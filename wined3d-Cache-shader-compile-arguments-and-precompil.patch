From 0c302b31ceedd8d024d2b694a08d5884191d94f1 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Michael=20M=C3=BCller?= <michael@fds-team.de>
Date: Fri, 6 Oct 2017 04:45:05 +0200
Subject: wined3d: Cache shader compile arguments and precompile shaders.

---
 dlls/wined3d/arb_program_shader.c |   2 +-
 dlls/wined3d/glsl_shader.c        | 425 ++++++++++++++++++++++++++++----------
 dlls/wined3d/shader.c             |  51 ++++-
 dlls/wined3d/wined3d_private.h    |   4 +-
 4 files changed, 363 insertions(+), 119 deletions(-)

diff --git a/dlls/wined3d/arb_program_shader.c b/dlls/wined3d/arb_program_shader.c
index 8f2f0e804e..75d7814ed9 100644
--- a/dlls/wined3d/arb_program_shader.c
+++ b/dlls/wined3d/arb_program_shader.c
@@ -5659,7 +5659,7 @@ static BOOL shader_arb_has_ffp_proj_control(void *shader_priv)
     return priv->ffp_proj_control;
 }
 
-static void shader_arb_precompile(void *shader_priv, struct wined3d_shader *shader) {}
+static void shader_arb_precompile(void *shader_priv, struct wined3d_shader *shader, const struct wined3d_state *state) {}
 
 const struct wined3d_shader_backend_ops arb_program_shader_backend =
 {
diff --git a/dlls/wined3d/glsl_shader.c b/dlls/wined3d/glsl_shader.c
index b3952fa4d8..016902a1e8 100644
--- a/dlls/wined3d/glsl_shader.c
+++ b/dlls/wined3d/glsl_shader.c
@@ -132,6 +132,8 @@ struct shader_glsl_priv
     struct wine_rb_tree ffp_fragment_shaders;
     BOOL ffp_proj_control;
     BOOL legacy_lighting;
+
+    HKEY key_cache;
 };
 
 struct glsl_vs_program
@@ -274,12 +276,16 @@ struct glsl_ps_compiled_shader
     struct ps_compile_args          args;
     struct ps_np2fixup_info         np2fixup;
     GLuint                          id;
+    DWORD                           select_count;
+    BOOL                            config_load;
 };
 
 struct glsl_vs_compiled_shader
 {
     struct vs_compile_args          args;
     GLuint                          id;
+    DWORD                           select_count;
+    BOOL                            config_load;
 };
 
 struct glsl_hs_compiled_shader
@@ -291,12 +297,16 @@ struct glsl_ds_compiled_shader
 {
     struct ds_compile_args args;
     GLuint id;
+    DWORD  select_count;
+    BOOL   config_load;
 };
 
 struct glsl_gs_compiled_shader
 {
     struct gs_compile_args args;
     GLuint id;
+    DWORD  select_count;
+    BOOL   config_load;
 };
 
 struct glsl_cs_compiled_shader
@@ -7861,7 +7871,8 @@ static GLuint shader_glsl_generate_compute_shader(const struct wined3d_context *
 static GLuint find_glsl_pshader(const struct wined3d_context *context,
         struct wined3d_string_buffer *buffer, struct wined3d_string_buffer_list *string_buffers,
         struct wined3d_shader *shader,
-        const struct ps_compile_args *args, const struct ps_np2fixup_info **np2fixup_info)
+        const struct ps_compile_args *args, const struct ps_np2fixup_info **np2fixup_info,
+        BOOL config_load)
 {
     struct glsl_ps_compiled_shader *gl_shaders, *new_array;
     struct glsl_shader_private *shader_data;
@@ -7892,6 +7903,7 @@ static GLuint find_glsl_pshader(const struct wined3d_context *context,
         {
             if (args->np2_fixup)
                 *np2fixup_info = &gl_shaders[i].np2fixup;
+            gl_shaders[i].select_count++;
             return gl_shaders[i].id;
         }
     }
@@ -7920,6 +7932,7 @@ static GLuint find_glsl_pshader(const struct wined3d_context *context,
     }
 
     gl_shaders[shader_data->num_gl_shaders].args = *args;
+    gl_shaders[shader_data->num_gl_shaders].config_load = config_load;
 
     np2fixup = &gl_shaders[shader_data->num_gl_shaders].np2fixup;
     memset(np2fixup, 0, sizeof(*np2fixup));
@@ -7953,7 +7966,7 @@ static inline BOOL vs_args_equal(const struct vs_compile_args *stored, const str
 }
 
 static GLuint find_glsl_vshader(const struct wined3d_context *context, struct shader_glsl_priv *priv,
-        struct wined3d_shader *shader, const struct vs_compile_args *args)
+        struct wined3d_shader *shader, const struct vs_compile_args *args, BOOL config_load)
 {
     UINT i;
     DWORD new_size;
@@ -7981,7 +7994,10 @@ static GLuint find_glsl_vshader(const struct wined3d_context *context, struct sh
     for (i = 0; i < shader_data->num_gl_shaders; ++i)
     {
         if (vs_args_equal(&gl_shaders[i].args, args, use_map))
+        {
+            gl_shaders[i].select_count++;
             return gl_shaders[i].id;
+        }
     }
 
     TRACE("No matching GL shader found for shader %p, compiling a new shader.\n", shader);
@@ -8009,6 +8025,7 @@ static GLuint find_glsl_vshader(const struct wined3d_context *context, struct sh
     }
 
     gl_shaders[shader_data->num_gl_shaders].args = *args;
+    gl_shaders[shader_data->num_gl_shaders].config_load = config_load;
 
     string_buffer_clear(&priv->shader_buffer);
     ret = shader_glsl_generate_vshader(context, priv, shader, args);
@@ -8064,7 +8081,8 @@ static GLuint find_glsl_hull_shader(const struct wined3d_context *context,
 }
 
 static GLuint find_glsl_domain_shader(const struct wined3d_context *context,
-        struct shader_glsl_priv *priv, struct wined3d_shader *shader, const struct ds_compile_args *args)
+        struct shader_glsl_priv *priv, struct wined3d_shader *shader, const struct ds_compile_args *args,
+        BOOL config_load)
 {
     struct glsl_ds_compiled_shader *gl_shaders, *new_array;
     struct glsl_shader_private *shader_data;
@@ -8085,7 +8103,10 @@ static GLuint find_glsl_domain_shader(const struct wined3d_context *context,
     for (i = 0; i < shader_data->num_gl_shaders; ++i)
     {
         if (!memcmp(&gl_shaders[i].args, args, sizeof(*args)))
+        {
+            gl_shaders[i].select_count++;
             return gl_shaders[i].id;
+        }
     }
 
     TRACE("No matching GL shader found for shader %p, compiling a new shader.\n", shader);
@@ -8114,13 +8135,15 @@ static GLuint find_glsl_domain_shader(const struct wined3d_context *context,
     string_buffer_clear(&priv->shader_buffer);
     ret = shader_glsl_generate_domain_shader(context, priv, shader, args);
     gl_shaders[shader_data->num_gl_shaders].args = *args;
+    gl_shaders[shader_data->num_gl_shaders].config_load = config_load;
     gl_shaders[shader_data->num_gl_shaders++].id = ret;
 
     return ret;
 }
 
 static GLuint find_glsl_geometry_shader(const struct wined3d_context *context,
-        struct shader_glsl_priv *priv, struct wined3d_shader *shader, const struct gs_compile_args *args)
+        struct shader_glsl_priv *priv, struct wined3d_shader *shader, const struct gs_compile_args *args,
+        BOOL config_load)
 {
     struct glsl_gs_compiled_shader *gl_shaders, *new_array;
     struct glsl_shader_private *shader_data;
@@ -8141,7 +8164,10 @@ static GLuint find_glsl_geometry_shader(const struct wined3d_context *context,
     for (i = 0; i < shader_data->num_gl_shaders; ++i)
     {
         if (!memcmp(&gl_shaders[i].args, args, sizeof(*args)))
+        {
+            gl_shaders[i].select_count++;
             return gl_shaders[i].id;
+        }
     }
 
     TRACE("No matching GL shader found for shader %p, compiling a new shader.\n", shader);
@@ -8170,6 +8196,7 @@ static GLuint find_glsl_geometry_shader(const struct wined3d_context *context,
     string_buffer_clear(&priv->shader_buffer);
     ret = shader_glsl_generate_geometry_shader(context, priv, shader, args);
     gl_shaders[shader_data->num_gl_shaders].args = *args;
+    gl_shaders[shader_data->num_gl_shaders].config_load = config_load;
     gl_shaders[shader_data->num_gl_shaders++].id = ret;
 
     return ret;
@@ -9662,7 +9689,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
         vshader = state->shader[WINED3D_SHADER_TYPE_VERTEX];
 
         find_vs_compile_args(state, vshader, context->stream_info.swizzle_map, &vs_compile_args, d3d_info);
-        vs_id = find_glsl_vshader(context, priv, vshader, &vs_compile_args);
+        vs_id = find_glsl_vshader(context, priv, vshader, &vs_compile_args, FALSE);
         vs_list = &vshader->linked_programs;
     }
     else if (priv->vertex_pipe == &glsl_vertex_pipe)
@@ -9692,7 +9719,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
         struct ds_compile_args args;
 
         find_ds_compile_args(state, dshader, &args, context);
-        ds_id = find_glsl_domain_shader(context, priv, dshader, &args);
+        ds_id = find_glsl_domain_shader(context, priv, dshader, &args, FALSE);
     }
 
     gshader = state->shader[WINED3D_SHADER_TYPE_GEOMETRY];
@@ -9705,7 +9732,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
         struct gs_compile_args args;
 
         find_gs_compile_args(state, gshader, &args);
-        gs_id = find_glsl_geometry_shader(context, priv, gshader, &args);
+        gs_id = find_glsl_geometry_shader(context, priv, gshader, &args, FALSE);
     }
 
     if (!(context->shader_update_mask & (1u << WINED3D_SHADER_TYPE_PIXEL)) && ctx_data->glsl_program)
@@ -9722,7 +9749,7 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
         pshader = state->shader[WINED3D_SHADER_TYPE_PIXEL];
         find_ps_compile_args(state, pshader, context->stream_info.position_transformed, &ps_compile_args, context);
         ps_id = find_glsl_pshader(context, &priv->shader_buffer, &priv->string_buffers,
-                pshader, &ps_compile_args, &np2fixup_info);
+                pshader, &ps_compile_args, &np2fixup_info, FALSE);
         ps_list = &pshader->linked_programs;
     }
     else if (priv->fragment_pipe == &glsl_fragment_pipe
@@ -10043,10 +10070,106 @@ static void set_glsl_shader_program(const struct wined3d_context *context, const
     }
 }
 
-static void shader_glsl_precompile(void *shader_priv, struct wined3d_shader *shader)
+static HKEY get_shader_key(struct shader_glsl_priv *priv)
+{
+    static const WCHAR regpath[] = {'S','o','f','t','w','a','r','e','\\','W','i','n','e','\\',
+                                    'D','i','r','e','c','t','3','D','\\','S','h','a','d','e','r','C','a','c','h','e',0};
+    WCHAR module[MAX_PATH], *p, *basename;
+    HKEY key1, key2;
+    LONG ret;
+
+    if (priv->key_cache)
+        return priv->key_cache;
+
+    ret = RegCreateKeyExW(HKEY_CURRENT_USER, regpath, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &key1, NULL);
+    if (ret != ERROR_SUCCESS) return NULL;
+
+    GetModuleFileNameW(NULL, module, MAX_PATH);
+    basename = module;
+    for (p = basename; *p; p++)
+    {
+        if (*p == '\\')
+            basename = p + 1;
+    }
+
+    ret = RegCreateKeyExW(key1, basename, 0, NULL, 0, KEY_ALL_ACCESS, NULL, &key2, NULL);
+    RegCloseKey(key1);
+    if (ret != ERROR_SUCCESS) return NULL;
+
+    priv->key_cache = key2;
+    return key2;
+}
+
+static void get_shader_value_name(struct wined3d_shader *shader, char value_name[44])
+{
+    const char *prefix = shader_glsl_get_prefix(shader->reg_maps.shader_version.type);
+    int i;
+
+    strcpy(value_name, prefix);
+    value_name[2] = '_';
+    for (i = 0; i < sizeof(shader->hash); i++)
+        sprintf(&value_name[3+i*2], "%02x", shader->hash[i]);
+    value_name[43] = 0;
+}
+
+static BOOL shader_glsl_load_shader_config(struct shader_glsl_priv *priv, struct wined3d_shader *shader, void *data, DWORD len)
+{
+    DWORD version = (1 << 24) | len;
+    DWORD size = sizeof(version) + len;
+    char value_name[44];
+    BYTE *buffer;
+    LONG ret;
+    HKEY key;
+
+    if (!(key = get_shader_key(priv)))
+        return FALSE;
+
+    get_shader_value_name(shader, value_name);
+
+    if (!(buffer = HeapAlloc(GetProcessHeap(), 0, sizeof(version) + len)))
+        return FALSE;
+
+    ret = RegQueryValueExA(key, value_name, NULL, NULL, buffer, &size);
+    if (ret != ERROR_SUCCESS || size != sizeof(version) + len || *((DWORD *)buffer) != version)
+    {
+        HeapFree(GetProcessHeap(), 0, buffer);
+        return FALSE;
+    }
+
+    memcpy(data, buffer + sizeof(DWORD), len);
+    HeapFree(GetProcessHeap(), 0, buffer);
+    return TRUE;
+}
+
+static void shader_glsl_save_shader_config(struct shader_glsl_priv *priv, struct wined3d_shader *shader, void *data, DWORD len)
+{
+    DWORD version = (1 << 24) | len;
+    char value_name[44];
+    BYTE *buffer;
+    HKEY key;
+
+    if (!(key = get_shader_key(priv)))
+        return;
+
+    get_shader_value_name(shader, value_name);
+
+    if (!(buffer = HeapAlloc(GetProcessHeap(), 0, sizeof(version) + len)))
+        return;
+
+    memcpy(buffer, &version, sizeof(version));
+    memcpy(buffer + sizeof(version), data, len);
+
+    RegSetValueExA(key, value_name, 0, REG_BINARY, buffer, sizeof(version) + len);
+
+    HeapFree(GetProcessHeap(), 0, buffer);
+}
+
+static void shader_glsl_precompile(void *shader_priv, struct wined3d_shader *shader, const struct wined3d_state *state)
 {
     struct wined3d_device *device = shader->device;
+    struct shader_glsl_priv *priv = shader_priv;
     struct wined3d_context *context;
+    BOOL config_load;
 
     if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_COMPUTE)
     {
@@ -10054,6 +10177,57 @@ static void shader_glsl_precompile(void *shader_priv, struct wined3d_shader *sha
         shader_glsl_compile_compute_shader(shader_priv, context, shader);
         context_release(context);
     }
+    else if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_HULL)
+    {
+        context = context_acquire(device, NULL, 0);
+        find_glsl_hull_shader(context, priv, shader);
+        context_release(context);
+    }
+    else if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_DOMAIN)
+    {
+        struct ds_compile_args args;
+
+        config_load = shader_glsl_load_shader_config(priv, shader, &args, sizeof(args));
+        if (!config_load) return;
+
+        context = context_acquire(device, NULL, 0);
+        find_glsl_domain_shader(context, priv, shader, &args, config_load);
+        context_release(context);
+    }
+    else if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_GEOMETRY)
+    {
+        struct gs_compile_args args;
+
+        config_load = shader_glsl_load_shader_config(priv, shader, &args, sizeof(args));
+        if (!config_load) return;
+
+        context = context_acquire(device, NULL, 0);
+        find_glsl_geometry_shader(context, priv, shader, &args, config_load);
+        context_release(context);
+    }
+    else if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_VERTEX)
+    {
+        struct vs_compile_args args;
+
+        config_load = shader_glsl_load_shader_config(priv, shader, &args, sizeof(args));
+        if (!config_load) return;
+
+        context = context_acquire(device, NULL, 0);
+        find_glsl_vshader(context, priv, shader, &args, config_load);
+        context_release(context);
+    }
+    else if (shader->reg_maps.shader_version.type == WINED3D_SHADER_TYPE_PIXEL)
+    {
+        const struct ps_np2fixup_info *np2fixup_info = NULL;
+        struct ps_compile_args args;
+
+        config_load = shader_glsl_load_shader_config(priv, shader, &args, sizeof(args));
+        if (!config_load) return;
+
+        context = context_acquire(device, NULL, 0);
+        find_glsl_pshader(context, &priv->shader_buffer, &priv->string_buffers, shader, &args, &np2fixup_info, config_load);
+        context_release(context);
+    }
 }
 
 /* Context activation is done by the caller. */
@@ -10198,9 +10372,12 @@ static void shader_glsl_destroy(struct wined3d_shader *shader)
     struct glsl_shader_private *shader_data = shader->backend_data;
     struct wined3d_device *device = shader->device;
     struct shader_glsl_priv *priv = device->shader_priv;
+    struct glsl_shader_prog_link *entry, *entry2;
     const struct wined3d_gl_info *gl_info;
     const struct list *linked_programs;
     struct wined3d_context *context;
+    DWORD highest_count = 0;
+    UINT i, max_id;
 
     if (!shader_data || !shader_data->num_gl_shaders)
     {
@@ -10212,153 +10389,176 @@ static void shader_glsl_destroy(struct wined3d_shader *shader)
     context = context_acquire(device, NULL, 0);
     gl_info = context->gl_info;
 
-    TRACE("Deleting linked programs.\n");
+    TRACE("Deleting linked programs and shaders.\n");
     linked_programs = &shader->linked_programs;
-    if (linked_programs->next)
+    switch (shader->reg_maps.shader_version.type)
     {
-        struct glsl_shader_prog_link *entry, *entry2;
-        UINT i;
-
-        switch (shader->reg_maps.shader_version.type)
+        case WINED3D_SHADER_TYPE_PIXEL:
         {
-            case WINED3D_SHADER_TYPE_PIXEL:
-            {
-                struct glsl_ps_compiled_shader *gl_shaders = shader_data->gl_shaders.ps;
+            struct glsl_ps_compiled_shader *gl_shaders = shader_data->gl_shaders.ps;
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting pixel shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.ps);
-
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, ps.shader_entry)
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting pixel shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
+                if (gl_shaders[i].select_count > highest_count)
                 {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
+                    highest_count = gl_shaders[i].select_count;
+                    max_id = i;
                 }
-
-                break;
             }
+            if (highest_count && !gl_shaders[max_id].config_load)
+                shader_glsl_save_shader_config(priv, shader, &gl_shaders[max_id].args, sizeof(gl_shaders[max_id].args));
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.ps);
 
-            case WINED3D_SHADER_TYPE_VERTEX:
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, ps.shader_entry)
             {
-                struct glsl_vs_compiled_shader *gl_shaders = shader_data->gl_shaders.vs;
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting vertex shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.vs);
+            break;
+        }
+
+        case WINED3D_SHADER_TYPE_VERTEX:
+        {
+            struct glsl_vs_compiled_shader *gl_shaders = shader_data->gl_shaders.vs;
 
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, vs.shader_entry)
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting vertex shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
+                if (gl_shaders[i].select_count > highest_count)
                 {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
+                    highest_count = gl_shaders[i].select_count;
+                    max_id = i;
                 }
-
-                break;
             }
+            if (highest_count && !gl_shaders[max_id].config_load)
+                shader_glsl_save_shader_config(priv, shader, &gl_shaders[max_id].args, sizeof(gl_shaders[max_id].args));
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.vs);
 
-            case WINED3D_SHADER_TYPE_HULL:
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, vs.shader_entry)
             {
-                struct glsl_hs_compiled_shader *gl_shaders = shader_data->gl_shaders.hs;
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting hull shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.hs);
+            break;
+        }
 
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, hs.shader_entry)
-                {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
-                }
+        case WINED3D_SHADER_TYPE_HULL:
+        {
+            struct glsl_hs_compiled_shader *gl_shaders = shader_data->gl_shaders.hs;
 
-                break;
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting hull shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
             }
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.hs);
 
-            case WINED3D_SHADER_TYPE_DOMAIN:
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, hs.shader_entry)
             {
-                struct glsl_ds_compiled_shader *gl_shaders = shader_data->gl_shaders.ds;
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting domain shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.ds);
+            break;
+        }
 
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, ds.shader_entry)
+        case WINED3D_SHADER_TYPE_DOMAIN:
+        {
+            struct glsl_ds_compiled_shader *gl_shaders = shader_data->gl_shaders.ds;
+
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting domain shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
+                if (gl_shaders[i].select_count > highest_count)
                 {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
+                    highest_count = gl_shaders[i].select_count;
+                    max_id = i;
                 }
-
-                break;
             }
+            if (highest_count && !gl_shaders[max_id].config_load)
+                shader_glsl_save_shader_config(priv, shader, &gl_shaders[max_id].args, sizeof(gl_shaders[max_id].args));
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.ds);
 
-            case WINED3D_SHADER_TYPE_GEOMETRY:
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, ds.shader_entry)
             {
-                struct glsl_gs_compiled_shader *gl_shaders = shader_data->gl_shaders.gs;
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting geometry shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.gs);
+            break;
+        }
 
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, gs.shader_entry)
+        case WINED3D_SHADER_TYPE_GEOMETRY:
+        {
+            struct glsl_gs_compiled_shader *gl_shaders = shader_data->gl_shaders.gs;
+
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting geometry shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
+                if (gl_shaders[i].select_count > highest_count)
                 {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
+                    highest_count = gl_shaders[i].select_count;
+                    max_id = i;
                 }
-
-                break;
             }
+            if (highest_count && !gl_shaders[max_id].config_load)
+                shader_glsl_save_shader_config(priv, shader, &gl_shaders[max_id].args, sizeof(gl_shaders[max_id].args));
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.gs);
 
-            case WINED3D_SHADER_TYPE_COMPUTE:
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, gs.shader_entry)
             {
-                struct glsl_cs_compiled_shader *gl_shaders = shader_data->gl_shaders.cs;
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
 
-                for (i = 0; i < shader_data->num_gl_shaders; ++i)
-                {
-                    TRACE("Deleting compute shader %u.\n", gl_shaders[i].id);
-                    GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
-                    checkGLcall("glDeleteShader");
-                }
-                HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.cs);
+            break;
+        }
 
-                LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
-                        struct glsl_shader_prog_link, cs.shader_entry)
-                {
-                    shader_glsl_invalidate_contexts_program(device, entry);
-                    delete_glsl_program_entry(priv, gl_info, entry);
-                }
+        case WINED3D_SHADER_TYPE_COMPUTE:
+        {
+            struct glsl_cs_compiled_shader *gl_shaders = shader_data->gl_shaders.cs;
 
-                break;
+            for (i = 0; i < shader_data->num_gl_shaders; ++i)
+            {
+                TRACE("Deleting compute shader %u.\n", gl_shaders[i].id);
+                GL_EXTCALL(glDeleteShader(gl_shaders[i].id));
+                checkGLcall("glDeleteShader");
             }
+            HeapFree(GetProcessHeap(), 0, shader_data->gl_shaders.cs);
 
-            default:
-                ERR("Unhandled shader type %#x.\n", shader->reg_maps.shader_version.type);
-                break;
+            LIST_FOR_EACH_ENTRY_SAFE(entry, entry2, linked_programs,
+                    struct glsl_shader_prog_link, cs.shader_entry)
+            {
+                shader_glsl_invalidate_contexts_program(device, entry);
+                delete_glsl_program_entry(priv, gl_info, entry);
+            }
+
+            break;
         }
+
+        default:
+            ERR("Unhandled shader type %#x.\n", shader->reg_maps.shader_version.type);
+            break;
     }
 
+
     HeapFree(GetProcessHeap(), 0, shader->backend_data);
     shader->backend_data = NULL;
 
@@ -10509,6 +10709,7 @@ static void shader_glsl_free(struct wined3d_device *device)
     string_buffer_free(&priv->shader_buffer);
     priv->fragment_pipe->free_private(device);
     priv->vertex_pipe->vp_free(device);
+    if (priv->key_cache) RegCloseKey(priv->key_cache);
 
     HeapFree(GetProcessHeap(), 0, device->shader_priv);
     device->shader_priv = NULL;
diff --git a/dlls/wined3d/shader.c b/dlls/wined3d/shader.c
index 687efbc351..dd78d752e1 100644
--- a/dlls/wined3d/shader.c
+++ b/dlls/wined3d/shader.c
@@ -33,6 +33,18 @@
 
 WINE_DEFAULT_DEBUG_CHANNEL(d3d_shader);
 
+typedef struct
+{
+   ULONG Unknown[6];
+   ULONG State[5];
+   ULONG Count[2];
+   UCHAR Buffer[64];
+} SHA_CTX;
+
+VOID WINAPI A_SHAInit(SHA_CTX *ctx);
+VOID WINAPI A_SHAUpdate(SHA_CTX *ctx, const UCHAR *buffer, UINT size);
+VOID WINAPI A_SHAFinal(SHA_CTX *ctx, PULONG result);
+
 /* pow, mul_high, sub_high, mul_low */
 const float wined3d_srgb_const0[] = {0.41666f, 1.055f, 0.055f, 12.92f};
 /* cmp */
@@ -3077,7 +3089,7 @@ struct shader_none_priv
 };
 
 static void shader_none_handle_instruction(const struct wined3d_shader_instruction *ins) {}
-static void shader_none_precompile(void *shader_priv, struct wined3d_shader *shader) {}
+static void shader_none_precompile(void *shader_priv, struct wined3d_shader *shader, const struct wined3d_state *state) {}
 static void shader_none_select_compute(void *shader_priv, struct wined3d_context *context,
         const struct wined3d_state *state) {}
 static void shader_none_update_float_vertex_constants(struct wined3d_device *device, UINT start, UINT count) {}
@@ -3306,8 +3318,14 @@ static void wined3d_shader_init_object(void *object)
     struct wined3d_device *device = shader->device;
 
     list_add_head(&device->shaders, &shader->shader_list_entry);
+}
+
+static void wined3d_shader_precompile(void *object)
+{
+    struct wined3d_shader *shader = object;
+    struct wined3d_device *device = shader->device;
 
-    device->shader_backend->shader_precompile(device->shader_priv, shader);
+    device->shader_backend->shader_precompile(device->shader_priv, shader, &device->state);
 }
 
 static void wined3d_shader_destroy_object(void *object)
@@ -3514,6 +3532,15 @@ static HRESULT shader_signature_copy(struct wined3d_shader_signature *dst,
     return WINED3D_OK;
 }
 
+static void shader_calculate_hash(struct wined3d_shader *shader)
+{
+    SHA_CTX ctx;
+
+    A_SHAInit(&ctx);
+    A_SHAUpdate(&ctx, (UCHAR *)shader->function, shader->functionLength);
+    A_SHAFinal(&ctx, (ULONG *)shader->hash);
+}
+
 static HRESULT shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
         const struct wined3d_shader_desc *desc, DWORD float_const_count, enum wined3d_shader_type type,
         void *parent, const struct wined3d_parent_ops *parent_ops)
@@ -3620,6 +3647,8 @@ static HRESULT shader_init(struct wined3d_shader *shader, struct wined3d_device
 
     shader->load_local_constsF = shader->lconst_inf_or_nan;
 
+    shader_calculate_hash(shader);
+
     wined3d_cs_init_object(shader->device->cs, wined3d_shader_init_object, shader);
 
     return hr;
@@ -3651,19 +3680,25 @@ static HRESULT vertex_shader_init(struct wined3d_shader *shader, struct wined3d_
     if (reg_maps->usesrelconstF && !list_empty(&shader->constantsF))
         shader->load_local_constsF = TRUE;
 
+    wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+
     return WINED3D_OK;
 }
 
 static HRESULT domain_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
         const struct wined3d_shader_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
-    return shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_DOMAIN, parent, parent_ops);
+    HRESULT hr = shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_DOMAIN, parent, parent_ops);
+    if (SUCCEEDED(hr)) wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+    return hr;
 }
 
 static HRESULT hull_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
         const struct wined3d_shader_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
-    return shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_HULL, parent, parent_ops);
+    HRESULT hr = shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_HULL, parent, parent_ops);
+    if (SUCCEEDED(hr)) wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+    return hr;
 }
 
 static HRESULT geometry_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
@@ -3689,6 +3724,8 @@ static HRESULT geometry_shader_init(struct wined3d_shader *shader, struct wined3
         memcpy(elements, so_desc->elements, so_desc->element_count * sizeof(*elements));
     }
 
+    wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+
     return WINED3D_OK;
 }
 
@@ -4007,6 +4044,8 @@ static HRESULT pixel_shader_init(struct wined3d_shader *shader, struct wined3d_d
         }
     }
 
+    wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+
     return WINED3D_OK;
 }
 
@@ -4044,7 +4083,9 @@ void pixelshader_update_resource_types(struct wined3d_shader *shader, WORD tex_t
 static HRESULT compute_shader_init(struct wined3d_shader *shader, struct wined3d_device *device,
         const struct wined3d_shader_desc *desc, void *parent, const struct wined3d_parent_ops *parent_ops)
 {
-    return shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_COMPUTE, parent, parent_ops);
+    HRESULT hr = shader_init(shader, device, desc, 0, WINED3D_SHADER_TYPE_COMPUTE, parent, parent_ops);
+    if (SUCCEEDED(hr)) wined3d_cs_init_object(shader->device->cs, wined3d_shader_precompile, shader);
+    return hr;
 }
 
 HRESULT CDECL wined3d_shader_create_cs(struct wined3d_device *device, const struct wined3d_shader_desc *desc,
diff --git a/dlls/wined3d/wined3d_private.h b/dlls/wined3d/wined3d_private.h
index 09ae7a23b8..a4d059e004 100644
--- a/dlls/wined3d/wined3d_private.h
+++ b/dlls/wined3d/wined3d_private.h
@@ -1390,7 +1390,7 @@ struct wined3d_vertex_pipe_ops;
 struct wined3d_shader_backend_ops
 {
     void (*shader_handle_instruction)(const struct wined3d_shader_instruction *);
-    void (*shader_precompile)(void *shader_priv, struct wined3d_shader *shader);
+    void (*shader_precompile)(void *shader_priv, struct wined3d_shader *shader, const struct wined3d_state *state);
     void (*shader_select)(void *shader_priv, struct wined3d_context *context,
             const struct wined3d_state *state);
     void (*shader_select_compute)(void *shader_priv, struct wined3d_context *context,
@@ -4037,6 +4037,8 @@ struct wined3d_shader
     struct wined3d_device *device;
     struct list shader_list_entry;
 
+    BYTE hash[20];
+
     union
     {
         struct wined3d_vertex_shader vs;
-- 
2.14.1

