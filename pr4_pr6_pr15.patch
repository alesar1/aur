diff --git a/imaplib2/imaplib2.py b/imaplib2/imaplib2.py
index 1fd47d2..d076e40 100755
--- a/imaplib2/imaplib2.py
+++ b/imaplib2/imaplib2.py
@@ -67,7 +67,6 @@ if bytes != str:
 else:
     import Queue as queue
     string_types = basestring
-    threading.TIMEOUT_MAX = 9223372036854.0
 
 select_module = select
 
@@ -192,7 +191,7 @@ class Request(object):
     def get_response(self, exc_fmt=None):
         self.callback = None
         if __debug__: self.parent._log(3, '%s:%s.ready.wait' % (self.name, self.tag))
-        self.ready.wait(threading.TIMEOUT_MAX)
+        self.ready.wait()
 
         if self.aborted is not None:
             typ, val = self.aborted
@@ -545,7 +544,16 @@ class IMAP4(object):
 
             ssl_version =  TLS_MAP[self.tls_level][self.ssl_version]
 
-            self.sock = ssl.wrap_socket(self.sock, self.keyfile, self.certfile, ca_certs=self.ca_certs, cert_reqs=cert_reqs, ssl_version=ssl_version)
+            if getattr(ssl, 'HAS_SNI', False):
+                ctx = ssl.SSLContext(ssl_version)
+                ctx.verify_mode = cert_reqs
+                if self.ca_certs is not None:
+                    ctx.load_verify_locations(self.ca_certs)
+                if self.certfile or self.keyfile:
+                    ctx.load_cert_chain(self.certfile, self.keyfile)
+                self.sock = ctx.wrap_socket(self.sock, server_hostname=self.host)
+            else:
+                self.sock = ssl.wrap_socket(self.sock, self.keyfile, self.certfile, ca_certs=self.ca_certs, cert_reqs=cert_reqs, ssl_version=ssl_version)
             ssl_exc = ssl.SSLError
             self.read_fd = self.sock.fileno()
         except ImportError:
@@ -1391,7 +1399,7 @@ class IMAP4(object):
             self.commands_lock.release()
             if need_event:
                 if __debug__: self._log(3, 'sync command %s waiting for empty commands Q' % name)
-                self.state_change_free.wait(threading.TIMEOUT_MAX)
+                self.state_change_free.wait()
                 if __debug__: self._log(3, 'sync command %s proceeding' % name)
 
         if self.state not in Commands[name][CMD_VAL_STATES]:
diff --git a/imaplib2/imaplib2.py3 b/imaplib2/imaplib2.py3
index 9de6702..6d44349 100755
--- a/imaplib2/imaplib2.py3
+++ b/imaplib2/imaplib2.py3
@@ -16,7 +16,7 @@ Public functions: Internaldate2Time
 
 __all__ = ("IMAP4", "IMAP4_SSL", "IMAP4_stream",
            "Internaldate2Time", "ParseFlags", "Time2Internaldate",
-           "Mon2num", "MonthNames", "InternalDate")
+           "Mon2num", "MonthNames", "InternalDate", "version")
 
 __version__ = "3.06"
 __release__ = "3"
@@ -138,6 +138,26 @@ Commands = {
 UID_direct = ('SEARCH', 'SORT', 'THREAD')
 
 
+def version(use_tuple=False):
+    """Return the version of this module.
+
+    Arguments
+    ---------
+    use_tuple : bool
+        Whether to return a string or a tuple of (major, minor). When True, the major and minor in the tuple will be
+        integers rather than strings.
+
+    Returns
+    -------
+    The version.
+    """
+
+    if use_tuple:
+        return (int(__release__), int(__revision__))
+
+    return __version__
+
+
 def Int2AP(num):
 
     """string = Int2AP(num)
@@ -183,7 +203,7 @@ class Request(object):
     def get_response(self, exc_fmt=None):
         self.callback = None
         if __debug__: self.parent._log(3, '%s:%s.ready.wait' % (self.name, self.tag))
-        self.ready.wait(threading.TIMEOUT_MAX)
+        self.ready.wait()
 
         if self.aborted is not None:
             typ, val = self.aborted
@@ -493,7 +513,17 @@ class IMAP4(object):
 
             ssl_version =  TLS_MAP[self.tls_level][self.ssl_version]
 
-            self.sock = ssl.wrap_socket(self.sock, self.keyfile, self.certfile, ca_certs=self.ca_certs, cert_reqs=cert_reqs, ssl_version=ssl_version)
+            if getattr(ssl, 'HAS_SNI', False):
+                ctx = ssl.SSLContext(ssl_version)
+                ctx.verify_mode = cert_reqs
+                if self.ca_certs is not None:
+                    ctx.load_verify_locations(self.ca_certs)
+                if self.certfile or self.keyfile:
+                    ctx.load_cert_chain(self.certfile, self.keyfile)
+                self.sock = ctx.wrap_socket(self.sock, server_hostname=self.host)
+            else:
+                self.sock = ssl.wrap_socket(self.sock, self.keyfile, self.certfile, ca_certs=self.ca_certs, cert_reqs=cert_reqs, ssl_version=ssl_version)
+
             ssl_exc = ssl.SSLError
             self.read_fd = self.sock.fileno()
         except ImportError:
@@ -1317,7 +1347,7 @@ class IMAP4(object):
             self.commands_lock.release()
             if need_event:
                 if __debug__: self._log(3, 'sync command %s waiting for empty commands Q' % name)
-                self.state_change_free.wait(threading.TIMEOUT_MAX)
+                self.state_change_free.wait()
                 if __debug__: self._log(3, 'sync command %s proceeding' % name)
 
         if self.state not in Commands[name][CMD_VAL_STATES]:
