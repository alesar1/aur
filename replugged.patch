diff --git a/src/Powercord/apis/commands.js b/src/Powercord/apis/commands.js
index 5a8dc903..f0ee6ee9 100644
--- a/src/Powercord/apis/commands.js
+++ b/src/Powercord/apis/commands.js
@@ -53,9 +53,6 @@ class CommandsAPI extends API {
    * @param {PowercordChatCommand} command Command to register
    */
   registerCommand (command) {
-    // @todo: remove this once there's a proper implemention (if any) for fetching the command origin.
-    const stackTrace = (new Error()).stack;
-    const [ , origin ] = stackTrace.match(new RegExp(`${global._.escapeRegExp(powercord.pluginManager.pluginDir)}.([-\\w]+)`)) || stackTrace.match(new RegExp(`${global._.escapeRegExp(join(__dirname, '../coremods'))}.([-\\w]+)`));
 
     if (typeof command === 'string') {
       console.error('no');
diff --git a/src/Powercord/coremods/moduleManager/components/manage/Base.jsx b/src/Powercord/coremods/moduleManager/components/manage/Base.jsx
index f5750344..3e69cf77 100644
--- a/src/Powercord/coremods/moduleManager/components/manage/Base.jsx
+++ b/src/Powercord/coremods/moduleManager/components/manage/Base.jsx
@@ -3,6 +3,7 @@ const { shell } = require('electron');
 const { React, getModule, contextMenu, i18n: { Messages } } = require('powercord/webpack');
 const { Button, Tooltip, ContextMenu, Divider, Icons: { Overflow } } = require('powercord/components');
 const { TextInput } = require('powercord/components/settings');
+const XDG_DATA_HOME = process.env.XDG_DATA_HOME || join(process.env.HOME, '.local', 'share');
 
 class Base extends React.Component {
   constructor () {
@@ -91,7 +92,7 @@ class Base extends React.Component {
           {
             type: 'button',
             name: Messages[`REPLUGGED_${this.state.key}_OPEN_FOLDER`],
-            onClick: () => shell.openPath(join(__dirname, '..', '..', '..', '..', this.constructor.name.toLowerCase()))
+            onClick: () => shell.openPath(join(XDG_DATA_HOME, 'replugged', this.constructor.name.toLowerCase()))
           },
           {
             type: 'button',
diff --git a/src/Powercord/coremods/moduleManager/index.js b/src/Powercord/coremods/moduleManager/index.js
index f3a2aa2b..61d7f3db 100644
--- a/src/Powercord/coremods/moduleManager/index.js
+++ b/src/Powercord/coremods/moduleManager/index.js
@@ -6,7 +6,7 @@ const { React, getModule, i18n: { Messages } } = require('powercord/webpack');
 const { PopoutWindow } = require('powercord/components');
 const { inject, uninject } = require('powercord/injector');
 const { findInReactTree, forceUpdateElement } = require('powercord/util');
-const { SpecialChannels: { CSS_SNIPPETS, STORE_PLUGINS, STORE_THEMES }, WEBSITE } = require('powercord/constants');
+const { SpecialChannels: { CSS_SNIPPETS, STORE_PLUGINS, STORE_THEMES }, WEBSITE, SETTINGS_FOLDER } = require('powercord/constants');
 const { join } = require('path');
 const commands = require('./commands');
 const deeplinks = require('./deeplinks');
@@ -23,7 +23,7 @@ const { injectContextMenu } = require('powercord/util');
 const Menu = getModule([ 'MenuItem' ], false);
 
 let _quickCSS = '';
-const _quickCSSFile = join(__dirname, 'quickcss.css');
+const _quickCSSFile = join(SETTINGS_FOLDER, 'quickcss.css');
 let _quickCSSElement;
 
 async function _installerInjectCtxMenu () {
diff --git a/src/Powercord/coremods/moduleManager/util/cloneRepo.js b/src/Powercord/coremods/moduleManager/util/cloneRepo.js
index b3b9743f..0ce92e71 100644
--- a/src/Powercord/coremods/moduleManager/util/cloneRepo.js
+++ b/src/Powercord/coremods/moduleManager/util/cloneRepo.js
@@ -3,15 +3,17 @@ const { spawn } = require('child_process');
 const fs = require('fs');
 const { REPO_URL_REGEX } = require('./misc');
 
+const XDG_DATA_HOME = process.env.XDG_DATA_HOME || join(process.env.HOME, '.local', 'share');
+
 module.exports = async function download (url, powercord, type) {
   // const dir = type === 'plugin' ? join(__dirname, '..', '..') : join(__dirname, '..', '..', 'themes');
   let dir;
   switch (type) {
     case 'plugin':
-      dir = join(__dirname, '..', '..', '..', 'plugins');
+      dir = join(XDG_DATA_HOME, 'replugged', 'plugins');
       break;
     case 'theme':
-      dir = join(__dirname, '..', '..', '..', 'themes');
+      dir = join(XDG_DATA_HOME, 'replugged', 'themes');
       break;
   }
 
diff --git a/src/Powercord/coremods/updater/components/Settings.jsx b/src/Powercord/coremods/updater/components/Settings.jsx
index 7c021676..7635380d 100644
--- a/src/Powercord/coremods/updater/components/Settings.jsx
+++ b/src/Powercord/coremods/updater/components/Settings.jsx
@@ -82,7 +82,7 @@ module.exports = class UpdaterSettings extends React.PureComponent {
         <div className="about">
           <div>
             <span>{Messages.REPLUGGED_UPDATES_UPSTREAM}</span>
-            <span>{powercord.gitInfos.upstream.replace(REPO_URL, Messages.REPLUGGED_UPDATES_UPSTREAM_OFFICIAL)}</span>
+            <span>{powercord.gitInfos.upstream.replace(REPO_URL, Messages.REPLUGGED_UPDATES_UPSTREAM_OFFICIAL+' (AUR)')}</span>
           </div>
           <div>
             <span>{Messages.REPLUGGED_UPDATES_REVISION}</span>
diff --git a/src/Powercord/coremods/updater/components/Update.jsx b/src/Powercord/coremods/updater/components/Update.jsx
index 7d8fbcaa..ab5be0e9 100644
--- a/src/Powercord/coremods/updater/components/Update.jsx
+++ b/src/Powercord/coremods/updater/components/Update.jsx
@@ -28,6 +28,7 @@ module.exports = class Update extends React.PureComponent {
         </div>
       </div>
       <div className='summary'>
+        {name === 'Powercord' ? <span>Note: Please download the update from the AUR!</span> : ''}
         {commits.map(commit => <div key={commit.id}>
           <a href={`https://github.com/${repo}/commit/${commit.id}`} target='_blank'>
             <code>{commit.id.substring(0, 7)}</code>
diff --git a/src/Powercord/coremods/updater/index.js b/src/Powercord/coremods/updater/index.js
index 113c2540..8b115124 100644
--- a/src/Powercord/coremods/updater/index.js
+++ b/src/Powercord/coremods/updater/index.js
@@ -124,14 +124,14 @@ class Updater {
     const updates = settings.get('updates', []);
     const failed = [];
     for (const update of [ ...updates ]) {
-      let entity = powercord;
+      let entity;
       if (update.id.startsWith('plugin')) {
         entity = powercord.pluginManager.get(update.id.replace('plugins_', ''));
       } else if (update.id.startsWith('theme')) {
         entity = powercord.styleManager.get(update.id.replace('themes_', ''));
       }
 
-      const success = await entity._update(force);
+      const success = entity ? await entity._update(force) : false;
       updates.shift();
       settings.get('updates', updates);
       if (!success) {
@@ -220,26 +220,10 @@ class Updater {
   }
 
   async getGitInfos () {
-    const branch = await PowercordNative.exec('git branch', this.cwd)
-      .then(({ stdout }) =>
-        stdout
-          .toString()
-          .split('\n')
-          .find(l => l.startsWith('*'))
-          .slice(2)
-          .trim()
-      );
-
-    const revision = await PowercordNative.exec(`git rev-parse ${branch}`, this.cwd)
-      .then(r => r.stdout.toString().trim());
-
-    const upstream = await PowercordNative.exec('git remote get-url origin', this.cwd)
-      .then(r => r.stdout.toString().match(/github\.com[:/]([\w-_]+\/[\w-_]+)/)[1]);
-
     return {
-      upstream,
-      branch,
-      revision
+      upstream: "replugged-org/replugged",
+      branch: "main",
+      revision: "237fe5c9ab6ae9026f3a7f4a19b0c416627d797f"
     };
   }
 
diff --git a/src/Powercord/index.js b/src/Powercord/index.js
index 55b18f57..11ad34c4 100644
--- a/src/Powercord/index.js
+++ b/src/Powercord/index.js
@@ -253,6 +253,32 @@ class Powercord extends Updatable {
     }
     return success;
   }
+
+  async _getUpdateCommits () {
+    return [];
+  }
+  async getBranch () {return this.gitInfos.branch;}
+  async getGitRepo () {return this.gitInfos.upstream;}
+  async _checkForUpdates () {
+    const abort = new AbortController();
+    const timeout = setTimeout(() => {
+      abort.abort();
+      throw new Error('Timed out.');
+    }, 10000);
+
+    try {
+      const latestCommitSha = await exec(`curl https://api.github.com/repos/${this.gitInfos.upstream}/commits/${this.gitInfos.branch} | jq -r .sha`, {
+        cwd: this.entityPath,
+        signal: abort.signal
+      }).then(({ stdout }) => stdout.toString());
+
+      clearTimeout(timeout);
+      return !latestCommitSha.includes(this.gitInfos.revision);
+    } catch (e) {
+      clearTimeout(timeout);
+      return false;
+    }
+  }
 }
 
 module.exports = Powercord;
diff --git a/src/Powercord/managers/plugins.js b/src/Powercord/managers/plugins.js
index 799b8947..605a8d2b 100644
--- a/src/Powercord/managers/plugins.js
+++ b/src/Powercord/managers/plugins.js
@@ -1,10 +1,12 @@
-const { resolve } = require('path');
+const { resolve, join } = require('path');
 const { readdirSync } = require('fs');
 const { rmdirRf } = require('powercord/util');
 
+const XDG_DATA_HOME = process.env.XDG_DATA_HOME || join(process.env.HOME, '.local', 'share');
+
 module.exports = class PluginManager {
   constructor () {
-    this.pluginDir = resolve(__dirname, '..', 'plugins');
+    this.pluginDir = resolve(XDG_DATA_HOME, 'replugged', 'plugins');
     this.plugins = new Map();
 
     this.manifestKeys = [ 'name', 'version', 'description', 'author', 'license' ];
diff --git a/src/Powercord/managers/styles.js b/src/Powercord/managers/styles.js
index e9475199..3a3a82c5 100644
--- a/src/Powercord/managers/styles.js
+++ b/src/Powercord/managers/styles.js
@@ -14,10 +14,12 @@ const ErrorTypes = Object.freeze({
   INVALID_MANIFEST: 'INVALID_MANIFEST'
 });
 
+const XDG_DATA_HOME = process.env.XDG_DATA_HOME || join(process.env.HOME, '.local', 'share');
+
 module.exports = class StyleManager {
   constructor () {
     this._coreStyles = [];
-    this.themesDir = join(__dirname, '../themes');
+    this.themesDir = join(XDG_DATA_HOME, 'replugged', 'themes');
     this.themes = new Map();
 
     if (!window.__SPLASH__) {
diff --git a/src/browserWindow.js b/src/browserWindow.js
index 82620e56..cafc41a0 100644
--- a/src/browserWindow.js
+++ b/src/browserWindow.js
@@ -28,7 +28,6 @@ class PatchedBrowserWindow extends BrowserWindow {
       if (opts.webPreferences.nativeWindowOpen) {
         // Discord Client
         opts.webPreferences.preload = join(__dirname, './preload.js');
-        opts.webPreferences.contextIsolation = false; // shrug
       } else {
         // Splash Screen on macOS (Host 0.0.262+) & Windows (Host 0.0.293 / 1.0.17+)
         opts.webPreferences.preload = join(__dirname, './preloadSplash.js');
diff --git a/src/fake_node_modules/powercord/constants.js b/src/fake_node_modules/powercord/constants.js
index e10288a8..add2b3f0 100644
--- a/src/fake_node_modules/powercord/constants.js
+++ b/src/fake_node_modules/powercord/constants.js
@@ -1,5 +1,9 @@
 const { join } = require('path');
 
+const XDG_CONFIG_HOME = process.env.XDG_CONFIG_HOME || join(process.env.HOME, '.config');
+const XDG_CACHE_HOME  = process.env.XDG_CACHE_HOME  || join(process.env.HOME, '.cache');
+const XDG_DATA_HOME  = process.env.XDG_DATA_HOME    || join(process.env.HOME, '.local', 'share');
+
 module.exports = Object.freeze({
   // Replugged
   WEBSITE: 'https://replugged.dev',
@@ -7,9 +11,9 @@ module.exports = Object.freeze({
   REPO_URL: 'replugged-org/replugged',
 
   // Runtime
-  SETTINGS_FOLDER: join(__dirname, '..', '..', '..', 'settings'),
-  CACHE_FOLDER: join(__dirname, '..', '..', '..', '.cache'),
-  LOGS_FOLDER: join(__dirname, '..', '..', '..', '.logs'),
+  SETTINGS_FOLDER: join(XDG_CONFIG_HOME, 'replugged'),
+  CACHE_FOLDER: join(XDG_CACHE_HOME, 'replugged'),
+  LOGS_FOLDER: join(XDG_DATA_HOME, 'replugged', 'logs'),
 
   // Discord Server
   DISCORD_INVITE: 'B2TcnXV9Rg',
diff --git a/src/fake_node_modules/powercord/webpack/index.js b/src/fake_node_modules/powercord/webpack/index.js
index efe6bfe6..7a2e0e62 100644
--- a/src/fake_node_modules/powercord/webpack/index.js
+++ b/src/fake_node_modules/powercord/webpack/index.js
@@ -1,210 +1,212 @@
-const { sleep } = require('powercord/util');
-const moduleFilters = require('./modules.json');
-
-/**
-* @typedef WebpackInstance
-* @property {object} cache
-* @property {function} require
-* @property {function} loadChunk
-*/
-
-/**
-* @typedef ContextMenuModule
-* @property {function} openContextMenu
-* @property {function} closeContextMenu
-*/
-
-
-/**
- * @typedef ModuleInfo
- * @property {number} id The module's id.
- * @property {boolean} loaded Whether the module is loaded
- * @property {object} exports The module's exports
- */
-
-/**
-* @typedef {number[]} chunkIds The chunk's ids.
-* @typedef {object.<number, function>} chunkMdls A map of module ids to module source functions.
-* @typedef {[chunkIds, chunkMdls]} Chunk
-*/
-
-/**
-* @property {ContextMenuModule} contextMenu
-* @property {WebpackInstance} instance
-*/
-const webpack = {
-  ...require('./lazy'),
-
-  /**
-  * Grabs a module from the Webpack store
-  * @param {function|string[]} filter Filter used to grab the module. Can be a function or an array of keys the object must have.
-  * @param {boolean} retry Whether or not to retry fetching if the module is not found. Each try will be delayed by 100ms and max retries is 20.
-  * @param {boolean} forever If Replugged should try to fetch the module forever. Should be used only if you're in early stages of startup.
-  * @returns {Promise<object>|object} The found module. A promise will always be returned, unless retry is false.
-  */
-  getModule (filter, retry = true, forever = false) {
-    if (Array.isArray(filter)) {
-      const keys = filter;
-      filter = m => keys.every(key => m.hasOwnProperty(key) || (m.__proto__ && m.__proto__.hasOwnProperty(key)));
-    }
-
-    if (!retry) {
-      return webpack._getModules(filter);
-    }
-
-    return new Promise(async (res) => {
-      let mdl;
-      for (let i = 0; i < 21; !forever && i++) {
-        mdl = webpack._getModules(filter);
-        if (mdl) {
-          return res(mdl);
-        }
-        await sleep(100);
-      }
-
-      res(mdl);
-    });
-  },
-
-  /**
-  * Grabs all found modules from the webpack store
-  * @param {function|string[]} filter Filter used to grab the module. Can be a function or an array of keys the object must have.
-  * @returns {object[]} The found modules.
-  */
-  getAllModules (filter) {
-    if (Array.isArray(filter)) {
-      const keys = filter;
-      filter = m => keys.every(key => m.hasOwnProperty(key) || (m.__proto__ && m.__proto__.hasOwnProperty(key)));
-    }
-
-    return webpack._getModules(filter, true);
-  },
-
-  /**
-  * Grabs a React component by its display name
-  * @param {string} displayName Component's display name.
-  * @param {boolean} retry Whether or not to retry fetching if the module is not found. Each try will be delayed by 100ms and max retries is 20.
-  * @param {boolean} forever If Replugged should try to fetch the module forever. Should be used only if you're in early stages of startup.
-  * @returns {Promise<object>|object} The component. A promise will always be returned, unless retry is false.
-  */
-  getModuleByDisplayName (displayName, retry = true, forever = false) {
-    return webpack.getModule(m => m.displayName && m.displayName.toLowerCase() === displayName.toLowerCase(), retry, forever);
-  },
-
+if (!global.NEW_BACKEND) {
+	module.exports = require('./old.webpack.js');
+	return;
+  }
+  
+  const { join } = require('path');
+  const { readFile } = require('fs').promises;
+  const { webFrame, contextBridge } = require('electron');
+  const { deserialize, freePointer, setCommandHandler } = require('./serialize.js');
+  const moduleFilters = require('./modules.json');
+  const MODULE_ID = Symbol.for('powercord.webpack.moduleId');
+  
   /**
-  * Grabs a React component's module info by its display name
-  * @param {string} displayName Component's display name.
-  * @returns {ModuleInfo} The module info.
-  */
-  getModuleInfoByDisplayName (displayName) {
-    return Object.values(webpack.instance.cache).find(m => m?.exports?.displayName === displayName || m?.exports?.default?.displayName === displayName);
-  },
-
+   * @typedef WebpackInstance
+   * @property {object} cache
+   * @property {function} require
+   */
+  
   /**
-  * Grabs a chunk by one of its modules' id
-  * @param {number} id The module id.
-  * @returns {Chunk} The chunk.
-  */
-  getChunkByModuleId (id) {
-    return webpackChunkdiscord_app.find((c) => id in c[1]);
-  },
-
+   * @typedef ContextMenuModule
+   * @property {function} openContextMenu
+   * @property {function} closeContextMenu
+   */
+  
+  // --
+  // Webpack interface
+  // --
+  let commandHandler = null;
+  const DISPLAY_NAME_FN = /=>\s*(?:\w+\??.(\w+)(?:\?\.|\s*&&\s*\w+\.\1\.)displayName|_optionalChain\(\[\w+, 'optionalAccess', _2 => _2\.(\w+), 'optionalAccess', _3 => _3\.displayName]\))\s*={2,3}\s*['"](.*)['"]/;
+  
+  function processResult (res, all) {
+	if (!res) {
+	  return res;
+	}
+  
+	if (res instanceof Promise) {
+	  return res.then((r) => processResult(r, all));
+	}
+  
+	if (all) {
+	  return res.map((r) => processResult(r));
+	}
+  
+	const mdl = deserialize(res[1]);
+	if (mdl && (typeof mdl === 'function' || typeof mdl === 'object')) {
+	  // eslint-disable-next-line prefer-destructuring
+	  mdl[MODULE_ID] = res[0];
+	}
+  
+	return mdl;
+  }
+  
   /**
-  * Gets the source function of a module by its id
-  * @param {number} id The module id.
-  * @returns {function} The source function.
-  */
-  getModuleSourceById (id) {
-    const chunk = webpack.getChunkByModuleId(id);
-    return chunk?.[1][id] ?? null;
-  },
-
+   * Grabs a module from the Webpack store
+   * @param {function|string[]} filter Filter used to grab the module. Can be a function or an array of keys the object must have.
+   * @param {boolean} retry Whether or not to retry fetching if the module is not found. Each try will be delayed by 100ms and max retries is 20.
+   * @param {boolean} forever If Replugged should try to fetch the module forever. Should be used only if you're in early stages of startup.
+   * @returns {Promise<object>|object} The found module. A promise will always be returned, unless retry is false.
+   */
+  function getModule (filter, retry = true, forever = false) {
+	if (typeof filter === 'function') {
+	  const match = filter.toString().match(DISPLAY_NAME_FN);
+	  if (match) {
+		const res = commandHandler('getModuleByDisplayNameRaw', match[1] || match[2], match[3], retry, forever);
+		return processResult(res);
+	  }
+  
+	  const _filter = filter;
+	  filter = (e) => !!_filter(deserialize(e));
+	}
+  
+	const res = commandHandler('getModule', filter, retry, forever);
+	return processResult(res);
+  }
+  
   /**
-  * From a given module id, gets a list of chunk ids that said module might lazy load.
-  * @param {number} id The module id.
-  * @returns {number[]} The 'to be lazy-loaded' chunk ids
-  */
-  getLazyLoadedChunkIdsByModuleId (id) {
-    const srcStr = webpack.getModuleSourceById(id)?.toString();
-    if (!srcStr) {
-      return [];
-    }
-    const requireArgument = srcStr.match(/^\(.,.,(.)\)/)?.[1];
-
-    if (!requireArgument) {
-      return [];
-    }
-
-    const importPattern = new RegExp(`\\b${requireArgument}\\.e\\(\\d+\\)`, 'g');
-    const imports = srcStr.match(importPattern);
-    const ids = imports.map(e => e.slice(4, -1));
-    return ids;
-  },
-
-
+   * Grabs all found modules from the webpack store
+   * @param {function|string[]} filter Filter used to grab the module. Can be a function or an array of keys the object must have.
+   * @returns {object[]} The found modules.
+   */
+  function getAllModules (filter) {
+	if (typeof filter === 'function') {
+	  const _filter = filter;
+	  filter = (e) => !!_filter(deserialize(e));
+	}
+  
+	const res = commandHandler('getAllModules', filter);
+	return processResult(res, true);
+  }
+  
   /**
-  * Initializes the injection into Webpack
-  * @returns {Promise<void>}
-  */
-  async init () {
-    delete webpack.init;
-
-    // Wait until webpack is ready
-    while (!window.webpackChunkdiscord_app || !window._) {
-      await sleep(100);
-    }
-
-    // Extract values from webpack
-    webpack.instance = {};
-    webpackChunkdiscord_app.push([
-      [ [ '_powercord' ] ],
-      {},
-      (r) => {
-        webpack.instance.cache = r.c;
-        webpack.instance.require = (m) => r(m);
-
-        webpack.instance.loadChunk = (c) => r.e(c)
-          .then(() => {
-            // Get chunk
-            const chunk = webpackChunkdiscord_app.find(C => `${C[0][0]}` === c);
-            // Cache all the modules
-            Object.keys(chunk[1]).forEach(m => r(m));
-          });
-      }
-    ]);
-    webpackChunkdiscord_app.pop();
-
-    // Patch push to enable webpack chunk listeners
-    webpack._patchPush();
-    delete webpack._patchPush;
-
-    // Load modules pre-fetched
-    for (const mdl in moduleFilters) {
-      // noinspection JSUnfilteredForInLoop
-      this[mdl] = await webpack.getModule(moduleFilters[mdl]);
-    }
-
-    this.i18n = webpack.getAllModules([ 'Messages', 'getLanguages' ]).find((m) => m.Messages.ACCOUNT);
-  },
-
-  _getModules (filter, all = false) {
-    const moduleInstances = Object.values(webpack.instance.cache).filter(m => m.exports);
-    if (all) {
-      const exports = moduleInstances.filter(m => filter(m.exports)).map(m => m.exports);
-      const expDefault = moduleInstances.filter(m => m.exports.default && filter(m.exports.default)).map(m => m.exports.default);
-      return exports.concat(expDefault);
-    }
-
-    const exports = moduleInstances.find(m => filter(m.exports));
-    if (exports) {
-      return exports.exports;
-    }
-    const expDefault = moduleInstances.find(m => m.exports.default && filter(m.exports.default));
-    if (expDefault) {
-      return expDefault.exports.default;
-    }
-    return null;
+   * Grabs a React component by its display name
+   * @param {string} displayName Component's display name.
+   * @param {boolean} retry Whether or not to retry fetching if the module is not found. Each try will be delayed by 100ms and max retries is 20.
+   * @param {boolean} forever If Replugged should try to fetch the module forever. Should be used only if you're in early stages of startup.
+   * @returns {Promise<object>|object} The component. A promise will always be returned, unless retry is false.
+   */
+  function getModuleByDisplayName (displayName, retry = true, forever = false) {
+	const res = commandHandler('getModuleByDisplayName', displayName.toLowerCase(), retry, forever);
+	return processResult(res);
+  }
+  
+  function getModuleById (id) {
+	const res = commandHandler('getModuleById', id);
+	return processResult(res);
   }
-};
-
-module.exports = webpack;
+  
+  let elementPointer = 0;
+  function lookupReactReference (element) {
+	if (!element) {
+	  return;
+	}
+  
+	if (!('__reactFiber$' in element)) {
+	  Object.defineProperty(element, '__reactFiber$', {
+		get: () => {
+		  element.dataset.powercordPointer = elementPointer;
+		  const res = commandHandler('lookupReactReference', elementPointer++);
+		  element.removeAttribute('data-powercord-pointer');
+		  return deserialize(res);
+		}
+	  });
+	}
+  }
+  
+  /**
+   * @property {ContextMenuModule} contextMenu
+   * @property {WebpackInstance} instance
+   */
+  const webpack = {
+	getModule,
+	getAllModules,
+	getModuleByDisplayName,
+	require: getModuleById,
+  
+	// Internal tape stuff
+	__lookupReactReference: lookupReactReference,
+  
+	/**
+	 * Initializes the injection into Webpack
+	 * @returns {Promise<void>}
+	 */
+	async init () {
+	  delete webpack.init;
+  
+	  // Init proxy script
+	  const serializeScript = await readFile(join(__dirname, 'serialize.js'), 'utf8');
+	  const proxyScript = await readFile(join(__dirname, 'proxy.js'), 'utf8');
+	  await webFrame.executeJavaScript(`(function () { ${serializeScript} ${proxyScript} return init() }())`);
+  
+	  // Load modules pre-fetched
+	  for (const mdl in moduleFilters) {
+		// noinspection JSUnfilteredForInLoop
+		this[mdl] = await getModule(moduleFilters[mdl]);
+	  }
+  
+	  this.i18n = getAllModules([ 'Messages', 'getLanguages' ]).find((m) => m.Messages.ACCOUNT);
+  
+	  // Expose window stuff
+	  this.proxiedWindow = await commandHandler('getWindowProps');
+	  this.proxiedWindow.DiscordSentry = deserialize(this.proxiedWindow.DiscordSentry);
+	  this.proxiedWindow.__SENTRY__ = deserialize(this.proxiedWindow.__SENTRY__);
+	  this.proxiedWindow._ = deserialize(this.proxiedWindow._);
+	}
+  };
+  
+  contextBridge.exposeInMainWorld('__$$WebpackProxyIPC', {
+	freePointer: (ptr) => freePointer(ptr),
+	registerCommandHandler: (h) => {
+	  if (commandHandler) {
+		throw new Error('no');
+	  }
+  
+	  commandHandler = h;
+	  setCommandHandler(h);
+	}
+  });
+  
+  console.inspect = function (obj) {
+	if ('__$$pointer' in obj) {
+	  commandHandler('inspect', obj.__$$pointer);
+	  return;
+	}
+  
+	console.log(obj);
+  };
+  
+  const remoteUrls = new Set();
+  const cou = URL.createObjectURL;
+  const rou = URL.revokeObjectURL;
+  URL.createObjectURL = function (blob) {
+	if ('__$$pointer' in blob) {
+	  const url = commandHandler('createUrlObject', blob.__$$pointer);
+	  remoteUrls.add(url);
+	  return url;
+	}
+  
+	return cou.call(URL, blob);
+  };
+  
+  URL.revokeObjectURL = function (url) {
+	if (remoteUrls.has(url)) {
+	  remoteUrls.delete(url);
+	  webFrame.executeJavaScript(`URL.revokeObjectURL(${JSON.stringify(url)})`);
+	  return;
+	}
+  
+	rou.call(URL, url);
+  };
+  
+  module.exports = webpack;
+  
\ No newline at end of file
diff --git a/src/patcher.js b/src/patcher.js
index 372e41f5..a8d59761 100644
--- a/src/patcher.js
+++ b/src/patcher.js
@@ -7,7 +7,7 @@ const { existsSync, unlinkSync } = require('fs');
 
 // Restore the classic path; The updater relies on it and it makes Discord go corrupt
 const electronPath = require.resolve('electron');
-const discordPath = join(dirname(require.main.filename), '..', 'app.asar');
+const discordPath = join('/', 'usr', 'lib', 'discord-canary', 'app.asar');
 require.main.filename = join(discordPath, 'app_bootstrap/index.js');
 
 const electron = require('electron');
