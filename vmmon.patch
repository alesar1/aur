diff --git a/vmmon/Makefile b/vmmon/Makefile
index de8162e..6124a71 100644
--- a/vmmon/Makefile
+++ b/vmmon/Makefile
@@ -43,7 +43,11 @@ INCLUDE      += -I$(SRCROOT)/shared
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 26 Mar 2018 13:33:32 +0200
Subject: [PATCH] vmmon: fix indirect call with retpoline build
diff --git a/vmmon/common/task.c b/vmmon/common/task.c
index 98cc74a..400ebfe 100644
--- a/vmmon/common/task.c
+++ b/vmmon/common/task.c
@@ -1597,12 +1597,23 @@ TaskSwitchToMonitor(VMCrossPage *crosspage)
    {
       uint64 raxGetsWiped, rcxGetsWiped;
 
+#ifdef CALL_NOSPEC
+      __asm__ __volatile__(CALL_NOSPEC
+                           : "=a" (raxGetsWiped),
+                             "=c" (rcxGetsWiped)
+                           : "0" (codePtr),
+                             "1" (crosspage),
+                             THUNK_TARGET(codePtr)
+                           : "rdx", "r8", "r9", "r10", "r11", "cc", "memory");
+#else
       __asm__ __volatile__("call *%%rax"
                            : "=a" (raxGetsWiped),
                              "=c" (rcxGetsWiped)
                            : "0" (codePtr),
                              "1" (crosspage)
                            : "rdx", "r8", "r9", "r10", "r11", "cc", "memory");
+#endif
+
    }
 #elif defined(_MSC_VER)
    /*
diff --git a/vmmon/linux/driver.c b/vmmon/linux/driver.c
index 87cf45b..5390a93 100644
--- a/vmmon/linux/driver.c
+++ b/vmmon/linux/driver.c
@@ -115,7 +115,7 @@
 #endif
 static int LinuxDriverMmap(struct file *filp, struct vm_area_struct *vma);
 
-static void LinuxDriverPollTimeout(unsigned long clientData);
+static void LinuxDriverPollTimeout(struct timer_list *clientData);
 static unsigned int LinuxDriverEstimateTSCkHz(void);
 
 static struct vm_operations_struct vmuser_mops = {
@@ -227,7 +228,7 @@ LinuxDriverEstimateTSCkHz(void)
  *----------------------------------------------------------------------
  */
 static void
-LinuxDriverEstimateTSCkHzDeferred(unsigned long data)
+LinuxDriverEstimateTSCkHzDeferred(struct timer_list *data)
 {
    LinuxDriverEstimateTSCkHz();
 }
@@ -265,9 +266,7 @@ LinuxDriverInitTSCkHz(void)
    }
 
    Vmx86_ReadTSCAndUptime(&tsckHzStartTime);
-   tscTimer.function = LinuxDriverEstimateTSCkHzDeferred;
    tscTimer.expires  = jiffies + 4 * HZ;
-   tscTimer.data     = 0;
    add_timer(&tscTimer);
 }
 
@@ -309,9 +308,13 @@ init_module(void)
     */
 
    init_waitqueue_head(&linuxState.pollQueue);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) && !defined(timer_setup)
    init_timer(&linuxState.pollTimer);
    linuxState.pollTimer.data = 0;
-   linuxState.pollTimer.function = LinuxDriverPollTimeout;
+   linuxState.pollTimer.function = (void *)LinuxDriverPollTimeout;
+#else
+   timer_setup(&linuxState.pollTimer, LinuxDriverPollTimeout, 0);
+#endif
 
    linuxState.fastClockThread = NULL;
    linuxState.fastClockFile = NULL;
@@ -360,7 +357,13 @@ init_module(void)
        linuxState.deviceName, linuxState.major, linuxState.minor);
 
    HostIF_InitUptime();
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) && !defined(timer_setup)
    init_timer(&tscTimer);
+   tscTimer.function = (void *)LinuxDriverEstimateTSCkHzDeferred;
+   tscTimer.data = (unsigned long)&tscTimer;
+#else
+   timer_setup(&tscTimer, LinuxDriverEstimateTSCkHzDeferred, 0);
+#endif
    LinuxDriverInitTSCkHz();
    Vmx86_InitIDList();
 
@@ -858,7 +858,7 @@
  */
 
 static void
-LinuxDriverPollTimeout(unsigned long clientData)  // IN:
+LinuxDriverPollTimeout(struct timer_list *clientData)  // IN:
 {
    LinuxDriverWakeUp(FALSE);
 }
diff --git a/vmmon/linux/hostif.c b/vmmon/linux/hostif.c
index fd32013..583d6da 100644
--- a/vmmon/linux/hostif.c
+++ b/vmmon/linux/hostif.c
@@ -1164,16 +1172,7 @@
 {
    int retval;
 
-   down_read(&current->mm->mmap_sem);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
-   retval = get_user_pages((unsigned long)uvAddr, numPages, 0, ppages, NULL);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-   retval = get_user_pages((unsigned long)uvAddr, numPages, 0, 0, ppages, NULL);
-#else
-   retval = get_user_pages(current, current->mm, (unsigned long)uvAddr,
-                           numPages, 0, 0, ppages, NULL);
-#endif
-   up_read(&current->mm->mmap_sem);
+   retval = get_user_pages_fast((unsigned long)uvAddr, numPages, 0, ppages);
 
    return retval != numPages;
 }
@@ -1594,17 +1593,34 @@ HostIF_EstimateLockedPageLimit(const VMDriver* vm,                // IN
    unsigned int reservedPages = MEMDEFAULTS_MIN_HOST_PAGES;
    unsigned int hugePages = (vm == NULL) ? 0 :
       BYTES_2_PAGES(vm->memInfo.hugePageBytes);
-   unsigned int lockedPages = global_page_state(NR_PAGETABLE) +
-                              global_page_state(NR_SLAB_UNRECLAIMABLE) +
-                              global_page_state(NR_UNEVICTABLE) +
-                              hugePages + reservedPages;
-   unsigned int anonPages =
+   unsigned int lockedPages = hugePages + reservedPages;
+   unsigned int anonPages;
+   unsigned int swapPages = BYTES_2_PAGES(linuxState.swapSize);
+
+   /* global_page_state is global_zone_page_state in 4.14. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 14, 0)
+   lockedPages += global_zone_page_state(NR_PAGETABLE);
+#else
+   lockedPages += global_page_state(NR_PAGETABLE);
+#endif
+   /* NR_SLAB_* moved from zone to node in 4.13. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+   lockedPages += global_node_page_state(NR_SLAB_UNRECLAIMABLE);
+#else
+   lockedPages += global_page_state(NR_SLAB_UNRECLAIMABLE);
+#endif
+   /* NR_UNEVICTABLE moved from global to node in 4.8. */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-      global_page_state(NR_ANON_MAPPED);
+   lockedPages += global_node_page_state(NR_UNEVICTABLE);
 #else
-      global_page_state(NR_ANON_PAGES);
+   lockedPages += global_page_state(NR_UNEVICTABLE);
+#endif
+   /* NR_ANON_MAPPED moved & changed name in 4.8. */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+   anonPages = global_node_page_state(NR_ANON_MAPPED);
+#else
+   anonPages = global_page_state(NR_ANON_PAGES);
 #endif
-   unsigned int swapPages = BYTES_2_PAGES(linuxState.swapSize);
 
    if (anonPages > swapPages) {
       lockedPages += anonPages - swapPages; 
@@ -1699,9 +1715,6 @@
    unsigned long jifs, jifBase;
    unsigned int attempts = 0;
 
-   /* Assert that HostIF_InitUptime has been called. */
-   ASSERT(uptimeState.timer.function);
-
  retry:
    do {
       version  = VersionedAtomic_BeginTryRead(&uptimeState.version);
@@ -1767,7 +1804,7 @@ HostIFReadUptimeWork(unsigned long *j)  // OUT: current jiffies
  */
 
 static void
-HostIFUptimeResyncMono(unsigned long data)  // IN: ignored
+HostIFUptimeResyncMono(struct timer_list *timer)  // IN: ignored
 {
    unsigned long jifs;
    uintptr_t flags;
@@ -1829,8 +1866,13 @@ HostIF_InitUptime(void)
                   -(tv.tv_usec * (UPTIME_FREQ / 1000000) + 
                     tv.tv_sec * UPTIME_FREQ));
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 15, 0) && !defined(timer_setup)
    init_timer(&uptimeState.timer);
-   uptimeState.timer.function = HostIFUptimeResyncMono;
+   uptimeState.timer.function = (void *)HostIFUptimeResyncMono;
+   uptimeState.timer.data = (unsigned long)&uptimeState.timer;
+#else
+   timer_setup(&uptimeState.timer, HostIFUptimeResyncMono, 0);
+#endif
    mod_timer(&uptimeState.timer, jiffies + HZ);
 }
 
From 8ba37a5023f939ba8d2e0d91b916ff442b1c18dd Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 31 Dec 2018 00:05:42 +0100
Subject: [PATCH] modules: replace SUBDIRS with M

Since commit 0126be38d988 ("kbuild: announce removal of SUBDIRS if used")
in v5.0-rc1, using SUBDIRS when building out of tree modules produces
a deprecation warning. As M used to work since pretty much ever, use it
unconditionally.
---
 vmmon-only/Makefile | 2 +-
 vmnet-only/Makefile | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/vmmon-only/Makefile b/vmmon-only/Makefile
index ccdd295..b4b71fb 100644
--- a/vmmon-only/Makefile
+++ b/vmmon-only/Makefile
@@ -121,7 +121,7 @@ prebuild:: ;
 postbuild:: ;
 
 $(DRIVER_KO): prebuild
-	$(MAKE) -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	$(MAKE) -C $(BUILD_DIR) M=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) modules
 	$(MAKE) -C $$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) postbuild
From ca44ce7215b91f82ff500843784b4e86a720fffe Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 31 Dec 2018 00:11:35 +0100
Subject: [PATCH] vmmon: totalram_pages is a function since 5.0

Since commit ca79b0c211af ("mm: convert totalram_pages and totalhigh_pages
variables to atomic") in v5.0-rc1, totalram_pages() is an accessor function
and the actual variable is an atomic.
---
 vmmon-only/linux/hostif.c | 18 ++++++++++--------
 1 file changed, 10 insertions(+), 8 deletions(-)

diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index af4b1d9..d32653c 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -207,6 +207,15 @@ static void UnlockEntry(void *clientData, MemTrackEntry *entryPtr);
 uint8 monitorIPIVector;
 uint8 hvIPIVector;
 
+static unsigned long compat_totalram_pages(void)
+{
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0)
+	return totalram_pages;
+#else
+	return totalram_pages();
+#endif
+}
+
 /*
  *-----------------------------------------------------------------------------
  *
@@ -1560,14 +1569,7 @@ unsigned int
 HostIF_EstimateLockedPageLimit(const VMDriver* vm,                // IN
 			       unsigned int currentlyLockedPages) // IN
 {
-   /*
-    * This variable is available and exported to modules,
-    * since at least 2.6.0.
-    */
-
-   extern unsigned long totalram_pages;
-
-   unsigned int totalPhysicalPages = totalram_pages;
+   unsigned int totalPhysicalPages = compat_totalram_pages();
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 28)
    return MemDefaults_CalcMaxLockedPages(totalPhysicalPages);
From c3fb5cda191137afddfdbd2f31bb4b15f9aeb3f2 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 31 Dec 2018 00:15:11 +0100
Subject: [PATCH] vmmon: bring back the do_gettimeofday() helper

The do_gettimeofday() helper was removed by commit e4b92b108c6c
("timekeeping: remove obsolete time accessors") in v5.0-rc1. Bring it back
for users in vmmon-only/linux/hostif.c.

This feels like a quick and clumsy band aid to allow build with post-4.20
kernels. On a closer look, the whole gymnastics around uptimeState and
HostIFReadUptimeWork() with jiffies and wall time checking and correcting
each other seems to be a workaround for an absence of high resolution
monotonic time. Considering ktime_get_ts64() is available since 3.17 and
before that, ktime_get_ts() since 2.6.17, perhaps the time has come to
clean all this machinery up. But something like this would be beyond the
scope of this repository.
---
 vmmon-only/include/compat_timekeeping32.h | 15 +++++++++++++++
 vmmon-only/linux/driver.c                 |  1 +
 vmmon-only/linux/hostif.c                 |  1 +
 vmnet-only/bridge.c                       | 11 +++++++++++
 4 files changed, 28 insertions(+)
 create mode 100644 vmmon-only/include/compat_timekeeping32.h

diff --git a/vmmon-only/include/compat_timekeeping32.h b/vmmon-only/include/compat_timekeeping32.h
new file mode 100644
index 0000000..5730dcd
--- /dev/null
+++ b/vmmon-only/include/compat_timekeeping32.h
@@ -0,0 +1,15 @@
+#ifndef __COMPAT_TIMEKEEPING32_H__
+#define __COMPAT_TIMEKEEPING32_H__
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 0, 0)
+static inline void do_gettimeofday(struct timeval *tv)
+{
+	struct timespec64 now;
+
+	ktime_get_real_ts64(&now);
+	tv->tv_sec = now.tv_sec;
+	tv->tv_usec = now.tv_nsec / 1000;
+}
+#endif
+
+#endif /* __COMPAT_TIMEKEEPING32_H__ */
diff --git a/vmmon-only/linux/driver.c b/vmmon-only/linux/driver.c
index ca4b538..cdc7fc1 100644
--- a/vmmon-only/linux/driver.c
+++ b/vmmon-only/linux/driver.c
@@ -34,6 +34,7 @@
 #include "compat_version.h"
 #include "compat_module.h"
 #include "compat_page.h"
+#include "compat_timekeeping32.h"
 
 #include "usercalldefs.h"
 
diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index c985aa0..75f4c8a 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -98,6 +98,7 @@
 #include "pgtbl.h"
 #include "vmmonInt.h"
 #include "versioned_atomic.h"
+#include "compat_timekeeping32.h"
 
 /*
  * Determine if we can use high resolution timers.
From 5db3c8a86f435e21f37a2acf386e2e52a1b42aa6 Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Sat, 5 Jan 2019 01:54:57 +0100
Subject: [PATCH] modules: handle access_ok() with two arguments

Since commit 96d4f267e40f ("Remove 'type' argument from access_ok()
function") in v5.0-rc1, the type argument of access_ok() was dropped.
The same commit also dropped macros VERIFY_READ and VERIFY_WRITE so check
for their existence on pre-5.0 kernels to allow build against kernels with
this change backported.
---
 vmmon-only/linux/hostif.c | 8 +++++++-
 vmnet-only/userif.c       | 8 +++++++-
 2 files changed, 14 insertions(+), 2 deletions(-)

diff --git a/vmmon-only/linux/hostif.c b/vmmon-only/linux/hostif.c
index 75f4c8a..987932b 100644
--- a/vmmon-only/linux/hostif.c
+++ b/vmmon-only/linux/hostif.c
@@ -217,6 +217,12 @@ static unsigned long compat_totalram_pages(void)
 #endif
 }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5, 0, 0) && defined(VERIFY_WRITE)
+	#define write_access_ok(addr, size) access_ok(VERIFY_WRITE, addr, size)
+#else
+	#define write_access_ok(addr, size) access_ok(addr, size)
+#endif
+
 /*
  *-----------------------------------------------------------------------------
  *
@@ -3585,7 +3591,7 @@ HostIF_MapUserMem(VA addr,                  // IN: User memory virtual address
 
    ASSERT(handle);
 
-   if (!access_ok(VERIFY_WRITE, p, size)) {
+   if (!write_access_ok(p, size)) {
       printk(KERN_ERR "%s: Couldn't verify write to uva 0x%p with size %"
              FMTSZ"u\n", __func__, p, size);
 
