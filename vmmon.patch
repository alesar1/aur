diff --git a/vmmon/Makefile b/vmmon/Makefile
index de8162e..6124a71 100644
--- a/vmmon/Makefile
+++ b/vmmon/Makefile
@@ -43,7 +43,11 @@ INCLUDE      += -I$(SRCROOT)/shared
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
diff --git a/vmmon/Makefile.kernel b/vmmon/Makefile.kernel
index bf805e0..9aac585 100644
--- a/vmmon/Makefile.kernel
+++ b/vmmon/Makefile.kernel
@@ -22,7 +22,7 @@ CC_OPTS += -DVMMON -DVMCORE
 INCLUDE := -I$(SRCROOT)/include -I$(SRCROOT)/common -I$(SRCROOT)/linux \
 	   -I$(SRCROOT)/vmcore
 
-EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE)
+EXTRA_CFLAGS := $(CC_OPTS) $(INCLUDE) $(LINUXINCLUDE)
 
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/smpcall.c, -DVMW_HAVE_SMP_CALL_3ARG, )
 EXTRA_CFLAGS += $(call vm_check_build, $(SRCROOT)/autoconf/tsc_khz.c, -DVMW_HAVE_TSC_KHZ, )
diff --git a/vmmon/include/compat_module.h b/vmmon/include/compat_module.h
index 2af7372..729aedc 100644
--- a/vmmon/include/compat_module.h
+++ b/vmmon/include/compat_module.h
@@ -80,4 +80,13 @@ static const char __module_cat(tag, __LINE__)[]                               \
    typedef int compat_mod_param_bool;
 #endif
 
+/*
+ * Linux kernel >= 4.3.0 does not return anything from misc_deregister
+ */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
+#define compat_misc_deregister(misc) misc_deregister(misc)
+#else
+#define compat_misc_deregister(misc) ({misc_deregister(misc);0;})
+#endif
+
 #endif /* __COMPAT_MODULE_H__ */
diff --git a/vmmon/linux/driver.c b/vmmon/linux/driver.c
index 87cf45b..5390a93 100644
--- a/vmmon/linux/driver.c
+++ b/vmmon/linux/driver.c
@@ -126,7 +126,16 @@ static struct vm_operations_struct vmuser_mops = {
 #endif
 };
 
-static struct file_operations vmuser_fops;
+static struct file_operations vmuser_fops = {
+   .owner = THIS_MODULE,
+   .poll = LinuxDriverPoll,
+   .unlocked_ioctl = LinuxDriver_Ioctl,
+   .compat_ioctl = LinuxDriver_Ioctl,
+   .open = LinuxDriver_Open,
+   .release = LinuxDriver_Close,
+   .mmap = LinuxDriverMmap
+};
+
 static struct timer_list tscTimer;
 static Atomic_uint32 tsckHz;
 static VmTimeStart tsckHzStartTime;
@@ -319,21 +328,6 @@ init_module(void)
    linuxState.fastClockPriority = -20;
    linuxState.swapSize = VMMON_UNKNOWN_SWAP_SIZE;
 
-   /*
-    * Initialize the file_operations structure. Because this code is always
-    * compiled as a module, this is fine to do it here and not in a static
-    * initializer.
-    */
-
-   memset(&vmuser_fops, 0, sizeof vmuser_fops);
-   vmuser_fops.owner = THIS_MODULE;
-   vmuser_fops.poll = LinuxDriverPoll;
-   vmuser_fops.unlocked_ioctl = LinuxDriver_Ioctl;
-   vmuser_fops.compat_ioctl = LinuxDriver_Ioctl;
-   vmuser_fops.open = LinuxDriver_Open;
-   vmuser_fops.release = LinuxDriver_Close;
-   vmuser_fops.mmap = LinuxDriverMmap;
-
 #ifdef VMX86_DEVEL
    devel_init_module();
    linuxState.minor = 0;
@@ -389,7 +383,9 @@ cleanup_module(void)
 #ifdef VMX86_DEVEL
    unregister_chrdev(linuxState.major, linuxState.deviceName);
 #else
-   misc_deregister(&linuxState.misc);
+   if (compat_misc_deregister(&linuxState.misc)) {
+      Warning("Module %s: error unregistering\n", linuxState.deviceName);
+   }
 #endif
 
    Log("Module %s: unloaded\n", linuxState.deviceName);
@@ -1287,7 +1283,7 @@ LinuxDriverReadTSC(void *data,   // OUT: TSC values
  *-----------------------------------------------------------------------------
  */
 
-__attribute__((always_inline)) static Bool
+inline __attribute__((always_inline)) static Bool
 LinuxDriverSyncReadTSCs(uint64 *delta) // OUT: TSC max - TSC min
 {
    TSCDelta tscDelta;
diff --git a/vmmon/linux/hostif.c b/vmmon/linux/hostif.c
index fd32013..583d6da 100644
--- a/vmmon/linux/hostif.c
+++ b/vmmon/linux/hostif.c
@@ -37,6 +37,9 @@
 
 #include <linux/vmalloc.h>
 #include <linux/slab.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/sched/signal.h>
+#endif
 
 #include <linux/preempt.h>
 #include <linux/poll.h>
@@ -73,6 +76,7 @@
 #include <linux/capability.h>
 #include <linux/kthread.h>
 #include <linux/wait.h>
+#include <asm/apic.h>
 #include <linux/signal.h>
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
 #include <linux/taskstats_kern.h> // For linux/sched/signal.h without version check
@@ -99,6 +99,37 @@
 #include "vmmonInt.h"
 #include "versioned_atomic.h"
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 14, 0)
+#   define global_zone_page_state global_page_state
+#endif
+
+static unsigned long get_nr_slab_unreclaimable(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 13, 0)
+   return global_node_page_state(NR_SLAB_UNRECLAIMABLE);
+#else
+   return global_page_state(NR_SLAB_UNRECLAIMABLE);
+#endif
+}
+
+static unsigned long get_nr_unevictable(void)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+   return global_node_page_state(NR_UNEVICTABLE);
+#else
+   return global_page_state(NR_UNEVICTABLE);
+#endif
+}
+
+static unsigned long get_nr_anon_mapped(void)
+{
+ #if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+   return global_node_page_state(NR_ANON_MAPPED);
+ #else
+   return global_page_state(NR_ANON_PAGES);
+ #endif
+}
+
 /*
  * Determine if we can use high resolution timers.
  */
@@ -142,6 +146,10 @@
  */
 #define LOCKED_PAGE_SLACK 10000
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
+#define NR_ANON_PAGES NR_ANON_MAPPED
+#endif
+
 static struct {
    Atomic_uint64     uptimeBase;
    VersionedAtomic   version;
@@ -1165,14 +1173,16 @@
    int retval;
 
    down_read(&current->mm->mmap_sem);
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 9, 0)
-   retval = get_user_pages((unsigned long)uvAddr, numPages, 0, ppages, NULL);
-#elif LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
-   retval = get_user_pages((unsigned long)uvAddr, numPages, 0, 0, ppages, NULL);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+   retval = get_user_pages((unsigned long)uvAddr,
 #else
    retval = get_user_pages(current, current->mm, (unsigned long)uvAddr,
-                           numPages, 0, 0, ppages, NULL);
 #endif
+                           numPages, 0,
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 9, 0)
+                           0,
+#endif
+                           ppages, NULL);
    up_read(&current->mm->mmap_sem);
 
    return retval != numPages;
@@ -1594,16 +1625,11 @@ HostIF_EstimateLockedPageLimit(const VMDriver* vm,                // IN
    unsigned int reservedPages = MEMDEFAULTS_MIN_HOST_PAGES;
    unsigned int hugePages = (vm == NULL) ? 0 :
       BYTES_2_PAGES(vm->memInfo.hugePageBytes);
-   unsigned int lockedPages = global_page_state(NR_PAGETABLE) +
-                              global_page_state(NR_SLAB_UNRECLAIMABLE) +
-                              global_page_state(NR_UNEVICTABLE) +
+   unsigned int lockedPages = global_zone_page_state(NR_PAGETABLE) +
+                              get_nr_slab_unreclaimable() +
+                              get_nr_unevictable() +
                               hugePages + reservedPages;
-   unsigned int anonPages =
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 8, 0)
-      global_page_state(NR_ANON_MAPPED);
-#else
-      global_page_state(NR_ANON_PAGES);
-#endif
+   unsigned int anonPages = get_nr_anon_mapped();
    unsigned int swapPages = BYTES_2_PAGES(linuxState.swapSize);
 
    if (anonPages > swapPages) {
diff --git a/vmmon/linux/vmmonInt.h b/vmmon/linux/vmmonInt.h
index 4dc04e9..993212d 100644
--- a/vmmon/linux/vmmonInt.h
+++ b/vmmon/linux/vmmonInt.h
@@ -28,7 +28,7 @@
  * Hide all kernel compatibility stuff in these macros and functions.
  */
 
-#ifdef VMW_HAVE_SMP_CALL_3ARG
+#if defined (VMW_HAVE_SMP_CALL_3ARG) || LINUX_VERSION_CODE >= KERNEL_VERSION(3, 0, 0)
 #define compat_smp_call_function(fn, info, wait) smp_call_function(fn, info, wait)
 #else
 #define compat_smp_call_function(fn, info, wait) smp_call_function(fn, info, 1, wait)
