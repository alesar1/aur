diff -Naupr ipt-netflow-2.2_orig/compat.h ipt-netflow-2.2/compat.h
--- ipt-netflow-2.2_orig/compat.h	2017-11-13 15:28:15.049771648 +0700
+++ ipt-netflow-2.2/compat.h	2017-11-13 15:28:48.643307274 +0700
@@ -611,6 +611,9 @@ out:
 
 /* Offset changes made in 613dbd95723aee7abd16860745691b6c7bda20dc */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28) && LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+# if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#  define xt_action_param xt_target_param
+# endif
 static inline u_int8_t xt_family(const struct xt_action_param *par)
 {
 	return par->family;
@@ -623,6 +626,20 @@ static inline const struct net_device *x
 {
 	return par->out;
 }
+static inline unsigned int xt_hooknum(const struct xt_action_param *par)
+{
+	return par->hooknum;
+}
+#endif
+
+#ifndef SK_CAN_REUSE
+# define SK_CAN_REUSE   1
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
+# define compat_refcount_read atomic_read
+#else
+# define compat_refcount_read refcount_read
 #endif
 
 #endif /* COMPAT_NETFLOW_H */
diff -Naupr ipt-netflow-2.2_orig/configure ipt-netflow-2.2/configure
--- ipt-netflow-2.2_orig/configure	2017-11-13 15:28:15.049771648 +0700
+++ ipt-netflow-2.2/configure	2017-11-13 15:28:48.643307274 +0700
@@ -154,9 +154,9 @@ iptables_find_version() {
 
 compiler_presence_test() {
   echo -n "Check for working gcc: "
-  gcc -v >/dev/null 2>&1
+  $CC -v >/dev/null 2>&1
   if [ $? = 0 ]; then
-    echo Yes
+    echo Yes "($CC)"
   else
     echo No
 
@@ -197,7 +197,7 @@ compile_libitp_test() {
   echo "
 #define __EXPORTED_HEADERS__
 #include <$*>" > test.c
-  gcc -c test.c $FLAGS >/dev/null 2>&1
+  $CC -c test.c $FLAGS >/dev/null 2>&1
   RET=$?
   if [ $RET = 0 ]; then
     echo Yes $MSG;
@@ -593,6 +593,7 @@ kernel_check_consistency
 kernel_check_config
 kernel_check_features
 
+CC=${CC:-gcc}
 test "$IPTBIN" || IPTBIN=`which iptables`
 
 iptables_find_version	#IPTVER
diff -Naupr ipt-netflow-2.2_orig/CREDITS ipt-netflow-2.2/CREDITS
--- ipt-netflow-2.2_orig/CREDITS	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow-2.2/CREDITS	2017-11-13 15:28:48.639973921 +0700
@@ -67,17 +67,20 @@ Patch authors and submitters:
    uropek [2013]
    shaman [2013]
    Jeremy Drake [2013]
+   Matthew Martin [2016] DKMS fixes
+   alex-eri [2016, 2017] OpenWRT compatibility
 
 
 Reference or prototype code authors:
 
-   Valentin V. Yankin [2011]
+   Valentin V. Yankin [2011] SNMP-index
 
 
 Project supporters:
 
    Summa Telecom [2014]
    Starlink [2014]
+   Anonymous
 
 
 Extensive testing and other help:
diff -Naupr ipt-netflow-2.2_orig/ipt_NETFLOW.c ipt-netflow-2.2/ipt_NETFLOW.c
--- ipt-netflow-2.2_orig/ipt_NETFLOW.c	2017-11-13 15:28:15.053105001 +0700
+++ ipt-netflow-2.2/ipt_NETFLOW.c	2017-11-13 15:28:48.643307274 +0700
@@ -469,6 +469,42 @@ static char *print_sockaddr(const struct
 	return snprintf_sockaddr(buf, sizeof(buf), ss);
 }
 
+static int is_zero_addr(const struct sockaddr_storage *ss)
+{
+	if (ss->ss_family == AF_INET)
+		return ((const struct sockaddr_in *)ss)->sin_addr.s_addr == 0;
+	else if (ss->ss_family == AF_INET6)
+		return  ((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[0] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[1] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[2] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[3] == 0;
+	else /* AF_UNSPEC */
+		return 1;
+}
+
+static char *print_usock_addr(struct ipt_netflow_sock *usock)
+{
+	static char buf[128];
+	size_t len;
+
+	snprintf(buf, sizeof(buf), "%s", print_sockaddr(&usock->addr));
+
+	if (!is_zero_addr(&usock->saddr)) {
+		len = strlen(buf);
+		snprintf(buf + len, sizeof(buf) - len, "@%s",
+		    print_sockaddr(&usock->saddr));
+		len = strlen(buf);
+		/* strip zero port */
+		if (len > 2 && buf[len - 1] == '0' && buf[len - 2] == ':')
+			buf[len - 2] = '\0';
+	}
+	if (usock->sdev[0]) {
+		len = strlen(buf);
+		snprintf(buf + len, sizeof(buf) - len, "%%%s", usock->sdev);
+	}
+	return buf;
+}
+
 #ifdef CONFIG_PROC_FS
 static inline int ABS(int x) { return x >= 0 ? x : -x; }
 #define SAFEDIV(x,y) ((y)? ({ u64 __tmp = x; do_div(__tmp, y); (int)__tmp; }) : 0)
@@ -575,7 +611,7 @@ static int snmp_seq_show(struct seq_file
 			sndbuf_peak = wmem_peak;
 		seq_printf(seq, "sock%d %s %d %u %u %u %u",
 		    snum,
-		    print_sockaddr(&usock->addr),
+		    print_usock_addr(usock),
 		    !!usock->sock,
 		    usock->err_connect,
 		    usock->err_full,
@@ -586,7 +622,7 @@ static int snmp_seq_show(struct seq_file
 
 			seq_printf(seq, " %u %u %u\n",
 			    sk->sk_sndbuf,
-			    atomic_read(&sk->sk_wmem_alloc),
+			    compat_refcount_read(&sk->sk_wmem_alloc),
 			    wmem_peak);
 		} else
 			seq_printf(seq, " 0 0 %u\n", wmem_peak);
@@ -821,14 +857,14 @@ static int nf_seq_show(struct seq_file *
 	list_for_each_entry(usock, &usock_list, list) {
 		seq_printf(seq, "sock%d: %s",
 		    snum,
-		    print_sockaddr(&usock->addr));
+		    print_usock_addr(usock));
 		if (usock->sock) {
 			struct sock *sk = usock->sock->sk;
 
 			seq_printf(seq, ", sndbuf %u, filled %u, peak %u;"
 			    " err: sndbuf reached %u, connect %u, cberr %u, other %u\n",
 			    sk->sk_sndbuf,
-			    atomic_read(&sk->sk_wmem_alloc),
+			    compat_refcount_read(&sk->sk_wmem_alloc),
 			    atomic_read(&usock->wmem_peak),
 			    usock->err_full,
 			    usock->err_connect,
@@ -1888,24 +1924,50 @@ static void sk_error_report(struct sock
 	return;
 }
 
-static struct socket *usock_open_sock(const struct sockaddr_storage *addr, void *user_data)
+static struct socket *usock_open_sock(struct ipt_netflow_sock *usock)
 {
 	struct socket *sock;
 	int error;
+	int salen = 0;
 
-	if ((error = sock_create_kern(addr->ss_family, SOCK_DGRAM, IPPROTO_UDP, &sock)) < 0) {
+	if ((error = sock_create_kern(usock->addr.ss_family, SOCK_DGRAM, IPPROTO_UDP, &sock)) < 0) {
 		printk(KERN_ERR "ipt_NETFLOW: sock_create_kern error %d\n", -error);
 		return NULL;
 	}
 	sock->sk->sk_allocation = GFP_ATOMIC;
 	sock->sk->sk_prot->unhash(sock->sk); /* hidden from input */
 	sock->sk->sk_error_report = &sk_error_report; /* clear ECONNREFUSED */
-	sock->sk->sk_user_data = user_data; /* usock */
+	sock->sk->sk_user_data = usock;
+	sock->sk->sk_reuse = SK_CAN_REUSE;
+
+	if (usock->sdev[0]) {
+		struct net_device *dev = dev_get_by_name(&init_net, usock->sdev);
+
+		if (dev) {
+			sock->sk->sk_bound_dev_if = dev->ifindex;
+			dev_put(dev);
+		} else {
+			printk(KERN_ERR "ipt_NETFLOW: error binding to device %s, errno %d\n",
+			    usock->sdev, -error);
+			return NULL;
+		}
+	}
+	if (!is_zero_addr(&usock->saddr)) {
+		if (usock->saddr.ss_family == AF_INET)
+			salen = sizeof(struct sockaddr_in);
+		else if (usock->saddr.ss_family == AF_INET6)
+			salen = sizeof(struct sockaddr_in6);
+		if ((error = sock->ops->bind(sock, (struct sockaddr *)&usock->saddr, salen)) < 0) {
+			printk(KERN_ERR "ipt_NETFLOW: error binding socket %d\n", -error);
+			return NULL;
+		}
+	}
+
 	if (sndbuf)
 		sock->sk->sk_sndbuf = sndbuf;
 	else
 		sndbuf = sock->sk->sk_sndbuf;
-	error = sock->ops->connect(sock, (struct sockaddr *)addr, sizeof(*addr), 0);
+	error = sock->ops->connect(sock, (struct sockaddr *)&usock->addr, sizeof(usock->addr), 0);
 	if (error < 0) {
 		printk(KERN_ERR "ipt_NETFLOW: error connecting UDP socket %d,"
 		    " don't worry, will try reconnect later.\n", -error);
@@ -1918,7 +1980,7 @@ static struct socket *usock_open_sock(co
 
 static void usock_connect(struct ipt_netflow_sock *usock, const int sendmsg)
 {
-	usock->sock = usock_open_sock(&usock->addr, usock);
+	usock->sock = usock_open_sock(usock);
 	if (usock->sock) {
 		if (sendmsg || debug)
 			printk(KERN_INFO "ipt_NETFLOW: connected %s\n",
@@ -1969,7 +2031,7 @@ static void netflow_sendmsg(void *buffer
 			printk(KERN_INFO "netflow_sendmsg: sendmsg(%d, %d) [%u %u]\n",
 			       snum,
 			       len,
-			       atomic_read(&usock->sock->sk->sk_wmem_alloc),
+			       compat_refcount_read(&usock->sock->sk->sk_wmem_alloc),
 			       usock->sock->sk->sk_sndbuf);
 		ret = kernel_sendmsg(usock->sock, &msg, &iov, 1, (size_t)len);
 		if (ret < 0) {
@@ -1992,7 +2054,7 @@ static void netflow_sendmsg(void *buffer
 			printk(KERN_ERR "ipt_NETFLOW: sendmsg[%d] error %d: data loss %llu pkt, %llu bytes%s\n",
 			       snum, ret, pdu_packets, pdu_traf, suggestion);
 		} else {
-			unsigned int wmem = atomic_read(&usock->sock->sk->sk_wmem_alloc);
+			unsigned int wmem = compat_refcount_read(&usock->sock->sk->sk_wmem_alloc);
 			if (wmem > atomic_read(&usock->wmem_peak))
 				atomic_set(&usock->wmem_peak, wmem);
 			NETFLOW_STAT_INC(exported_pkt);
@@ -2052,7 +2114,7 @@ static void add_usock(struct ipt_netflow
 	}
 	list_add_tail(&usock->list, &usock_list);
 	printk(KERN_INFO "ipt_NETFLOW: added destination %s%s\n",
-	       print_sockaddr(&usock->addr),
+	       print_usock_addr(usock),
 	       (!usock->sock)? " (unconnected)" : "");
 	mutex_unlock(&sock_lock);
 }
@@ -2248,9 +2310,11 @@ static int add_destinations(const char *
 
 	for (; ptr; ptr += len) {
 		struct sockaddr_storage ss;
+		struct sockaddr_storage sbind = {};
 		struct ipt_netflow_sock *usock;
 		const char *end;
 		int succ = 0;
+		char name[IFNAMSIZ] = { 0 };
 
 		/* skip initial separators */
 		ptr += strspn(ptr, SEPARATORS);
@@ -2262,6 +2326,7 @@ static int add_destinations(const char *
 
 		if (strncount(ptr, len, ':') >= 2) {
 			struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;
+			struct sockaddr_in6 *sout = (struct sockaddr_in6 *)&sbind;
 			const char *c = ptr;
 			int clen = len;
 
@@ -2276,15 +2341,32 @@ static int add_destinations(const char *
 				++end;
 			if (succ &&
 			    (*end == ':' || *end == '.' || *end == 'p' || *end == '#'))
-				sin6->sin6_port = htons(simple_strtoul(++end, NULL, 0));
+				sin6->sin6_port = htons(simple_strtoul(++end, (char **)&end, 0));
+			if (succ && *end == '@') {
+				++end;
+				sout->sin6_family = AF_INET6;
+				sout->sin6_port   = 0;
+				succ = in6_pton(end, strcspn(end, SEPARATORS), (u8 *)&sout->sin6_addr, -1, &end);
+			}
 		} else {
-			struct sockaddr_in *sin = (struct sockaddr_in *)&ss;
+			struct sockaddr_in *sin  = (struct sockaddr_in *)&ss;
+			struct sockaddr_in *sout = (struct sockaddr_in *)&sbind;
 
 			sin->sin_family = AF_INET;
 			sin->sin_port = htons(2055);
 			succ = in4_pton(ptr, len, (u8 *)&sin->sin_addr, -1, &end);
 			if (succ && *end == ':')
-				sin->sin_port = htons(simple_strtoul(++end, NULL, 0));
+				sin->sin_port = htons(simple_strtoul(++end, (char **)&end, 0));
+			if (succ && *end == '@') {
+				++end;
+				sout->sin_family = AF_INET;
+				sout->sin_port   = 0;
+				succ = in4_pton(end, strcspn(end, SEPARATORS), (u8 *)&sout->sin_addr, -1, &end);
+			}
+		}
+		if (succ && *end == '%') {
+			++end;
+			snprintf(name, sizeof(name), "%.*s", (int)strcspn(end, SEPARATORS), end);
 		}
 		if (!succ) {
 			printk(KERN_ERR "ipt_NETFLOW: can't parse destination: %.*s\n",
@@ -2297,7 +2379,9 @@ static int add_destinations(const char *
 			return -ENOMEM;
 		}
 		memset(usock, 0, sizeof(*usock));
-		usock->addr = ss;
+		usock->addr  = ss;
+		usock->saddr = sbind;
+		memcpy(usock->sdev, name, sizeof(usock->sdev));
 		usock_connect(usock, 0);
 		add_usock(usock);
 	}
@@ -2624,7 +2708,7 @@ static void netflow_export_pdu_v9(void)
 	do_gettimeofday(&tv);
 	pdu.v9.export_time_s	= htonl(tv.tv_sec);
 	pdu.v9.seq		= htonl(pdu_seq);
-	pdu.v9.source_id	= engine_id;
+	pdu.v9.source_id	= htonl(engine_id);
 
 	pdusize = pdu_data_used - (unsigned char *)&pdu.v9;
 
@@ -2656,7 +2740,7 @@ static void netflow_export_pdu_ipfix(voi
 	do_gettimeofday(&tv);
 	pdu.ipfix.export_time_s	= htonl(tv.tv_sec);
 	pdu.ipfix.seq		= htonl(pdu_seq);
-	pdu.ipfix.odomain_id	= engine_id;
+	pdu.ipfix.odomain_id	= htonl(engine_id);
 	pdusize = pdu_data_used - (unsigned char *)&pdu;
 	pdu.ipfix.length	= htons(pdusize);
 
@@ -4806,9 +4890,9 @@ static unsigned int netflow_target(
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
 	const int family = target->family;
 #else
-#ifdef ENABLE_DIRECTION
-	const int hooknum = par->hooknum;
-#endif
+# ifdef ENABLE_DIRECTION
+	const int hooknum = xt_hooknum(par);
+# endif
 	const int family = xt_family(par);
 #endif
 	struct ipt_netflow_tuple tuple;
diff -Naupr ipt-netflow-2.2_orig/ipt_NETFLOW.h ipt-netflow-2.2/ipt_NETFLOW.h
--- ipt-netflow-2.2_orig/ipt_NETFLOW.h	2017-11-13 15:28:15.053105001 +0700
+++ ipt-netflow-2.2/ipt_NETFLOW.h	2017-11-13 15:28:48.643307274 +0700
@@ -378,6 +378,8 @@ struct ipt_netflow_sock {
 	struct list_head list;
 	struct socket *sock;
 	struct sockaddr_storage addr;	// destination
+	struct sockaddr_storage saddr;	// source
+	char   sdev[IFNAMSIZ];		// source device
 	atomic_t wmem_peak;		// sk_wmem_alloc peak value
 	unsigned int err_connect;	// connect errors
 	unsigned int err_full;		// socket filled error
diff -Naupr ipt-netflow-2.2_orig/README ipt-netflow-2.2/README
--- ipt-netflow-2.2_orig/README	2017-11-13 15:28:12.093087176 +0700
+++ ipt-netflow-2.2/README	2017-11-13 15:28:48.639973921 +0700
@@ -224,11 +224,6 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
      --enable-aggregation
          enables aggregation rules. Read below for explanation of aggregation.
 
-     --enable-debugfs
-         enabled debugfs interface to active flows list. NB! This is for debug
-         purposes only. cat /sys/kernel/debug/netflow_dump to see all currently
-         accouned flows.
-
      --disable-dkms
          disable creating dkms.conf and auto-install module into DKMS tree.
 
@@ -276,6 +271,7 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
 2. Statistics is in /proc/net/stat/ipt_netflow
    Machine readable statistics is in /proc/net/stat/ipt_netflow_snmp
    To view boring slab statistics: grep ipt_netflow /proc/slabinfo
+   Dump of all flows is in /proc/net/stat/ipt_netflow_flows
 
 3. You can view parameters and control them via sysctl, example:
 
@@ -422,6 +418,12 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
      - mirror flows to two (can be more) addresses, separate addresses
        with comma.
 
+   destination=127.0.0.1:2055@127.0.0.2
+     - bind socket to address (127.0.0.2).
+
+   destination=127.0.0.1:2055%eth0
+     - bind socket to interface (eth0). May be useful for multi-homed boxes.
+
    sampler=deterministic:123
    sampler=random:123
    sampler=hash:123
