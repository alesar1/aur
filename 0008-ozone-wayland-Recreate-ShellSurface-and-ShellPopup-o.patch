From 8f007d6dd7e450f4661e49a7053ed64e4cafbc1a Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Thu, 12 Dec 2019 13:22:46 +0000
Subject: [PATCH 8/9] ozone/wayland: Recreate ShellSurface and ShellPopup on
 Show calls.

In Wayland, there is no explicit method for showing surfaces. Instead,
one must create/destroy resources to trigger mapping of the
base wl_surface and show xdg surfaces and xdg popups on a screen.

Actually, we have already been doing so for WaylandPopups and
WaylandSubsurfaces, but WaylandSurface just ignored that.

This CL brings the following changes:
1) WaylandSurface: create ShellSurface on Show and destroy on Hide.
If Show fails, tell the delegate to Close the window. Also, restore
min and max size, title and app id on each Show call.
2) WaylandPopup: do no create ShellPopup on Initialize, but rather
wait until Show call comes.
3) Tests: Instead of unretained implementation, use the template
that creates resources and manages their lifetime automatically
so that MockXdgPopup and MockXdgSurface could be destroyed
automatically once the client destroyes the allocated resources.
4) WaylandSubsurface: do not try to Show if the subsurface has already
shown or do not try to Hide if the subsurface has already been
hidden.
5) Also added 3 tests to exercise above changes.

SetsPropertiesOnShow

Test: DestroysCreatesSurfaceOnHideShow, DestroysCreatesPopupsOnHideShow
Bug: 578890
Change-Id: Ifb873eb1b089775e945705b1254ac048eddbb4e8
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1961201
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Reviewed-by: Michael Spang <spang@chromium.org>
Cr-Commit-Position: refs/heads/master@{#724184}
---
 .../platform/wayland/host/wayland_popup.cc    |  41 +++--
 .../platform/wayland/host/wayland_popup.h     |   2 +-
 .../wayland/host/wayland_subsurface.cc        |   6 +
 .../platform/wayland/host/wayland_surface.cc  |  78 +++++---
 .../platform/wayland/host/wayland_surface.h   |  18 +-
 .../host/wayland_window_manager_unittests.cc  |  13 +-
 .../wayland/host/wayland_window_unittest.cc   | 170 +++++++++++++++---
 ui/ozone/platform/wayland/test/mock_surface.h |  18 +-
 .../platform/wayland/test/mock_xdg_popup.cc   |  10 +-
 .../platform/wayland/test/mock_xdg_popup.h    |   6 +-
 .../platform/wayland/test/mock_xdg_shell.cc   |   9 +-
 .../platform/wayland/test/mock_xdg_surface.cc | 116 +++++++-----
 .../platform/wayland/test/mock_xdg_surface.h  |  69 ++++---
 .../platform/wayland/test/wayland_test.cc     |   2 +
 14 files changed, 402 insertions(+), 156 deletions(-)

diff --git a/ui/ozone/platform/wayland/host/wayland_popup.cc b/ui/ozone/platform/wayland/host/wayland_popup.cc
index 45aac6e51bfc..98cadd54555c 100644
--- a/ui/ozone/platform/wayland/host/wayland_popup.cc
+++ b/ui/ozone/platform/wayland/host/wayland_popup.cc
@@ -18,9 +18,9 @@ WaylandPopup::WaylandPopup(PlatformWindowDelegate* delegate,
 
 WaylandPopup::~WaylandPopup() = default;
 
-void WaylandPopup::CreateShellPopup() {
+bool WaylandPopup::CreateShellPopup() {
   if (GetBounds().IsEmpty())
-    return;
+    return false;
 
   // TODO(jkim): Consider how to support DropArrow window on tabstrip.
   // When it starts dragging, as described the protocol, https://goo.gl/1Mskq3,
@@ -30,8 +30,8 @@ void WaylandPopup::CreateShellPopup() {
   // a crash when aura::Window is destroyed.
   // https://crbug.com/875164
   if (connection()->IsDragInProgress()) {
-    LOG(ERROR) << "Wayland can't create a popup window during dragging.";
-    return;
+    LOG(WARNING) << "Wayland can't create a popup window during dragging.";
+    return false;
   }
 
   DCHECK(parent_window() && !shell_popup_);
@@ -40,30 +40,40 @@ void WaylandPopup::CreateShellPopup() {
 
   ShellObjectFactory factory;
   shell_popup_ = factory.CreateShellPopupWrapper(connection(), this, bounds_px);
-  if (!shell_popup_)
-    CHECK(false) << "Failed to create Wayland shell popup";
+  if (!shell_popup_) {
+    LOG(ERROR) << "Failed to create Wayland shell popup";
+    return false;
+  }
 
   parent_window()->set_child_window(this);
+  return true;
 }
 
 void WaylandPopup::Show(bool inactive) {
+  if (shell_popup_)
+    return;
+
   set_keyboard_focus(true);
 
-  if (!shell_popup_) {
-    // When showing a sub-menu after it has been previously shown and hidden,
-    // Wayland sends SetBounds prior to Show, and |bounds_px| takes the pixel
-    // bounds.  This makes a difference against the normal flow when the
-    // window is created (see |Initialize|).  To equalize things, rescale
-    // |bounds_px_| to DIP.  It will be adjusted while creating the popup.
-    SetBounds(gfx::ScaleToRoundedRect(GetBounds(), 1.0 / ui_scale()));
-    CreateShellPopup();
-    connection()->ScheduleFlush();
+  // When showing a sub-menu after it has been previously shown and hidden,
+  // Wayland sends SetBounds prior to Show, and |bounds_px| takes the pixel
+  // bounds.  This makes a difference against the normal flow when the
+  // window is created (see |Initialize|).  To equalize things, rescale
+  // |bounds_px_| to DIP.  It will be adjusted while creating the popup.
+  SetBounds(gfx::ScaleToRoundedRect(GetBounds(), 1.0 / ui_scale()));
+  if (!CreateShellPopup()) {
+    Close();
+    return;
   }
 
   UpdateBufferScale(false);
+  connection()->ScheduleFlush();
 }
 
 void WaylandPopup::Hide() {
+  if (!shell_popup_)
+    return;
+
   if (child_window())
     child_window()->Hide();
 
@@ -155,7 +165,6 @@ bool WaylandPopup::OnInitialize(PlatformWindowInitProperties properties) {
   // If parent window is known in advanced, we may set the scale early.
   SetBufferScale(parent_window()->buffer_scale(), false);
   set_ui_scale(parent_window()->ui_scale());
-  CreateShellPopup();
   return true;
 }
 
diff --git a/ui/ozone/platform/wayland/host/wayland_popup.h b/ui/ozone/platform/wayland/host/wayland_popup.h
index 2d45986ba36a..7bc48bb29a06 100644
--- a/ui/ozone/platform/wayland/host/wayland_popup.h
+++ b/ui/ozone/platform/wayland/host/wayland_popup.h
@@ -32,7 +32,7 @@ class WaylandPopup : public WaylandWindow {
   bool OnInitialize(PlatformWindowInitProperties properties) override;
 
   // Creates a popup window, which is visible as a menu window.
-  void CreateShellPopup();
+  bool CreateShellPopup();
 
   // Returns bounds with origin relative to parent window's origin.
   gfx::Rect AdjustPopupWindowPosition();
diff --git a/ui/ozone/platform/wayland/host/wayland_subsurface.cc b/ui/ozone/platform/wayland/host/wayland_subsurface.cc
index d261b910fc97..94ca613ecaf1 100644
--- a/ui/ozone/platform/wayland/host/wayland_subsurface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_subsurface.cc
@@ -18,11 +18,17 @@ WaylandSubsurface::WaylandSubsurface(PlatformWindowDelegate* delegate,
 WaylandSubsurface::~WaylandSubsurface() = default;
 
 void WaylandSubsurface::Show(bool inactive) {
+  if (subsurface_)
+    return;
+
   CreateSubsurface();
   UpdateBufferScale(false);
 }
 
 void WaylandSubsurface::Hide() {
+  if (!subsurface_)
+    return;
+
   subsurface_.reset();
 
   // Detach buffer from surface in order to completely shutdown menus and
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.cc b/ui/ozone/platform/wayland/host/wayland_surface.cc
index cfd4349db885..b800a526e64e 100644
--- a/ui/ozone/platform/wayland/host/wayland_surface.cc
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -10,6 +10,7 @@
 #include "ui/gfx/native_widget_types.h"
 #include "ui/ozone/platform/wayland/host/shell_object_factory.h"
 #include "ui/ozone/platform/wayland/host/shell_surface_wrapper.h"
+#include "ui/ozone/platform/wayland/host/wayland_buffer_manager_host.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 #include "ui/platform_window/platform_window_handler/wm_drop_handler.h"
 
@@ -35,11 +36,18 @@ WaylandSurface::~WaylandSurface() {
   }
 }
 
-void WaylandSurface::CreateShellSurface() {
+bool WaylandSurface::CreateShellSurface() {
   ShellObjectFactory factory;
   shell_surface_ = factory.CreateShellSurfaceWrapper(connection(), this);
-  if (!shell_surface_)
-    CHECK(false) << "Failed to initialize Wayland shell surface";
+  if (!shell_surface_) {
+    LOG(ERROR) << "Failed to create a ShellSurface.";
+    return false;
+  }
+
+  shell_surface_->SetAppId(app_id_);
+  shell_surface_->SetTitle(window_title_);
+  SetSizeConstraints();
+  return true;
 }
 
 void WaylandSurface::ApplyPendingBounds() {
@@ -77,12 +85,33 @@ void WaylandSurface::StartDrag(const ui::OSExchangeData& data,
 }
 
 void WaylandSurface::Show(bool inactive) {
+  if (shell_surface_)
+    return;
+
+  if (!CreateShellSurface()) {
+    Close();
+    return;
+  }
+
   set_keyboard_focus(true);
-  // TODO(msisov): recreate |shell_surface_| on show calls.
+  UpdateBufferScale(false);
 }
 
 void WaylandSurface::Hide() {
-  // TODO(msisov): destroy |shell_surface_| on hide calls.
+  if (!shell_surface_)
+    return;
+
+  if (child_window()) {
+    child_window()->Hide();
+    set_child_window(nullptr);
+  }
+
+  shell_surface_.reset();
+  connection()->ScheduleFlush();
+
+  // Detach buffer from surface in order to completely shutdown menus and
+  // tooltips, and release resources.
+  connection()->buffer_manager_host()->ResetSurfaceContents(GetWidget());
 }
 
 bool WaylandSurface::IsVisible() const {
@@ -92,9 +121,15 @@ bool WaylandSurface::IsVisible() const {
 }
 
 void WaylandSurface::SetTitle(const base::string16& title) {
-  DCHECK(shell_surface_);
-  shell_surface_->SetTitle(title);
-  connection()->ScheduleFlush();
+  if (window_title_ == title)
+    return;
+
+  window_title_ = title;
+
+  if (shell_surface_) {
+    shell_surface_->SetTitle(title);
+    connection()->ScheduleFlush();
+  }
 }
 
 void WaylandSurface::ToggleFullscreen() {
@@ -178,15 +213,9 @@ void WaylandSurface::SizeConstraintsChanged() {
     return;
 
   DCHECK(delegate());
-  auto min_size = delegate()->GetMinimumSizeForWindow();
-  auto max_size = delegate()->GetMaximumSizeForWindow();
-
-  if (min_size.has_value())
-    shell_surface_->SetMinSize(min_size->width(), min_size->height());
-  if (max_size.has_value())
-    shell_surface_->SetMaxSize(max_size->width(), max_size->height());
-
-  connection()->ScheduleFlush();
+  min_size_ = delegate()->GetMinimumSizeForWindow();
+  max_size_ = delegate()->GetMaximumSizeForWindow();
+  SetSizeConstraints();
 }
 
 void WaylandSurface::HandleSurfaceConfigure(int32_t width,
@@ -315,10 +344,8 @@ void WaylandSurface::OnDragSessionClose(uint32_t dnd_action) {
 }
 
 bool WaylandSurface::OnInitialize(PlatformWindowInitProperties properties) {
-  CreateShellSurface();
-  if (shell_surface_ && !properties.wm_class_class.empty())
-    shell_surface_->SetAppId(properties.wm_class_class);
-  return !!shell_surface_;
+  app_id_ = properties.wm_class_class;
+  return true;
 }
 
 bool WaylandSurface::IsMinimized() const {
@@ -345,4 +372,13 @@ WmMoveResizeHandler* WaylandSurface::AsWmMoveResizeHandler() {
   return static_cast<WmMoveResizeHandler*>(this);
 }
 
+void WaylandSurface::SetSizeConstraints() {
+  if (min_size_.has_value())
+    shell_surface_->SetMinSize(min_size_->width(), min_size_->height());
+  if (max_size_.has_value())
+    shell_surface_->SetMaxSize(max_size_->width(), max_size_->height());
+
+  connection()->ScheduleFlush();
+}
+
 }  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.h b/ui/ozone/platform/wayland/host/wayland_surface.h
index 0f7204db3c48..677eaca6ef56 100644
--- a/ui/ozone/platform/wayland/host/wayland_surface.h
+++ b/ui/ozone/platform/wayland/host/wayland_surface.h
@@ -76,10 +76,13 @@ class WaylandSurface : public WaylandWindow,
   void MaybeTriggerPendingStateChange();
 
   // Creates a surface window, which is visible as a main window.
-  void CreateShellSurface();
+  bool CreateShellSurface();
 
   WmMoveResizeHandler* AsWmMoveResizeHandler();
 
+  // Propagates the |min_size_| and |max_size_| to the ShellSurface.
+  void SetSizeConstraints();
+
   // Wrappers around shell surface.
   std::unique_ptr<ShellSurfaceWrapper> shell_surface_;
 
@@ -106,6 +109,19 @@ class WaylandSurface : public WaylandWindow,
   bool is_active_ = false;
   bool is_minimizing_ = false;
 
+  // Id of the chromium app passed through
+  // PlatformWindowInitProperties::wm_class_class. This is used by Wayland
+  // compositor to identify the app, unite it's windows into the same stack of
+  // windows and find *.desktop file to set various preferences including icons.
+  std::string app_id_;
+
+  // Title of the ShellSurface.
+  base::string16 window_title_;
+
+  // Max and min sizes of the WaylandSurface window.
+  base::Optional<gfx::Size> min_size_;
+  base::Optional<gfx::Size> max_size_;
+
   DISALLOW_COPY_AND_ASSIGN(WaylandSurface);
 };
 
diff --git a/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc b/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
index 64a387723560..a4b1fc7d9436 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
@@ -36,8 +36,11 @@ class WaylandWindowManagerTest : public WaylandTest {
     PlatformWindowInitProperties properties;
     properties.bounds = bounds;
     properties.type = type;
-    return WaylandWindow::Create(delegate, connection_.get(),
-                                 std::move(properties));
+    auto window = WaylandWindow::Create(delegate, connection_.get(),
+                                        std::move(properties));
+    if (window)
+      window->Show(false);
+    return window;
   }
 
   WaylandWindowManager* manager_ = nullptr;
@@ -87,6 +90,9 @@ TEST_P(WaylandWindowManagerTest, GetCurrentFocusedWindow) {
 
   auto window1 = CreateWaylandWindowWithParams(PlatformWindowType::kWindow,
                                                kDefaultBounds, &delegate);
+  // When window is shown, it automatically gets keyboard focus. Reset it.
+  window_->set_keyboard_focus(false);
+  window1->set_keyboard_focus(false);
 
   Sync();
 
@@ -121,6 +127,9 @@ TEST_P(WaylandWindowManagerTest, GetCurrentKeyboardFocusedWindow) {
 
   auto window1 = CreateWaylandWindowWithParams(PlatformWindowType::kWindow,
                                                kDefaultBounds, &delegate);
+  // When window is shown, it automatically gets keyboard focus. Reset it.
+  window_->set_keyboard_focus(false);
+  window1->set_keyboard_focus(false);
 
   Sync();
 
diff --git a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
index 132f740b0eb1..f56b96690eea 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
@@ -128,11 +128,7 @@ class WaylandWindowTest : public WaylandTest {
     }
   }
 
-  // Depending on a shell version, xdg_surface_ or xdg_toplevel surface should
-  // get the mock calls. This method decided, which surface to use.
-  wl::MockXdgSurface* GetXdgSurface() {
-    return xdg_surface_->xdg_toplevel();
-  }
+  wl::MockXdgTopLevel* GetXdgToplevel() { return xdg_surface_->xdg_toplevel(); }
 
   void AddStateToWlArray(uint32_t state, wl_array* states) {
     *static_cast<uint32_t*>(wl_array_add(states, sizeof state)) = state;
@@ -162,8 +158,11 @@ class WaylandWindowTest : public WaylandTest {
     properties.type = type;
     properties.parent_widget = parent_widget;
 
-    return WaylandWindow::Create(delegate, connection_.get(),
-                                 std::move(properties));
+    auto window = WaylandWindow::Create(delegate, connection_.get(),
+                                        std::move(properties));
+    if (window)
+      window->Show(false);
+    return window;
   }
 
   void InitializeWithSupportedHitTestValues(std::vector<int>* hit_tests) {
@@ -213,7 +212,7 @@ class WaylandWindowTest : public WaylandTest {
 };
 
 TEST_P(WaylandWindowTest, SetTitle) {
-  EXPECT_CALL(*GetXdgSurface(), SetTitle(StrEq("hello")));
+  EXPECT_CALL(*GetXdgToplevel(), SetTitle(StrEq("hello")));
   window_->SetTitle(base::ASCIIToUTF16("hello"));
 }
 
@@ -229,7 +228,7 @@ TEST_P(WaylandWindowTest, MaximizeAndRestore) {
 
   auto active_maximized = MakeStateArray(
       {XDG_TOPLEVEL_STATE_ACTIVATED, XDG_TOPLEVEL_STATE_MAXIMIZED});
-  EXPECT_CALL(*GetXdgSurface(), SetMaximized());
+  EXPECT_CALL(*GetXdgToplevel(), SetMaximized());
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kMaximizedBounds.width(),
                                                kMaximizedBounds.height()));
   EXPECT_CALL(delegate_, OnActivationChanged(Eq(true)));
@@ -267,7 +266,7 @@ TEST_P(WaylandWindowTest, MaximizeAndRestore) {
               OnWindowStateChanged(Eq(PlatformWindowState::kNormal)));
   EXPECT_CALL(delegate_, OnActivationChanged(_)).Times(0);
   EXPECT_CALL(delegate_, OnBoundsChanged(kNormalBounds));
-  EXPECT_CALL(*GetXdgSurface(), UnsetMaximized());
+  EXPECT_CALL(*GetXdgToplevel(), UnsetMaximized());
   window_->Restore();
   // Reinitialize wl_array, which removes previous old states.
   auto active = InitializeWlArrayWithActivatedState();
@@ -283,7 +282,7 @@ TEST_P(WaylandWindowTest, Minimize) {
   SendConfigureEvent(0, 0, 1, states.get());
   Sync();
 
-  EXPECT_CALL(*GetXdgSurface(), SetMinimized());
+  EXPECT_CALL(*GetXdgToplevel(), SetMinimized());
   // Wayland compositor doesn't notify clients about minimized state, but rather
   // if a window is not activated. Thus, a WaylandWindow marks itself as being
   // minimized and as soon as a configuration event with not activated state
@@ -319,7 +318,7 @@ TEST_P(WaylandWindowTest, SetFullscreenAndRestore) {
 
   AddStateToWlArray(XDG_TOPLEVEL_STATE_FULLSCREEN, states.get());
 
-  EXPECT_CALL(*GetXdgSurface(), SetFullscreen());
+  EXPECT_CALL(*GetXdgToplevel(), SetFullscreen());
   EXPECT_CALL(delegate_,
               OnWindowStateChanged(Eq(PlatformWindowState::kFullScreen)));
   window_->ToggleFullscreen();
@@ -330,7 +329,7 @@ TEST_P(WaylandWindowTest, SetFullscreenAndRestore) {
   SendConfigureEvent(0, 0, 2, states.get());
   Sync();
 
-  EXPECT_CALL(*GetXdgSurface(), UnsetFullscreen());
+  EXPECT_CALL(*GetXdgToplevel(), UnsetFullscreen());
   EXPECT_CALL(delegate_,
               OnWindowStateChanged(Eq(PlatformWindowState::kNormal)));
   window_->Restore();
@@ -347,7 +346,7 @@ TEST_P(WaylandWindowTest, StartWithFullscreen) {
 
   // The state must not be changed to the fullscreen before the surface is
   // activated.
-  EXPECT_CALL(*GetXdgSurface(), SetFullscreen()).Times(0);
+  EXPECT_CALL(*GetXdgToplevel(), SetFullscreen()).Times(0);
   EXPECT_CALL(delegate_, OnWindowStateChanged(_)).Times(0);
   window_->ToggleFullscreen();
   // The state of the window must still be a normal one.
@@ -357,7 +356,7 @@ TEST_P(WaylandWindowTest, StartWithFullscreen) {
 
   // Once the surface will be activated, the window will automatically trigger
   // the state change.
-  EXPECT_CALL(*GetXdgSurface(), SetFullscreen());
+  EXPECT_CALL(*GetXdgToplevel(), SetFullscreen());
   EXPECT_CALL(delegate_,
               OnWindowStateChanged(Eq(PlatformWindowState::kFullScreen)));
 
@@ -391,7 +390,7 @@ TEST_P(WaylandWindowTest, SetMaximizedFullscreenAndRestore) {
 
   auto active_maximized = MakeStateArray(
       {XDG_TOPLEVEL_STATE_ACTIVATED, XDG_TOPLEVEL_STATE_MAXIMIZED});
-  EXPECT_CALL(*GetXdgSurface(), SetMaximized());
+  EXPECT_CALL(*GetXdgToplevel(), SetMaximized());
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kMaximizedBounds.width(),
                                                kMaximizedBounds.height()));
   EXPECT_CALL(delegate_, OnActivationChanged(Eq(true)));
@@ -404,7 +403,7 @@ TEST_P(WaylandWindowTest, SetMaximizedFullscreenAndRestore) {
   Sync();
   VerifyAndClearExpectations();
 
-  EXPECT_CALL(*GetXdgSurface(), SetFullscreen());
+  EXPECT_CALL(*GetXdgToplevel(), SetFullscreen());
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kMaximizedBounds.width(),
                                                kMaximizedBounds.height()));
   EXPECT_CALL(delegate_, OnBoundsChanged(_)).Times(0);
@@ -419,8 +418,8 @@ TEST_P(WaylandWindowTest, SetMaximizedFullscreenAndRestore) {
 
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kNormalBounds.width(),
                                                kNormalBounds.height()));
-  EXPECT_CALL(*GetXdgSurface(), UnsetFullscreen());
-  EXPECT_CALL(*GetXdgSurface(), UnsetMaximized());
+  EXPECT_CALL(*GetXdgToplevel(), UnsetFullscreen());
+  EXPECT_CALL(*GetXdgToplevel(), UnsetMaximized());
   EXPECT_CALL(delegate_, OnBoundsChanged(kNormalBounds));
   EXPECT_CALL(delegate_,
               OnWindowStateChanged(Eq(PlatformWindowState::kNormal)));
@@ -841,7 +840,7 @@ TEST_P(WaylandWindowTest, CanDispatchEventToMenuWindowNested) {
 }
 
 TEST_P(WaylandWindowTest, DispatchWindowMove) {
-  EXPECT_CALL(*GetXdgSurface(), Move(_));
+  EXPECT_CALL(*GetXdgToplevel(), Move(_));
   ui::GetWmMoveResizeHandler(*window_)->DispatchHostWindowDragMovement(HTCAPTION, gfx::Point());
 }
 
@@ -855,7 +854,7 @@ TEST_P(WaylandWindowTest, DispatchWindowResize) {
   for (const int value : hit_test_values) {
     {
       uint32_t direction = wl::IdentifyDirection(*(connection_.get()), value);
-      EXPECT_CALL(*GetXdgSurface(), Resize(_, Eq(direction)));
+      EXPECT_CALL(*GetXdgToplevel(), Resize(_, Eq(direction)));
       wm_move_resize_handler->DispatchHostWindowDragMovement(value,
                                                              gfx::Point());
     }
@@ -1092,7 +1091,7 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   // shown on another display.
   auto active_maximized = MakeStateArray(
       {XDG_TOPLEVEL_STATE_ACTIVATED, XDG_TOPLEVEL_STATE_MAXIMIZED});
-  EXPECT_CALL(*GetXdgSurface(), SetMaximized());
+  EXPECT_CALL(*GetXdgToplevel(), SetMaximized());
 
   window_->Maximize();
   SendConfigureEvent(2493, 1413, 1, active_maximized.get());
@@ -1252,9 +1251,9 @@ TEST_P(WaylandWindowTest, OnSizeConstraintsChanged) {
       EXPECT_CALL(delegate_, GetMaximumSizeForWindow())
           .WillOnce(Return(max_size));
 
-      EXPECT_CALL(*GetXdgSurface(), SetMinSize(100, 200))
+      EXPECT_CALL(*GetXdgToplevel(), SetMinSize(100, 200))
           .Times(has_min_size ? 1 : 0);
-      EXPECT_CALL(*GetXdgSurface(), SetMaxSize(300, 400))
+      EXPECT_CALL(*GetXdgToplevel(), SetMaxSize(300, 400))
           .Times(has_max_size ? 1 : 0);
 
       window_->SizeConstraintsChanged();
@@ -1265,6 +1264,129 @@ TEST_P(WaylandWindowTest, OnSizeConstraintsChanged) {
   }
 }
 
+TEST_P(WaylandWindowTest, DestroysCreatesSurfaceOnHideShow) {
+  MockPlatformWindowDelegate delegate;
+  auto window = CreateWaylandWindowWithParams(
+      PlatformWindowType::kWindow, gfx::kNullAcceleratedWidget,
+      gfx::Rect(0, 0, 100, 100), &delegate);
+  ASSERT_TRUE(window);
+
+  Sync();
+
+  auto* mock_surface = server_.GetObject<wl::MockSurface>(window->GetWidget());
+  EXPECT_TRUE(mock_surface->xdg_surface());
+  EXPECT_TRUE(mock_surface->xdg_surface()->xdg_toplevel());
+
+  Sync();
+
+  window->Hide();
+
+  Sync();
+
+  EXPECT_FALSE(mock_surface->xdg_surface());
+
+  window->Show(false);
+
+  Sync();
+
+  EXPECT_TRUE(mock_surface->xdg_surface());
+  EXPECT_TRUE(mock_surface->xdg_surface()->xdg_toplevel());
+}
+
+TEST_P(WaylandWindowTest, DestroysCreatesPopupsOnHideShow) {
+  MockPlatformWindowDelegate delegate;
+  auto window = CreateWaylandWindowWithParams(
+      PlatformWindowType::kMenu, window_->GetWidget(), gfx::Rect(0, 0, 50, 50),
+      &delegate);
+  ASSERT_TRUE(window);
+
+  Sync();
+
+  auto* mock_surface = server_.GetObject<wl::MockSurface>(window->GetWidget());
+  EXPECT_TRUE(mock_surface->xdg_surface());
+  EXPECT_TRUE(mock_surface->xdg_surface()->xdg_popup());
+
+  Sync();
+
+  window->Hide();
+
+  Sync();
+
+  EXPECT_FALSE(mock_surface->xdg_surface());
+
+  window->Show(false);
+
+  Sync();
+
+  EXPECT_TRUE(mock_surface->xdg_surface());
+  EXPECT_TRUE(mock_surface->xdg_surface()->xdg_popup());
+}
+
+// Tests that if the window gets hidden and shown again, the title, app id and
+// size constraints remain the same.
+TEST_P(WaylandWindowTest, SetsPropertiesOnShow) {
+  constexpr char kAppId[] = "wayland_test";
+  const base::string16 kTitle(base::UTF8ToUTF16("WaylandWindowTest"));
+
+  PlatformWindowInitProperties properties;
+  properties.bounds = gfx::Rect(0, 0, 100, 100);
+  properties.type = PlatformWindowType::kWindow;
+  properties.wm_class_class = kAppId;
+
+  MockPlatformWindowDelegate delegate;
+  auto window = WaylandWindow::Create(&delegate, connection_.get(),
+                                      std::move(properties));
+  DCHECK(window);
+  window->Show(false);
+
+  Sync();
+
+  auto* mock_surface = server_.GetObject<wl::MockSurface>(window->GetWidget());
+  auto* mock_xdg_toplevel = mock_surface->xdg_surface()->xdg_toplevel();
+
+  // Only app id must be set now.
+  EXPECT_EQ(std::string(kAppId), mock_xdg_toplevel->app_id());
+  EXPECT_TRUE(mock_xdg_toplevel->title().empty());
+  EXPECT_TRUE(mock_xdg_toplevel->min_size().IsEmpty());
+  EXPECT_TRUE(mock_xdg_toplevel->max_size().IsEmpty());
+
+  // Now, propagate size constraints and title.
+  base::Optional<gfx::Size> min_size(gfx::Size(1, 1));
+  base::Optional<gfx::Size> max_size(gfx::Size(100, 100));
+  EXPECT_CALL(delegate, GetMinimumSizeForWindow()).WillOnce(Return(min_size));
+  EXPECT_CALL(delegate, GetMaximumSizeForWindow()).WillOnce(Return(max_size));
+
+  EXPECT_CALL(*mock_xdg_toplevel,
+              SetMinSize(min_size.value().width(), min_size.value().height()));
+  EXPECT_CALL(*mock_xdg_toplevel,
+              SetMaxSize(max_size.value().width(), max_size.value().height()));
+  EXPECT_CALL(*mock_xdg_toplevel, SetTitle(base::UTF16ToUTF8(kTitle)));
+
+  window->SetTitle(kTitle);
+  window->SizeConstraintsChanged();
+
+  Sync();
+
+  window->Hide();
+
+  Sync();
+
+  window->Show(false);
+
+  Sync();
+
+  mock_xdg_toplevel = mock_surface->xdg_surface()->xdg_toplevel();
+
+  // We can't mock all those methods above as long as the xdg_toplevel is
+  // created and destroyed on each show and hide call. However, it is the same
+  // WaylandSurface object that cached the values we set and must restore them
+  // on Show().
+  EXPECT_EQ(mock_xdg_toplevel->min_size(), min_size.value());
+  EXPECT_EQ(mock_xdg_toplevel->max_size(), max_size.value());
+  EXPECT_EQ(std::string(kAppId), mock_xdg_toplevel->app_id());
+  EXPECT_EQ(mock_xdg_toplevel->title(), base::UTF16ToUTF8(kTitle));
+}
+
 INSTANTIATE_TEST_SUITE_P(XdgVersionStableTest,
                          WaylandWindowTest,
                          ::testing::Values(kXdgShellStable));
diff --git a/ui/ozone/platform/wayland/test/mock_surface.h b/ui/ozone/platform/wayland/test/mock_surface.h
index 27f7a2c09aab..47dc4680d50b 100644
--- a/ui/ozone/platform/wayland/test/mock_surface.h
+++ b/ui/ozone/platform/wayland/test/mock_surface.h
@@ -42,15 +42,10 @@ class MockSurface : public ServerObject {
   MOCK_METHOD4(DamageBuffer,
                void(int32_t x, int32_t y, int32_t width, int32_t height));
 
-  void set_xdg_surface(std::unique_ptr<MockXdgSurface> xdg_surface) {
-    xdg_surface_ = std::move(xdg_surface);
+  void set_xdg_surface(MockXdgSurface* xdg_surface) {
+    xdg_surface_ = xdg_surface;
   }
-  MockXdgSurface* xdg_surface() const { return xdg_surface_.get(); }
-
-  void set_xdg_popup(std::unique_ptr<MockXdgPopup> xdg_popup) {
-    xdg_popup_ = std::move(xdg_popup);
-  }
-  MockXdgPopup* xdg_popup() const { return xdg_popup_.get(); }
+  MockXdgSurface* xdg_surface() const { return xdg_surface_; }
 
   void set_sub_surface(TestSubSurface* sub_surface) {
     sub_surface_ = sub_surface;
@@ -62,17 +57,14 @@ class MockSurface : public ServerObject {
     frame_callback_ = callback_resource;
   }
 
-  bool has_role() const {
-    return !!xdg_surface_ || !!xdg_popup_ || !!sub_surface_;
-  }
+  bool has_role() const { return !!xdg_surface_ || !!sub_surface_; }
 
   void AttachNewBuffer(wl_resource* buffer_resource, int32_t x, int32_t y);
   void ReleasePrevAttachedBuffer();
   void SendFrameCallback();
 
  private:
-  std::unique_ptr<MockXdgSurface> xdg_surface_;
-  std::unique_ptr<MockXdgPopup> xdg_popup_;
+  MockXdgSurface* xdg_surface_ = nullptr;
   TestSubSurface* sub_surface_ = nullptr;
 
   wl_resource* frame_callback_ = nullptr;
diff --git a/ui/ozone/platform/wayland/test/mock_xdg_popup.cc b/ui/ozone/platform/wayland/test/mock_xdg_popup.cc
index ebf449ca3e55..4a92c79edab0 100644
--- a/ui/ozone/platform/wayland/test/mock_xdg_popup.cc
+++ b/ui/ozone/platform/wayland/test/mock_xdg_popup.cc
@@ -4,6 +4,8 @@
 
 #include "ui/ozone/platform/wayland/test/mock_xdg_popup.h"
 
+#include "ui/ozone/platform/wayland/test/mock_xdg_surface.h"
+
 namespace wl {
 
 namespace {
@@ -27,9 +29,11 @@ const struct zxdg_popup_v6_interface kZxdgPopupV6Impl = {
     &Grab,             // grab
 };
 
-MockXdgPopup::MockXdgPopup(wl_resource* resource, const void* implementation)
-    : ServerObject(resource) {
-  SetImplementationUnretained(resource, implementation, this);
+MockXdgPopup::MockXdgPopup(wl_resource* resource, wl_resource* surface)
+    : ServerObject(resource), surface_(surface) {
+  auto* mock_xdg_surface = GetUserDataAs<MockXdgSurface>(surface_);
+  if (mock_xdg_surface)
+    mock_xdg_surface->set_xdg_popup(nullptr);
 }
 
 MockXdgPopup::~MockXdgPopup() {}
diff --git a/ui/ozone/platform/wayland/test/mock_xdg_popup.h b/ui/ozone/platform/wayland/test/mock_xdg_popup.h
index 27b02361d897..61a805130200 100644
--- a/ui/ozone/platform/wayland/test/mock_xdg_popup.h
+++ b/ui/ozone/platform/wayland/test/mock_xdg_popup.h
@@ -24,7 +24,7 @@ extern const struct zxdg_popup_v6_interface kZxdgPopupV6Impl;
 
 class MockXdgPopup : public ServerObject {
  public:
-  MockXdgPopup(wl_resource* resource, const void* implementation);
+  MockXdgPopup(wl_resource* resource, wl_resource* surface);
   ~MockXdgPopup() override;
 
   MOCK_METHOD1(Grab, void(uint32_t serial));
@@ -42,9 +42,11 @@ class MockXdgPopup : public ServerObject {
   }
 
  private:
-  // Position of the popup. Used only with V6.
   struct TestPositioner::PopupPosition position_;
 
+  // Ground surface for this popup.
+  wl_resource* surface_ = nullptr;
+
   DISALLOW_COPY_AND_ASSIGN(MockXdgPopup);
 };
 
diff --git a/ui/ozone/platform/wayland/test/mock_xdg_shell.cc b/ui/ozone/platform/wayland/test/mock_xdg_shell.cc
index 1ba63d431015..cd76626a1245 100644
--- a/ui/ozone/platform/wayland/test/mock_xdg_shell.cc
+++ b/ui/ozone/platform/wayland/test/mock_xdg_shell.cc
@@ -29,15 +29,16 @@ void GetXdgSurfaceImpl(wl_client* client,
     wl_resource_post_error(resource, xdg_error, "surface already has a role");
     return;
   }
-  wl_resource* xdg_surface_resource = wl_resource_create(
-      client, interface, wl_resource_get_version(resource), id);
 
+  wl_resource* xdg_surface_resource =
+      CreateResourceWithImpl<::testing::NiceMock<MockXdgSurface>>(
+          client, interface, wl_resource_get_version(resource), implementation,
+          id, surface_resource);
   if (!xdg_surface_resource) {
     wl_client_post_no_memory(client);
     return;
   }
-  surface->set_xdg_surface(
-      std::make_unique<MockXdgSurface>(xdg_surface_resource, implementation));
+  surface->set_xdg_surface(GetUserDataAs<MockXdgSurface>(xdg_surface_resource));
 }
 
 void CreatePositioner(wl_client* client,
diff --git a/ui/ozone/platform/wayland/test/mock_xdg_surface.cc b/ui/ozone/platform/wayland/test/mock_xdg_surface.cc
index 35963f84b963..d0bd03add2bd 100644
--- a/ui/ozone/platform/wayland/test/mock_xdg_surface.cc
+++ b/ui/ozone/platform/wayland/test/mock_xdg_surface.cc
@@ -4,6 +4,7 @@
 
 #include <xdg-shell-unstable-v6-server-protocol.h>
 
+#include "ui/ozone/platform/wayland/test/mock_surface.h"
 #include "ui/ozone/platform/wayland/test/mock_xdg_popup.h"
 #include "ui/ozone/platform/wayland/test/mock_xdg_surface.h"
 #include "ui/ozone/platform/wayland/test/test_positioner.h"
@@ -11,18 +12,26 @@
 namespace wl {
 
 void SetTitle(wl_client* client, wl_resource* resource, const char* title) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetTitle(title);
+  auto* toplevel = GetUserDataAs<MockXdgTopLevel>(resource);
+  // As it this can be envoked during construction of the XdgSurface, cache the
+  // result so that tests are able to access that information.
+  toplevel->set_title(title);
+  toplevel->SetTitle(toplevel->title());
 }
 
 void SetAppId(wl_client* client, wl_resource* resource, const char* app_id) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetAppId(app_id);
+  auto* toplevel = GetUserDataAs<MockXdgTopLevel>(resource);
+  toplevel->SetAppId(app_id);
+  // As it this can be envoked during construction of the XdgSurface, cache the
+  // result so that tests are able to access that information.
+  toplevel->set_app_id(app_id);
 }
 
 void Move(wl_client* client,
           wl_resource* resource,
           wl_resource* seat,
           uint32_t serial) {
-  GetUserDataAs<MockXdgSurface>(resource)->Move(serial);
+  GetUserDataAs<MockXdgTopLevel>(resource)->Move(serial);
 }
 
 void Resize(wl_client* client,
@@ -30,7 +39,7 @@ void Resize(wl_client* client,
             wl_resource* seat,
             uint32_t serial,
             uint32_t edges) {
-  GetUserDataAs<MockXdgSurface>(resource)->Resize(serial, edges);
+  GetUserDataAs<MockXdgTopLevel>(resource)->Resize(serial, edges);
 }
 
 void AckConfigure(wl_client* client, wl_resource* resource, uint32_t serial) {
@@ -48,25 +57,47 @@ void SetWindowGeometry(wl_client* client,
 }
 
 void SetMaximized(wl_client* client, wl_resource* resource) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetMaximized();
+  GetUserDataAs<MockXdgTopLevel>(resource)->SetMaximized();
 }
 
 void UnsetMaximized(wl_client* client, wl_resource* resource) {
-  GetUserDataAs<MockXdgSurface>(resource)->UnsetMaximized();
+  GetUserDataAs<MockXdgTopLevel>(resource)->UnsetMaximized();
 }
 
 void SetFullscreen(wl_client* client,
                    wl_resource* resource,
                    wl_resource* output) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetFullscreen();
+  GetUserDataAs<MockXdgTopLevel>(resource)->SetFullscreen();
 }
 
 void UnsetFullscreen(wl_client* client, wl_resource* resource) {
-  GetUserDataAs<MockXdgSurface>(resource)->UnsetFullscreen();
+  GetUserDataAs<MockXdgTopLevel>(resource)->UnsetFullscreen();
 }
 
 void SetMinimized(wl_client* client, wl_resource* resource) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetMinimized();
+  GetUserDataAs<MockXdgTopLevel>(resource)->SetMinimized();
+}
+
+void SetMaxSize(wl_client* client,
+                wl_resource* resource,
+                int32_t width,
+                int32_t height) {
+  auto* toplevel = GetUserDataAs<MockXdgTopLevel>(resource);
+  toplevel->SetMaxSize(width, height);
+  // As it this can be envoked during construction of the XdgSurface, cache the
+  // result so that tests are able to access that information.
+  toplevel->set_max_size(gfx::Size(width, height));
+}
+
+void SetMinSize(wl_client* client,
+                wl_resource* resource,
+                int32_t width,
+                int32_t height) {
+  auto* toplevel = GetUserDataAs<MockXdgTopLevel>(resource);
+  toplevel->SetMinSize(width, height);
+  // As it this can be envoked during construction of the XdgSurface, cache the
+  // result so that tests are able to access that information.
+  toplevel->set_min_size(gfx::Size(width, height));
 }
 
 void GetTopLevel(wl_client* client, wl_resource* resource, uint32_t id) {
@@ -120,13 +151,22 @@ void GetXdgPopup(struct wl_client* client,
     return;
   }
 
-  wl_resource* xdg_popup_resource = wl_resource_create(
-      client, &xdg_popup_interface, wl_resource_get_version(resource), id);
+  wl_resource* xdg_popup_resource =
+      CreateResourceWithImpl<::testing::NiceMock<MockXdgPopup>>(
+          client, &xdg_popup_interface, wl_resource_get_version(resource),
+          &kXdgPopupImpl, id, resource);
+
+  if (!xdg_popup_resource) {
+    wl_client_post_no_memory(client);
+    return;
+  }
+
+  auto* mock_xdg_popup = GetUserDataAs<MockXdgPopup>(xdg_popup_resource);
+  DCHECK(mock_xdg_popup);
+
   auto* positioner = GetUserDataAs<TestPositioner>(positioner_resource);
   DCHECK(positioner);
 
-  auto mock_xdg_popup =
-      std::make_unique<MockXdgPopup>(xdg_popup_resource, &kXdgPopupImpl);
   mock_xdg_popup->set_position(positioner->position());
   if (mock_xdg_popup->size().IsEmpty() ||
       mock_xdg_popup->anchor_rect().IsEmpty()) {
@@ -135,7 +175,7 @@ void GetXdgPopup(struct wl_client* client,
     return;
   }
 
-  mock_xdg_surface->set_xdg_popup(std::move(mock_xdg_popup));
+  mock_xdg_surface->set_xdg_popup(mock_xdg_popup);
 }
 
 void GetZXdgPopupV6(struct wl_client* client,
@@ -156,13 +196,22 @@ void GetZXdgPopupV6(struct wl_client* client,
     return;
   }
 
-  wl_resource* xdg_popup_resource = wl_resource_create(
-      client, &zxdg_popup_v6_interface, wl_resource_get_version(resource), id);
+  wl_resource* xdg_popup_resource =
+      CreateResourceWithImpl<::testing::NiceMock<MockXdgPopup>>(
+          client, &zxdg_popup_v6_interface, wl_resource_get_version(resource),
+          &kZxdgPopupV6Impl, id, resource);
+
+  if (!xdg_popup_resource) {
+    wl_client_post_no_memory(client);
+    return;
+  }
+
+  auto* mock_xdg_popup = GetUserDataAs<MockXdgPopup>(xdg_popup_resource);
+  DCHECK(mock_xdg_popup);
+
   auto* positioner = GetUserDataAs<TestPositioner>(positioner_resource);
   DCHECK(positioner);
 
-  auto mock_xdg_popup =
-      std::make_unique<MockXdgPopup>(xdg_popup_resource, &kZxdgPopupV6Impl);
   mock_xdg_popup->set_position(positioner->position());
   if (mock_xdg_popup->size().IsEmpty() ||
       mock_xdg_popup->anchor_rect().IsEmpty()) {
@@ -171,21 +220,7 @@ void GetZXdgPopupV6(struct wl_client* client,
     return;
   }
 
-  mock_xdg_surface->set_xdg_popup(std::move(mock_xdg_popup));
-}
-
-void SetMaxSize(wl_client* client,
-                wl_resource* resource,
-                int32_t width,
-                int32_t height) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetMaxSize(width, height);
-}
-
-void SetMinSize(wl_client* client,
-                wl_resource* resource,
-                int32_t width,
-                int32_t height) {
-  GetUserDataAs<MockXdgSurface>(resource)->SetMinSize(width, height);
+  mock_xdg_surface->set_xdg_popup(mock_xdg_popup);
 }
 
 const struct xdg_surface_interface kMockXdgSurfaceImpl = {
@@ -238,17 +273,18 @@ const struct zxdg_toplevel_v6_interface kMockZxdgToplevelV6Impl = {
     &SetMinimized,     // set_minimized
 };
 
-MockXdgSurface::MockXdgSurface(wl_resource* resource,
-                               const void* implementation)
-    : ServerObject(resource) {
-  SetImplementationUnretained(resource, implementation, this);
-}
+MockXdgSurface::MockXdgSurface(wl_resource* resource, wl_resource* surface)
+    : ServerObject(resource), surface_(surface) {}
 
-MockXdgSurface::~MockXdgSurface() {}
+MockXdgSurface::~MockXdgSurface() {
+  auto* mock_surface = GetUserDataAs<MockSurface>(surface_);
+  if (mock_surface)
+    mock_surface->set_xdg_surface(nullptr);
+}
 
 MockXdgTopLevel::MockXdgTopLevel(wl_resource* resource,
                                  const void* implementation)
-    : MockXdgSurface(resource, implementation) {
+    : ServerObject(resource) {
   SetImplementationUnretained(resource, implementation, this);
 }
 
diff --git a/ui/ozone/platform/wayland/test/mock_xdg_surface.h b/ui/ozone/platform/wayland/test/mock_xdg_surface.h
index 20e0f96bdfcb..c41a6ed8fa32 100644
--- a/ui/ozone/platform/wayland/test/mock_xdg_surface.h
+++ b/ui/ozone/platform/wayland/test/mock_xdg_surface.h
@@ -30,60 +30,71 @@ class MockXdgTopLevel;
 // UI.
 class MockXdgSurface : public ServerObject {
  public:
-  MockXdgSurface(wl_resource* resource, const void* implementation);
+  MockXdgSurface(wl_resource* resource, wl_resource* surface);
   ~MockXdgSurface() override;
 
-  // These mock methods are shared between xdg_surface and zxdg_toplevel
-  // surface.
-  MOCK_METHOD1(SetParent, void(wl_resource* parent));
-  MOCK_METHOD1(SetTitle, void(const char* title));
-  MOCK_METHOD1(SetAppId, void(const char* app_id));
-  MOCK_METHOD1(Move, void(uint32_t serial));
-  MOCK_METHOD2(Resize, void(uint32_t serial, uint32_t edges));
   MOCK_METHOD1(AckConfigure, void(uint32_t serial));
   MOCK_METHOD4(SetWindowGeometry,
                void(int32_t x, int32_t y, int32_t width, int32_t height));
-  MOCK_METHOD0(SetMaximized, void());
-  MOCK_METHOD0(UnsetMaximized, void());
-  MOCK_METHOD0(SetFullscreen, void());
-  MOCK_METHOD0(UnsetFullscreen, void());
-  MOCK_METHOD0(SetMinimized, void());
-
-  // These methods are for zxdg_toplevel only.
-  MOCK_METHOD2(SetMaxSize, void(int32_t width, int32_t height));
-  MOCK_METHOD2(SetMinSize, void(int32_t width, int32_t height));
 
   void set_xdg_toplevel(std::unique_ptr<MockXdgTopLevel> xdg_toplevel) {
     xdg_toplevel_ = std::move(xdg_toplevel);
   }
   MockXdgTopLevel* xdg_toplevel() const { return xdg_toplevel_.get(); }
 
-  void set_xdg_popup(std::unique_ptr<MockXdgPopup> xdg_popup) {
-    xdg_popup_ = std::move(xdg_popup);
-  }
-  MockXdgPopup* xdg_popup() const { return xdg_popup_.get(); }
+  void set_xdg_popup(MockXdgPopup* xdg_popup) { xdg_popup_ = xdg_popup; }
+  MockXdgPopup* xdg_popup() const { return xdg_popup_; }
 
  private:
-  // Used when xdg v6 is used.
+  // Has either toplevel role..
   std::unique_ptr<MockXdgTopLevel> xdg_toplevel_;
+  // Or popup role.
+  MockXdgPopup* xdg_popup_ = nullptr;
 
-  std::unique_ptr<MockXdgPopup> xdg_popup_;
+  // MockSurface that is the ground for this xdg_surface.
+  wl_resource* surface_ = nullptr;
 
   DISALLOW_COPY_AND_ASSIGN(MockXdgSurface);
 };
 
 // Manage zxdg_toplevel for providing desktop UI.
-class MockXdgTopLevel : public MockXdgSurface {
+class MockXdgTopLevel : public ServerObject {
  public:
-  explicit MockXdgTopLevel(wl_resource* resource, const void* implementation);
+  MockXdgTopLevel(wl_resource* resource, const void* implementation);
   ~MockXdgTopLevel() override;
 
-  // TODO(msisov): mock other zxdg_toplevel specific methods once
-  // implementation
-  // is done. example: MOCK_METHOD2(SetMaxSize, void(int32_t width, int32_t
-  // height());
+  MOCK_METHOD1(SetParent, void(wl_resource* parent));
+  MOCK_METHOD1(SetTitle, void(const std::string& title));
+  MOCK_METHOD1(SetAppId, void(const char* app_id));
+  MOCK_METHOD1(Move, void(uint32_t serial));
+  MOCK_METHOD2(Resize, void(uint32_t serial, uint32_t edges));
+  MOCK_METHOD0(SetMaximized, void());
+  MOCK_METHOD0(UnsetMaximized, void());
+  MOCK_METHOD0(SetFullscreen, void());
+  MOCK_METHOD0(UnsetFullscreen, void());
+  MOCK_METHOD0(SetMinimized, void());
+  MOCK_METHOD2(SetMaxSize, void(int32_t width, int32_t height));
+  MOCK_METHOD2(SetMinSize, void(int32_t width, int32_t height));
+
+  const std::string& app_id() const { return app_id_; }
+  void set_app_id(const char* app_id) { app_id_ = std::string(app_id); }
+
+  std::string title() const { return title_; }
+  void set_title(const char* title) { title_ = std::string(title); }
+
+  const gfx::Size& min_size() const { return min_size_; }
+  void set_min_size(const gfx::Size& min_size) { min_size_ = min_size; }
+
+  const gfx::Size& max_size() const { return max_size_; }
+  void set_max_size(const gfx::Size& max_size) { max_size_ = max_size; }
 
  private:
+  gfx::Size min_size_;
+  gfx::Size max_size_;
+
+  std::string title_;
+  std::string app_id_;
+
   DISALLOW_COPY_AND_ASSIGN(MockXdgTopLevel);
 };
 
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 2543981d8c38..2866ab6a07f8 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -55,6 +55,8 @@ void WaylandTest::SetUp() {
                                   std::move(properties));
   ASSERT_NE(widget_, gfx::kNullAcceleratedWidget);
 
+  window_->Show(false);
+
   // Wait for the client to flush all pending requests from initialization.
   base::RunLoop().RunUntilIdle();
 
-- 
2.24.1

