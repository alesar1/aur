From ce9461fc62d2fe5cd337243900a5b971c913dff2 Mon Sep 17 00:00:00 2001
From: Oschowa <oschowa@web.de>
Date: Tue, 3 Nov 2020 11:46:45 +0100
Subject: [PATCH 01/11] Add PipeWire audio backend

based on this original pull request
https://github.com/mpv-player/mpv/pull/7902 by andreaskem
---
 audio/out/ao.c          |   4 +
 audio/out/ao_pipewire.c | 284 ++++++++++++++++++++++++++++++++++++++++
 wscript                 |   4 +
 wscript_build.py        |   1 +
 4 files changed, 293 insertions(+)
 create mode 100644 audio/out/ao_pipewire.c

diff --git a/audio/out/ao.c b/audio/out/ao.c
index 532b5bb4e2c..8fc56ef860d 100644
--- a/audio/out/ao.c
+++ b/audio/out/ao.c
@@ -41,6 +41,7 @@ extern const struct ao_driver audio_out_audiounit;
 extern const struct ao_driver audio_out_coreaudio;
 extern const struct ao_driver audio_out_coreaudio_exclusive;
 extern const struct ao_driver audio_out_rsound;
+extern const struct ao_driver audio_out_pipewire;
 extern const struct ao_driver audio_out_pulse;
 extern const struct ao_driver audio_out_jack;
 extern const struct ao_driver audio_out_openal;
@@ -63,6 +64,9 @@ static const struct ao_driver * const audio_out_drivers[] = {
 #if HAVE_COREAUDIO
     &audio_out_coreaudio,
 #endif
+#if HAVE_PIPEWIRE
+    &audio_out_pipewire,
+#endif
 #if HAVE_PULSE
     &audio_out_pulse,
 #endif
diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
new file mode 100644
index 00000000000..79965cdc68b
--- /dev/null
+++ b/audio/out/ao_pipewire.c
@@ -0,0 +1,284 @@
+
+#include <pipewire/pipewire.h>
+#include <spa/param/audio/format-utils.h>
+
+#include "common/msg.h"
+#include "options/m_config.h"
+#include "options/m_option.h"
+#include "ao.h"
+#include "audio/format.h"
+#include "config.h"
+#include "internal.h"
+#include "osdep/timer.h"
+
+struct ao_pipewire_opts {
+    int buffer_samples;
+};
+
+#define OPT_BASE_STRUCT struct ao_pipewire_opts
+static const struct m_sub_options ao_pipewire_conf = {
+    .opts = (const struct m_option[]) {
+        {"pipewire-buffer-samples", OPT_INT(buffer_samples)},
+        {0}
+    },
+    .defaults = &(const struct ao_pipewire_opts) {
+        .buffer_samples = 2048,
+    },
+    .size = sizeof(struct ao_pipewire_opts),
+};
+
+struct priv {
+    struct pw_thread_loop *loop;
+    struct pw_stream *stream;
+
+    struct ao_pipewire_opts *opts;
+};
+
+static enum spa_audio_format af_fmt_to_pw(enum af_format format)
+{
+    switch (format) {
+    case AF_FORMAT_U8:          return SPA_AUDIO_FORMAT_U8;
+    case AF_FORMAT_S16:         return SPA_AUDIO_FORMAT_S16;
+    case AF_FORMAT_S32:         return SPA_AUDIO_FORMAT_S32;
+    case AF_FORMAT_FLOAT:       return SPA_AUDIO_FORMAT_F32;
+    case AF_FORMAT_DOUBLE:      return SPA_AUDIO_FORMAT_F64;
+    case AF_FORMAT_U8P:         return SPA_AUDIO_FORMAT_U8P;
+    case AF_FORMAT_S16P:        return SPA_AUDIO_FORMAT_S16P;
+    case AF_FORMAT_S32P:        return SPA_AUDIO_FORMAT_S32P;
+    case AF_FORMAT_FLOATP:      return SPA_AUDIO_FORMAT_F32P;
+    case AF_FORMAT_DOUBLEP:     return SPA_AUDIO_FORMAT_F64P;
+    default:                    return SPA_AUDIO_FORMAT_UNKNOWN;
+    }
+}
+
+static const enum spa_audio_channel mp_speaker_id_to_spa[] = {
+    [MP_SPEAKER_ID_FL]          = SPA_AUDIO_CHANNEL_FL,
+    [MP_SPEAKER_ID_FR]          = SPA_AUDIO_CHANNEL_FR,
+    [MP_SPEAKER_ID_FC]          = SPA_AUDIO_CHANNEL_FC,
+    [MP_SPEAKER_ID_LFE]         = SPA_AUDIO_CHANNEL_LFE,
+    [MP_SPEAKER_ID_BL]          = SPA_AUDIO_CHANNEL_RL,
+    [MP_SPEAKER_ID_BR]          = SPA_AUDIO_CHANNEL_RR,
+    [MP_SPEAKER_ID_FLC]         = SPA_AUDIO_CHANNEL_FLC,
+    [MP_SPEAKER_ID_FRC]         = SPA_AUDIO_CHANNEL_FRC,
+    [MP_SPEAKER_ID_BC]          = SPA_AUDIO_CHANNEL_RC,
+    [MP_SPEAKER_ID_SL]          = SPA_AUDIO_CHANNEL_SL,
+    [MP_SPEAKER_ID_SR]          = SPA_AUDIO_CHANNEL_SR,
+    [MP_SPEAKER_ID_TC]          = SPA_AUDIO_CHANNEL_TC,
+    [MP_SPEAKER_ID_TFL]         = SPA_AUDIO_CHANNEL_TFL,
+    [MP_SPEAKER_ID_TFC]         = SPA_AUDIO_CHANNEL_TFC,
+    [MP_SPEAKER_ID_TFR]         = SPA_AUDIO_CHANNEL_TFR,
+    [MP_SPEAKER_ID_TBL]         = SPA_AUDIO_CHANNEL_TRL,
+    [MP_SPEAKER_ID_TBC]         = SPA_AUDIO_CHANNEL_TRC,
+    [MP_SPEAKER_ID_TBR]         = SPA_AUDIO_CHANNEL_TRR,
+    [MP_SPEAKER_ID_DL]          = SPA_AUDIO_CHANNEL_FL,
+    [MP_SPEAKER_ID_DR]          = SPA_AUDIO_CHANNEL_FR,
+    [MP_SPEAKER_ID_WL]          = SPA_AUDIO_CHANNEL_FL,
+    [MP_SPEAKER_ID_WR]          = SPA_AUDIO_CHANNEL_FR,
+    [MP_SPEAKER_ID_SDL]         = SPA_AUDIO_CHANNEL_SL,
+    [MP_SPEAKER_ID_SDR]         = SPA_AUDIO_CHANNEL_SL,
+    [MP_SPEAKER_ID_LFE2]        = SPA_AUDIO_CHANNEL_LFE2,
+    [MP_SPEAKER_ID_NA]          = SPA_AUDIO_CHANNEL_NA,
+};
+
+static void on_process(void *userdata)
+{
+    struct ao *ao = userdata;
+    struct priv *p = ao->priv;
+    struct pw_time time;
+    struct pw_buffer *b;
+    void *data[MP_NUM_CHANNELS];
+
+    if ((b = pw_stream_dequeue_buffer(p->stream)) == NULL) {
+        pw_log_warn("out of buffers: %m");
+        return;
+    }
+
+    struct spa_buffer *buf = b->buffer;
+
+    int bytes_per_channel = buf->datas[0].maxsize / ao->channels.num;
+    int nframes = bytes_per_channel / ao->sstride;
+
+    for (int i = 0; i < buf->n_datas; i++) {
+        data[i] = buf->datas[i].data;
+        buf->datas[i].chunk->size = bytes_per_channel;
+        buf->datas[i].chunk->offset = 0;
+    }
+
+    pw_stream_get_time(p->stream, &time);
+    if (time.rate.denom == 0)
+        time.rate.denom = ao->samplerate;
+
+    int64_t end_time = mp_time_us();
+    /* time.queued is always going to be 0, so we don't need to care */
+    end_time += (nframes + time.delay) * SPA_USEC_PER_SEC / time.rate.denom;
+
+    ao_read_data(ao, data, nframes, end_time);
+
+    pw_stream_queue_buffer(p->stream, b);
+}
+
+static void on_param_changed(void *userdata, uint32_t id, const struct spa_pod *param)
+{
+    struct ao *ao = userdata;
+    struct priv *p = ao->priv;
+	const struct spa_pod *params[1];
+	uint8_t buffer[1024];
+	struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
+
+    if (param == NULL || id != SPA_PARAM_Format)
+        return;
+
+    int buffer_size = ao->device_buffer * af_fmt_to_bytes(ao->format) * ao->channels.num;
+
+    params[0] = spa_pod_builder_add_object(&b,
+                    SPA_TYPE_OBJECT_ParamBuffers, SPA_PARAM_Buffers,
+                    SPA_PARAM_BUFFERS_blocks,     SPA_POD_Int(ao->num_planes),
+                    SPA_PARAM_BUFFERS_size,       SPA_POD_Int(buffer_size),
+                    SPA_PARAM_BUFFERS_stride,     SPA_POD_Int(ao->sstride));
+
+    pw_stream_update_params(p->stream, params, 1);
+}
+
+static void on_state_changed(void *userdata, enum pw_stream_state old, enum pw_stream_state state, const char *error)
+{
+    struct ao *ao = userdata;
+    MP_DBG(ao, "Stream state changed: old_state=%d state=%d error=%s\n", old, state, error);
+
+    if (state == PW_STREAM_STATE_ERROR) {
+        MP_WARN(ao, "Stream in error state, trying to reload...\n");
+        ao_request_reload(ao);
+    }
+}
+
+static const struct pw_stream_events stream_events = {
+    .version = PW_VERSION_STREAM_EVENTS,
+    .param_changed = on_param_changed,
+    .process = on_process,
+    .state_changed = on_state_changed,
+};
+
+static void uninit(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    if (p->loop)
+        pw_thread_loop_stop(p->loop);
+    if (p->stream)
+        pw_stream_destroy(p->stream);
+    p->stream = NULL;
+    if (p->loop)
+        pw_thread_loop_destroy(p->loop);
+    p->loop = NULL;
+    pw_deinit();
+}
+
+static int init(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    uint8_t buffer[1024];
+    struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
+    const struct spa_pod *params[1];
+    char latency_str[64];
+
+    p->opts = mp_get_config_group(ao, ao->global, &ao_pipewire_conf);
+
+    enum spa_audio_format spa_format = af_fmt_to_pw(ao->format);
+    if (spa_format == SPA_AUDIO_FORMAT_UNKNOWN) {
+        ao->format = AF_FORMAT_FLOATP;
+        spa_format = SPA_AUDIO_FORMAT_F32P;
+    }
+
+    struct spa_audio_info_raw audio_info = {
+        .format = spa_format,
+        .rate = ao->samplerate,
+        .channels = ao->channels.num,
+    };
+
+    for (int i = 0; i < ao->channels.num; i++)
+        audio_info.position[i] = mp_speaker_id_to_spa[ao->channels.speaker[i]];
+
+    params[0] = spa_format_audio_raw_build(&b, SPA_PARAM_EnumFormat, &audio_info);
+
+    if (af_fmt_is_planar(ao->format)) {
+        ao->num_planes = ao->channels.num;
+        ao->sstride = af_fmt_to_bytes(ao->format);
+    } else {
+        ao->num_planes = 1;
+        ao->sstride = ao->channels.num * af_fmt_to_bytes(ao->format);
+    }
+
+    ao->device_buffer = p->opts->buffer_samples;
+    snprintf(latency_str, sizeof(latency_str), "%d/%d", ao->device_buffer, ao->samplerate);
+
+    pw_init(NULL, NULL);
+
+    p->loop = pw_thread_loop_new("ao-pipewire", NULL);
+    if (p->loop == NULL)
+        goto error;
+
+    p->stream = pw_stream_new_simple(
+                    pw_thread_loop_get_loop(p->loop),
+                    "audio-src",
+                    pw_properties_new(
+                        PW_KEY_MEDIA_TYPE, "Audio",
+                        PW_KEY_MEDIA_CATEGORY, "Playback",
+                        PW_KEY_MEDIA_ROLE, "Music",
+                        PW_KEY_NODE_NAME, "mpv",
+                        PW_KEY_NODE_LATENCY, latency_str,
+                        NULL),
+                    &stream_events,
+                    ao);
+    if (p->stream == NULL)
+        goto error;
+
+    if (pw_stream_connect(p->stream,
+                    PW_DIRECTION_OUTPUT,
+                    PW_ID_ANY,
+                    PW_STREAM_FLAG_AUTOCONNECT |
+                    PW_STREAM_FLAG_MAP_BUFFERS |
+                    PW_STREAM_FLAG_RT_PROCESS,
+                    params, 1) < 0)
+        goto error;
+
+    if (pw_thread_loop_start(p->loop) < 0)
+        goto error;
+
+    return 0;
+
+error:
+    uninit(ao);
+    return -1;
+}
+
+static void reset(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    pw_thread_loop_lock(p->loop);
+    pw_stream_set_active(p->stream, false);
+    pw_thread_loop_unlock(p->loop);
+}
+
+static void start(struct ao *ao)
+{
+    struct priv *p = ao->priv;
+    pw_thread_loop_lock(p->loop);
+    pw_stream_set_active(p->stream, true);
+    pw_thread_loop_unlock(p->loop);
+}
+
+const struct ao_driver audio_out_pipewire = {
+    .description = "PipeWire audio output",
+    .name        = "pipewire",
+
+    .init        = init,
+    .uninit      = uninit,
+    .reset       = reset,
+    .start       = start,
+
+    .priv_size = sizeof(struct priv),
+    .priv_defaults = &(const struct priv)
+    {
+        .loop = NULL,
+        .stream = NULL,
+    },
+    .global_opts = &ao_pipewire_conf,
+};
diff --git a/wscript b/wscript
index a0227e648e4..4baa8b80d6a 100644
--- a/wscript
+++ b/wscript
@@ -434,6 +434,10 @@ audio_output_features = [
         'desc': 'OSSv4 audio output',
         'func': check_statement(['sys/soundcard.h'], 'int x = SNDCTL_DSP_SETPLAYVOL'),
         'deps': 'posix && gpl',
+    }, {
+        'name': '--pipewire',
+        'desc': 'PipeWire audio output',
+        'func': check_pkg_config('libpipewire-0.3', '>= 0.3.0')
     }, {
         'name': '--pulse',
         'desc': 'PulseAudio audio output',
diff --git a/wscript_build.py b/wscript_build.py
index 9fc0d25a51e..d9d6a13dd32 100644
--- a/wscript_build.py
+++ b/wscript_build.py
@@ -246,6 +246,7 @@ def swift(task):
         ( "audio/out/ao_opensles.c",             "opensles" ),
         ( "audio/out/ao_oss.c",                  "oss-audio" ),
         ( "audio/out/ao_pcm.c" ),
+        ( "audio/out/ao_pipewire.c",             "pipewire" ),
         ( "audio/out/ao_pulse.c",                "pulse" ),
         ( "audio/out/ao_sdl.c",                  "sdl2-audio" ),
         ( "audio/out/ao_wasapi.c",               "wasapi" ),

From 1239cb7f151e021f166d993ada0780e869110394 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Tue, 8 Jun 2021 00:24:00 +0200
Subject: [PATCH 02/11] ao_pipewire: whitespace fixes

---
 audio/out/ao_pipewire.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index 79965cdc68b..b0102bee8ea 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -121,9 +121,9 @@ static void on_param_changed(void *userdata, uint32_t id, const struct spa_pod *
 {
     struct ao *ao = userdata;
     struct priv *p = ao->priv;
-	const struct spa_pod *params[1];
-	uint8_t buffer[1024];
-	struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
+    const struct spa_pod *params[1];
+    uint8_t buffer[1024];
+    struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
 
     if (param == NULL || id != SPA_PARAM_Format)
         return;

From c706187797181968d0585d44cf72eaacaa70f473 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Tue, 8 Jun 2021 00:24:06 +0200
Subject: [PATCH 03/11] ao_pipewire: add more application properties

---
 audio/out/ao_pipewire.c | 6 +++++-
 1 file changed, 5 insertions(+), 1 deletion(-)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index b0102bee8ea..9f2a66ad845 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -8,6 +8,7 @@
 #include "ao.h"
 #include "audio/format.h"
 #include "config.h"
+#include "generated/version.h"
 #include "internal.h"
 #include "osdep/timer.h"
 
@@ -222,7 +223,10 @@ static int init(struct ao *ao)
                         PW_KEY_MEDIA_TYPE, "Audio",
                         PW_KEY_MEDIA_CATEGORY, "Playback",
                         PW_KEY_MEDIA_ROLE, "Music",
-                        PW_KEY_NODE_NAME, "mpv",
+                        PW_KEY_NODE_NAME, ao->client_name,
+                        PW_KEY_APP_NAME, ao->client_name,
+                        PW_KEY_APP_ID, ao->client_name,
+                        PW_KEY_APP_ICON_NAME, ao->client_name,
                         PW_KEY_NODE_LATENCY, latency_str,
                         NULL),
                     &stream_events,

From 1b1b8c85f70f19c018676b0ed432a397ba33c6fb Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Tue, 8 Jun 2021 00:24:11 +0200
Subject: [PATCH 04/11] ap_pipewire: implement audio controls

---
 audio/out/ao_pipewire.c | 95 +++++++++++++++++++++++++++++++++++++++++
 1 file changed, 95 insertions(+)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index 9f2a66ad845..a5c4322eebe 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -1,6 +1,8 @@
 
 #include <pipewire/pipewire.h>
 #include <spa/param/audio/format-utils.h>
+#include <spa/param/props.h>
+#include <math.h>
 
 #include "common/msg.h"
 #include "options/m_config.h"
@@ -33,6 +35,8 @@ struct priv {
     struct pw_stream *stream;
 
     struct ao_pipewire_opts *opts;
+    bool muted;
+    float volume[2];
 };
 
 static enum spa_audio_format af_fmt_to_pw(enum af_format format)
@@ -151,11 +155,44 @@ static void on_state_changed(void *userdata, enum pw_stream_state old, enum pw_s
     }
 }
 
+static float spa_volume_to_mp_volume(float vol)
+{
+        return cbrt(vol) * 100;
+}
+
+static float mp_volume_to_spa_volume(float vol)
+{
+        vol /= 100;
+        return vol * vol * vol;
+}
+
+static void on_control_info(void *userdata, uint32_t id,
+        const struct pw_stream_control *control)
+{
+    struct ao *ao = userdata;
+    struct priv *p = ao->priv;
+
+    switch (id) {
+        case SPA_PROP_mute:
+            if (control->n_values == 1)
+                p->muted = control->values[0] >= 0.5;
+            break;
+        case SPA_PROP_channelVolumes:
+            if (control->n_values == 2) {
+                p->volume[0] = control->values[0];
+                p->volume[1] = control->values[1];
+            }
+            break;
+    }
+}
+
+
 static const struct pw_stream_events stream_events = {
     .version = PW_VERSION_STREAM_EVENTS,
     .param_changed = on_param_changed,
     .process = on_process,
     .state_changed = on_state_changed,
+    .control_info = on_control_info,
 };
 
 static void uninit(struct ao *ao)
@@ -269,6 +306,62 @@ static void start(struct ao *ao)
     pw_thread_loop_unlock(p->loop);
 }
 
+#define CONTROL_RET(r) (!r ? CONTROL_OK : CONTROL_ERROR)
+
+static int control(struct ao *ao, enum aocontrol cmd, void *arg)
+{
+    struct priv *p = ao->priv;
+
+    switch (cmd) {
+        case AOCONTROL_GET_VOLUME: {
+                struct ao_control_vol *vol = arg;
+                vol->left = spa_volume_to_mp_volume(p->volume[0]);
+                vol->right = spa_volume_to_mp_volume(p->volume[1]);
+                return CONTROL_OK;
+        }
+        case AOCONTROL_GET_MUTE: {
+                bool *muted = arg;
+                *muted = p->muted;
+                return CONTROL_OK;
+        }
+        case AOCONTROL_SET_VOLUME:
+        case AOCONTROL_SET_MUTE:
+        case AOCONTROL_UPDATE_STREAM_TITLE: {
+            int ret;
+
+            pw_thread_loop_lock(p->loop);
+            switch (cmd) {
+                case AOCONTROL_SET_VOLUME: {
+                    struct ao_control_vol *vol = arg;
+                    float left = mp_volume_to_spa_volume(vol->left), right = mp_volume_to_spa_volume(vol->right);
+                    ret = CONTROL_RET(pw_stream_set_control(p->stream, SPA_PROP_channelVolumes, 2, &left, &right));
+                    break;
+               }
+                case AOCONTROL_SET_MUTE: {
+                    bool *muted = arg;
+                    float value = *muted ? 1.f : 0.f;
+                    ret = CONTROL_RET(pw_stream_set_control(p->stream, SPA_PROP_mute, 1, &value));
+                    break;
+                }
+                case AOCONTROL_UPDATE_STREAM_TITLE: {
+                    char *title = arg;
+                    struct spa_dict_item items[1];
+                    items[0] = SPA_DICT_ITEM_INIT(PW_KEY_MEDIA_NAME, title);
+                    ret = CONTROL_RET(pw_stream_update_properties(p->stream, &SPA_DICT_INIT(items, MP_ARRAY_SIZE(items))));
+                    break;
+                }
+                default:
+                    ret = CONTROL_NA;
+            }
+            pw_thread_loop_unlock(p->loop);
+            return ret;
+        }
+        default:
+            return CONTROL_UNKNOWN;
+    }
+}
+
+
 const struct ao_driver audio_out_pipewire = {
     .description = "PipeWire audio output",
     .name        = "pipewire",
@@ -278,6 +371,8 @@ const struct ao_driver audio_out_pipewire = {
     .reset       = reset,
     .start       = start,
 
+    .control     = control,
+
     .priv_size = sizeof(struct priv),
     .priv_defaults = &(const struct priv)
     {

From 06c940f36e79be42e3f7e18166baf9232aed9023 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Fri, 10 Dec 2021 19:46:18 +0100
Subject: [PATCH 05/11] ao_pipewire: make opt-in

The original author of ao_pipewire has reported to experience vsync
jitter with this ao, so have the user opt-in.
---
 audio/out/ao.c | 6 +++---
 1 file changed, 3 insertions(+), 3 deletions(-)

diff --git a/audio/out/ao.c b/audio/out/ao.c
index 8fc56ef860d..b9c1176fd99 100644
--- a/audio/out/ao.c
+++ b/audio/out/ao.c
@@ -64,9 +64,6 @@ static const struct ao_driver * const audio_out_drivers[] = {
 #if HAVE_COREAUDIO
     &audio_out_coreaudio,
 #endif
-#if HAVE_PIPEWIRE
-    &audio_out_pipewire,
-#endif
 #if HAVE_PULSE
     &audio_out_pulse,
 #endif
@@ -91,6 +88,9 @@ static const struct ao_driver * const audio_out_drivers[] = {
 #endif
 #if HAVE_SDL2_AUDIO
     &audio_out_sdl,
+#endif
+#if HAVE_PIPEWIRE
+    &audio_out_pipewire,
 #endif
     &audio_out_null,
 #if HAVE_COREAUDIO

From 6cdbf74e735741ca76858602b7508fabc0949466 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Sat, 11 Dec 2021 21:16:42 +0100
Subject: [PATCH 07/11] ao_pipwire: add to manpage

---
 DOCS/man/ao.rst | 13 +++++++++++++
 1 file changed, 13 insertions(+)

diff --git a/DOCS/man/ao.rst b/DOCS/man/ao.rst
index cc4cea0036a..d59c227c7ce 100644
--- a/DOCS/man/ao.rst
+++ b/DOCS/man/ao.rst
@@ -144,6 +144,19 @@ Available audio output drivers are:
         Allow mpv to use PulseAudio even if the sink is suspended (default: no).
         Can be useful if PulseAudio is running as a bridge to jack and mpv has its sink-input set to the one jack is using.
 
+``pipewire``
+    PipeWire audio output driver
+
+    The following global options are supported by this audio output:
+
+    ``--pipewire-buffer-samples=<n>``
+        Set the audio buffer size in samples. A higher value buffers
+        more data, and has a lower probability of buffer underruns. A smaller
+        value makes the audio stream react faster, e.g. to playback speed
+        changes.
+        The effective size of the buffer depends on the amount of buffered
+        samples and the samplerate.
+
 ``sdl``
     SDL 1.2+ audio output driver. Should work on any platform supported by SDL
     1.2, but may require the ``SDL_AUDIODRIVER`` environment variable to be set

From 72723d360585470405d9d7fd696c11ed6dfd1053 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Sun, 12 Dec 2021 21:47:19 +0100
Subject: [PATCH 08/11] ao_pipewire: simplify option parsing

---
 audio/out/ao_pipewire.c | 30 +++++++++---------------------
 1 file changed, 9 insertions(+), 21 deletions(-)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index a5c4322eebe..9d2b3a74230 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -14,27 +14,11 @@
 #include "internal.h"
 #include "osdep/timer.h"
 
-struct ao_pipewire_opts {
-    int buffer_samples;
-};
-
-#define OPT_BASE_STRUCT struct ao_pipewire_opts
-static const struct m_sub_options ao_pipewire_conf = {
-    .opts = (const struct m_option[]) {
-        {"pipewire-buffer-samples", OPT_INT(buffer_samples)},
-        {0}
-    },
-    .defaults = &(const struct ao_pipewire_opts) {
-        .buffer_samples = 2048,
-    },
-    .size = sizeof(struct ao_pipewire_opts),
-};
-
 struct priv {
     struct pw_thread_loop *loop;
     struct pw_stream *stream;
 
-    struct ao_pipewire_opts *opts;
+    int buffer_samples;
     bool muted;
     float volume[2];
 };
@@ -217,8 +201,6 @@ static int init(struct ao *ao)
     const struct spa_pod *params[1];
     char latency_str[64];
 
-    p->opts = mp_get_config_group(ao, ao->global, &ao_pipewire_conf);
-
     enum spa_audio_format spa_format = af_fmt_to_pw(ao->format);
     if (spa_format == SPA_AUDIO_FORMAT_UNKNOWN) {
         ao->format = AF_FORMAT_FLOATP;
@@ -244,7 +226,7 @@ static int init(struct ao *ao)
         ao->sstride = ao->channels.num * af_fmt_to_bytes(ao->format);
     }
 
-    ao->device_buffer = p->opts->buffer_samples;
+    ao->device_buffer = p->buffer_samples;
     snprintf(latency_str, sizeof(latency_str), "%d/%d", ao->device_buffer, ao->samplerate);
 
     pw_init(NULL, NULL);
@@ -361,6 +343,7 @@ static int control(struct ao *ao, enum aocontrol cmd, void *arg)
     }
 }
 
+#define OPT_BASE_STRUCT struct priv
 
 const struct ao_driver audio_out_pipewire = {
     .description = "PipeWire audio output",
@@ -378,6 +361,11 @@ const struct ao_driver audio_out_pipewire = {
     {
         .loop = NULL,
         .stream = NULL,
+        .buffer_samples = 2048
+    },
+    .options_prefix = "pipewire",
+    .options = (const struct m_option[]) {
+        {"buffer-samples", OPT_INT(buffer_samples)},
+        {0}
     },
-    .global_opts = &ao_pipewire_conf,
 };

From 99c1f415de2a41eca47c6fb28f1db68235d35f35 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Thu, 16 Dec 2021 23:20:36 +0100
Subject: [PATCH 09/11] ao_pipewire: explicitly pass samplerate to pipewire

---
 audio/out/ao_pipewire.c | 3 +++
 1 file changed, 3 insertions(+)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index 9d2b3a74230..ca887514c77 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -200,6 +200,7 @@ static int init(struct ao *ao)
     struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
     const struct spa_pod *params[1];
     char latency_str[64];
+    char samplerate_str[8];
 
     enum spa_audio_format spa_format = af_fmt_to_pw(ao->format);
     if (spa_format == SPA_AUDIO_FORMAT_UNKNOWN) {
@@ -228,6 +229,7 @@ static int init(struct ao *ao)
 
     ao->device_buffer = p->buffer_samples;
     snprintf(latency_str, sizeof(latency_str), "%d/%d", ao->device_buffer, ao->samplerate);
+    snprintf(samplerate_str, sizeof(samplerate_str), "1/%d", ao->samplerate);
 
     pw_init(NULL, NULL);
 
@@ -247,6 +249,7 @@ static int init(struct ao *ao)
                         PW_KEY_APP_ID, ao->client_name,
                         PW_KEY_APP_ICON_NAME, ao->client_name,
                         PW_KEY_NODE_LATENCY, latency_str,
+                        PW_KEY_NODE_RATE, samplerate_str,
                         NULL),
                     &stream_events,
                     ao);

From b6c24447729bd55d88d7c10baf60ec87e6711545 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Fri, 17 Dec 2021 19:00:28 +0100
Subject: [PATCH 10/11] ao_pipewire: clean up stream properties

---
 audio/out/ao_pipewire.c | 36 +++++++++++++++++++-----------------
 1 file changed, 19 insertions(+), 17 deletions(-)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index ca887514c77..16a3eebbfa0 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -199,8 +199,23 @@ static int init(struct ao *ao)
     uint8_t buffer[1024];
     struct spa_pod_builder b = SPA_POD_BUILDER_INIT(buffer, sizeof(buffer));
     const struct spa_pod *params[1];
-    char latency_str[64];
-    char samplerate_str[8];
+    struct pw_properties *props = pw_properties_new(
+        PW_KEY_MEDIA_TYPE, "Audio",
+        PW_KEY_MEDIA_CATEGORY, "Playback",
+        PW_KEY_MEDIA_ROLE, "Music",
+        PW_KEY_NODE_NAME, ao->client_name,
+        PW_KEY_NODE_DESCRIPTION, ao->client_name,
+        PW_KEY_APP_NAME, ao->client_name,
+        PW_KEY_APP_ID, ao->client_name,
+        PW_KEY_APP_ICON_NAME, ao->client_name,
+        PW_KEY_NODE_ALWAYS_PROCESS, "true",
+        NULL
+    );
+
+    ao->device_buffer = p->buffer_samples;
+
+    pw_properties_setf(props, PW_KEY_NODE_LATENCY, "%d/%d", ao->device_buffer, ao->samplerate);
+    pw_properties_setf(props, PW_KEY_NODE_RATE, "1/%d", ao->samplerate);
 
     enum spa_audio_format spa_format = af_fmt_to_pw(ao->format);
     if (spa_format == SPA_AUDIO_FORMAT_UNKNOWN) {
@@ -227,10 +242,6 @@ static int init(struct ao *ao)
         ao->sstride = ao->channels.num * af_fmt_to_bytes(ao->format);
     }
 
-    ao->device_buffer = p->buffer_samples;
-    snprintf(latency_str, sizeof(latency_str), "%d/%d", ao->device_buffer, ao->samplerate);
-    snprintf(samplerate_str, sizeof(samplerate_str), "1/%d", ao->samplerate);
-
     pw_init(NULL, NULL);
 
     p->loop = pw_thread_loop_new("ao-pipewire", NULL);
@@ -240,17 +251,7 @@ static int init(struct ao *ao)
     p->stream = pw_stream_new_simple(
                     pw_thread_loop_get_loop(p->loop),
                     "audio-src",
-                    pw_properties_new(
-                        PW_KEY_MEDIA_TYPE, "Audio",
-                        PW_KEY_MEDIA_CATEGORY, "Playback",
-                        PW_KEY_MEDIA_ROLE, "Music",
-                        PW_KEY_NODE_NAME, ao->client_name,
-                        PW_KEY_APP_NAME, ao->client_name,
-                        PW_KEY_APP_ID, ao->client_name,
-                        PW_KEY_APP_ICON_NAME, ao->client_name,
-                        PW_KEY_NODE_LATENCY, latency_str,
-                        PW_KEY_NODE_RATE, samplerate_str,
-                        NULL),
+                    props,
                     &stream_events,
                     ao);
     if (p->stream == NULL)
@@ -260,6 +261,7 @@ static int init(struct ao *ao)
                     PW_DIRECTION_OUTPUT,
                     PW_ID_ANY,
                     PW_STREAM_FLAG_AUTOCONNECT |
+                    PW_STREAM_FLAG_INACTIVE |
                     PW_STREAM_FLAG_MAP_BUFFERS |
                     PW_STREAM_FLAG_RT_PROCESS,
                     params, 1) < 0)

From d0c08f99c43b7df4d31ea999284fa66104384ca2 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Thomas=20Wei=C3=9Fschuh?= <thomas@t-8ch.de>
Date: Fri, 17 Dec 2021 19:28:23 +0100
Subject: [PATCH 11/11] ao_pipewire: fix volume control with only on channel

---
 audio/out/ao_pipewire.c | 5 ++++-
 1 file changed, 4 insertions(+), 1 deletion(-)

diff --git a/audio/out/ao_pipewire.c b/audio/out/ao_pipewire.c
index 16a3eebbfa0..7139ebbd5bb 100644
--- a/audio/out/ao_pipewire.c
+++ b/audio/out/ao_pipewire.c
@@ -162,7 +162,10 @@ static void on_control_info(void *userdata, uint32_t id,
                 p->muted = control->values[0] >= 0.5;
             break;
         case SPA_PROP_channelVolumes:
-            if (control->n_values == 2) {
+            if (control->n_values == 1) {
+                p->volume[0] = control->values[0];
+                p->volume[1] = control->values[0];
+            } else if (control->n_values == 2) {
                 p->volume[0] = control->values[0];
                 p->volume[1] = control->values[1];
             }
