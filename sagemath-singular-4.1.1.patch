diff --git a/src/sage/libs/singular/decl.pxd b/src/sage/libs/singular/decl.pxd
index 676544ab1e..5c8639d362 100644
--- a/src/sage/libs/singular/decl.pxd
+++ b/src/sage/libs/singular/decl.pxd
@@ -170,7 +170,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     int n_NumberOfParameters(const n_Procs_s* r)
 
-    ctypedef struct poly "polyrec":
+    ctypedef struct poly "spolyrec":
         poly *next
         number *coef
         unsigned long exp[1]
@@ -632,7 +632,7 @@ cdef extern from "singular/Singular/libsingular.h":
 
     # divide monomial p by monomial q, p,q const
 
-    poly *pDivide(poly *p,poly *q)
+    poly *pMDivide(poly *p,poly *q)
 
     # return the i-th power of p; p destroyed, requires global ring
 
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 089524d6b4..ce6d58fc6f 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -190,8 +190,8 @@ from sage.libs.singular.decl cimport (
     n_IsUnit, n_Invers,
     p_ISet, rChangeCurrRing, p_Copy, p_Init, p_SetCoeff, p_Setm, p_SetExp, p_Add_q,
     p_NSet, p_GetCoeff, p_Delete, p_GetExp, pNext, rRingVar, omAlloc0, omStrDup,
-    omFree, pDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
-    pDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
+    omFree, pMDivide, p_SetCoeff0, n_Init, p_DivisibleBy, pLcm, p_LmDivisibleBy,
+    pMDivide, p_IsConstant, p_ExpVectorEqual, p_String, p_LmInit, n_Copy,
     p_IsUnit, p_Series, p_Head, idInit, fast_map_common_subexp, id_Delete,
     p_IsHomogeneous, p_Homogen, p_Totaldegree,pLDeg1_Totaldegree, singclap_pdivide, singclap_factorize,
     idLift, IDELEMS, On, Off, SW_USE_CHINREM_GCD, SW_USE_EZGCD,
@@ -1692,8 +1697,8 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_generic):
         if not g._poly:
             raise ZeroDivisionError
 
-        if r!=currRing: rChangeCurrRing(r)  # pDivide
-        res = pDivide(f._poly, g._poly)
+        if r!=currRing: rChangeCurrRing(r)  # pMDivide
+        res = pMDivide(f._poly, g._poly)
         if coeff:
             if r.cf.type == n_unknown or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
                 n = r.cf.cfDiv( p_GetCoeff(f._poly, r) , p_GetCoeff(g._poly, r), r.cf)
@@ -1852,8 +1857,8 @@ cdef class MPolynomialRing_libsingular(MPolynomialRing_generic):
                    and (<MPolynomial_libsingular>g) \
                    and g.parent() is self \
                    and p_LmDivisibleBy((<MPolynomial_libsingular>g)._poly, m, r):
-                if r!=currRing: rChangeCurrRing(r)  # pDivide
-                flt = pDivide(f._poly, (<MPolynomial_libsingular>g)._poly)
+                if r!=currRing: rChangeCurrRing(r)  # pMDivide
+                flt = pMDivide(f._poly, (<MPolynomial_libsingular>g)._poly)
                 #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<MPolynomial_libsingular>g)._poly, r), r), r)
                 p_SetCoeff(flt, n_Init(1, r), r)
                 return new_MP(self,flt), g
@@ -4049,10 +4054,10 @@ cdef class MPolynomial_libsingular(MPolynomial):
             if _right.is_monomial():
                 p = _self._poly
                 quo = p_ISet(0,r)
-                if r != currRing: rChangeCurrRing(r)   # pDivide
+                if r != currRing: rChangeCurrRing(r)   # pMDivide
                 while p:
                     if p_DivisibleBy(_right._poly, p, r):
-                        temp = pDivide(p, _right._poly)
+                        temp = pMDivide(p, _right._poly)
                         p_SetCoeff0(temp, n_Copy(p_GetCoeff(p, r), r), r)
                         quo = p_Add_q(quo, temp, r)
                     p = pNext(p)
diff --git a/src/sage/rings/polynomial/plural.pyx b/src/sage/rings/polynomial/plural.pyx
index 3b45a38419..c0227fd364 100644
--- a/src/sage/rings/polynomial/plural.pyx
+++ b/src/sage/rings/polynomial/plural.pyx
@@ -999,7 +999,7 @@ cdef class NCPolynomialRing_plural(Ring):
         if not g._poly:
             raise ZeroDivisionError
 
-        res = pDivide(f._poly,g._poly)
+        res = pMDivide(f._poly,g._poly)
         if coeff:
             if (r.cf.type == n_unknown) or r.cf.cfDivBy(p_GetCoeff(f._poly, r), p_GetCoeff(g._poly, r), r.cf):
                 n = r.cf.cfDiv( p_GetCoeff(f._poly, r) , p_GetCoeff(g._poly, r), r.cf)
@@ -1194,7 +1194,7 @@ cdef class NCPolynomialRing_plural(Ring):
             if isinstance(g, NCPolynomial_plural) \
                    and (<NCPolynomial_plural>g) \
                    and p_LmDivisibleBy((<NCPolynomial_plural>g)._poly, m, r):
-                flt = pDivide(f._poly, (<NCPolynomial_plural>g)._poly)
+                flt = pMDivide(f._poly, (<NCPolynomial_plural>g)._poly)
                 #p_SetCoeff(flt, n_Div( p_GetCoeff(f._poly, r) , p_GetCoeff((<NCPolynomial_plural>g)._poly, r), r), r)
                 p_SetCoeff(flt, n_Init(1, r), r)
                 return new_NCP(self,flt), g
diff --git a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
index 809ca72c76..9610ce125d 100644
--- a/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
+++ b/src/sage/rings/polynomial/multi_polynomial_libsingular.pyx
@@ -4066,6 +4066,9 @@ cdef class MPolynomial_libsingular(MPolynomial):
             if r.cf.type == n_Znm or r.cf.type == n_Zn or r.cf.type == n_Z2m :
                 raise NotImplementedError("Division of multivariate polynomials over non fields by non-monomials not implemented.")
 
+        if is_IntegerRing(self._parent._base):
+            return self.change_ring(RationalField()) // right.change_ring(RationalField())
+        
         cdef int count = singular_polynomial_length_bounded(_self._poly,15)
         if count >= 15:  # note that _right._poly must be of shorter length than self._poly for us to care about this call
             sig_on()
@@ -4744,6 +4747,9 @@ cdef class MPolynomial_libsingular(MPolynomial):
         else:
             _right = <MPolynomial_libsingular>right
 
+        if is_IntegerRing(self._parent._base):
+            return self.change_ring(RationalField()).gcd(right.change_ring(RationalField()), algorithm, **kwds)
+
         cdef int count = singular_polynomial_length_bounded(self._poly,20) \
             + singular_polynomial_length_bounded(_right._poly,20)
         if count >= 20:
@@ -4814,6 +4822,9 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if self._parent._base.is_finite() and self._parent._base.characteristic() > 1<<29:
             raise NotImplementedError("LCM of multivariate polynomials over prime fields with characteristic > 2^29 is not implemented.")
 
+        if is_IntegerRing(self._parent._base):
+            return self.change_ring(RationalField()).lcm(g.change_ring(RationalField()))
+
         cdef int count = singular_polynomial_length_bounded(self._poly,20) \
             + singular_polynomial_length_bounded(_g._poly,20)
         if count >= 20:
@@ -4888,7 +4888,7 @@ cdef class MPolynomial_libsingular(MPolynomial):
         if right.is_zero():
             raise ZeroDivisionError

-        if not self._parent._base.is_field() and not is_IntegerRing(self._parent._base):
+        if not self._parent._base.is_field():
             py_quo = self//right
             py_rem = self - right*py_quo
             return py_quo, py_rem
