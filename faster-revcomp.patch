diff --git a/src/mash/Sketch.cpp b/src/mash/Sketch.cpp
index b2329fa..a15d769 100644
--- a/src/mash/Sketch.cpp
+++ b/src/mash/Sketch.cpp
@@ -1061,22 +1061,42 @@ Sketch::SketchOutput * loadCapnp(Sketch::SketchInput * input)
     return output;
 }
 
+
+/* Array from 0..25 of DNA complement of A..Z */
+const char complement[] = {
+  'T', // 'A' = A
+  'V', // 'B' = not A = C,T,G
+  'G', // 'C' = C
+  'H', // 'D' = not C = A,T,G
+  'N', // 'E' = .
+  'N', // 'F' = .
+  'C', // 'G' = G
+  'D', // 'H' = not G = A,C,T
+  'N', // 'I' = .
+  'N', // 'J' = .
+  'M', // 'K' = T,G = Keto
+  'N', // 'L' = .
+  'K', // 'M' = A,C = Amino
+  'N', // 'N' = A,C,T,G = uNkNowN
+  'N', // 'O' = .
+  'N', // 'P' = .
+  'N', // 'Q' = .
+  'Y', // 'R' = A,G = puRine
+  'S', // 'S' = G,C = Strong
+  'A', // 'T' = T
+  'A', // 'U' = T (RNA)
+  'B', // 'V' = not T = A,C,G
+  'W', // 'W' = A,T = Weak
+  'N', // 'X' = .
+  'R', // 'Y' = pYrimidine = C,T
+  'N', // 'Z' = .
+};
+
 void reverseComplement(const char * src, char * dest, int length)
 {
     for ( int i = 0; i < length; i++ )
     {
-        char base = src[i];
-        
-        switch ( base )
-        {
-            case 'A': base = 'T'; break;
-            case 'C': base = 'G'; break;
-            case 'G': base = 'C'; break;
-            case 'T': base = 'A'; break;
-            default: break;
-        }
-        
-        dest[length - i - 1] = base;
+        dest[i] = complement[ (int) src[length-i-1] - (int) 'A' ];
     }
 }
 
