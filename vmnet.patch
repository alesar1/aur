--- a/vmnet/Makefile
+++ b/vmnet/Makefile
@@ -43,7 +43,11 @@ INCLUDE      += -I$(SRCROOT)/shared
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
--- a/vmnet/bridge.c
+++ b/vmnet/bridge.c
@@ -636,7 +636,7 @@
 	 unsigned long flags;
 	 int i;
 
-	 atomic_inc(&clone->users);
+	 clone = skb_get(clone);
 
 	 clone->dev = dev;
 	 clone->protocol = eth_type_trans(clone, dev);
@@ -1143,11 +1143,16 @@
 static int
 VNetBridgeNotify(struct notifier_block *this, // IN: callback data (bridge)
                  u_long msg,                  // IN: type of event
-                 void *data)                  // IN: device pertaining to event
+                 void *data)                  // IN: net_device or notifier info
 {
    VNetBridge *bridge = list_entry(this, VNetBridge, notifier);
-   struct net_device *dev = (struct net_device *) data;
+   struct net_device *dev;
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 11, 0)
+   dev = netdev_notifier_info_to_dev(data);
+#else
+   dev = (struct net_device *)data;
+#endif
    switch (msg) {
    case NETDEV_UNREGISTER:
       LOG(2, (KERN_DEBUG "bridge-%s: interface %s is unregistering\n",
--- a/vmnet/compat_netdevice.h
+++ b/vmnet/compat_netdevice.h
@@ -337,4 +337,11 @@
 typedef u32 compat_netdev_features_t;
 #endif
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 7, 0) || \
+    (defined(RHEL_RELEASE_CODE) && RHEL_RELEASE_CODE >= 0x0704)
+#define compat_netif_trans_update(d) netif_trans_update(d)
+#else
+#define compat_netif_trans_update(d) do { (d)->trans_start = jiffies; } while (0)
+#endif
+
 #endif /* __COMPAT_NETDEVICE_H__ */
--- a/vmnet/netif.c
+++ b/vmnet/netif.c
@@ -149,7 +149,7 @@
    memcpy(deviceName, devName, sizeof deviceName);
    NULL_TERMINATE_STRING(deviceName);
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0) || defined(NET_NAME_USER)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(3, 18, 0)
    dev = alloc_netdev(sizeof *netIf, deviceName, NET_NAME_USER, VNetNetIfSetup);
 #else
    dev = alloc_netdev(sizeof *netIf, deviceName, VNetNetIfSetup);
@@ -465,7 +465,7 @@
    VNetSend(&netIf->port.jack, skb);
 
    netIf->stats.tx_packets++;
-   dev->trans_start = jiffies;
+   compat_netif_trans_update(dev);
 
    return 0;
 }
--- a/vmnet/userif.c
+++ b/vmnet/userif.c
@@ -36,6 +36,9 @@
 #include <linux/slab.h>
 #include <linux/version.h>
 #include <linux/wait.h>
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 11, 0)
+#include <linux/taskstats_kern.h>  // For <linux/sched/signal.h> without version dependency
+#endif
 
 #include <net/checksum.h>
 #include <net/sock.h>
@@ -112,10 +113,7 @@
    struct page *page = NULL;
    int retval;
 
-   down_read(&current->mm->mmap_sem);
-   retval = get_user_pages(current, current->mm, addr,
-			   1, 1, 0, &page, NULL);
-   up_read(&current->mm->mmap_sem);
+   retval = get_user_pages_fast(addr, 1, FOLL_WRITE, &page);
 
    if (retval != 1) {
       return NULL;
@@ -143,16 +143,21 @@
  */
 
 static INLINE int
-VNetUserIfMapPtr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapPtr(VA64 uAddr,      // IN: pointer to user memory
                  size_t size,     // IN: size of data
                  struct page **p, // OUT: locked page
                  void **ptr)      // OUT: kernel mapped pointer
 {
-   if (!access_ok(VERIFY_WRITE, (void *)uAddr, size) ||
-       (((uAddr + size - 1) & ~(PAGE_SIZE - 1)) !=
-        (uAddr & ~(PAGE_SIZE - 1)))) {
+   uint8 v;
+
+   /* Check area does not straddle two pages. */
+   if ((uAddr & (PAGE_SIZE - 1)) + size > PAGE_SIZE) {
       return -EINVAL;
    }
+   /* Check if it is user's area.  UserifLockPage() checks writability. */
+   if (copy_from_user(&v, (void *)(unsigned long)uAddr, sizeof v) != 0) {
+      return -EFAULT;
+   }
 
    *p = UserifLockPage(uAddr);
    if (*p == NULL) {
@@ -164,7 +169,7 @@
 }
 
 static INLINE int
-VNetUserIfMapUint32Ptr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapUint32Ptr(VA64 uAddr,      // IN: pointer to user memory
                        struct page **p, // OUT: locked page
                        uint32 **ptr)    // OUT: kernel mapped pointer
 {
@@ -209,7 +214,7 @@
       return -EBUSY;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->pollPtr, &pollPage,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->pollPtr, &pollPage,
                                         &pollPtr)) < 0) {
       return retval;
    }
@@ -227,7 +232,7 @@
       goto error_free;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->recvClusterPtr,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->recvClusterPtr,
                                         &recvClusterPage,
                                         &recvClusterCount)) < 0) {
       goto error_free;
--- a/vmnet/vmnetInt.h
+++ b/vmnet/vmnetInt.h
@@ -77,7 +77,7 @@
 
 
 extern struct proto vmnet_proto;
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 2, 0) || defined(sk_net_refcnt)
 #   define compat_sk_alloc(_bri, _pri) sk_alloc(&init_net, \
                                                 PF_NETLINK, _pri, &vmnet_proto, 1)
 #elif defined(VMW_NETDEV_HAS_NET)
From 8ba37a5023f939ba8d2e0d91b916ff442b1c18dd Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 31 Dec 2018 00:05:42 +0100
Subject: [PATCH] modules: replace SUBDIRS with M

Since commit 0126be38d988 ("kbuild: announce removal of SUBDIRS if used")
in v5.0-rc1, using SUBDIRS when building out of tree modules produces
a deprecation warning. As M used to work since pretty much ever, use it
unconditionally.
---
 vmmon-only/Makefile | 2 +-
 vmnet-only/Makefile | 2 +-
 2 files changed, 2 insertions(+), 2 deletions(-)

diff --git a/vmnet-only/Makefile b/vmnet-only/Makefile
index caab6b9..c2fc51f 100644
--- a/vmnet-only/Makefile
+++ b/vmnet-only/Makefile
@@ -121,7 +121,7 @@ prebuild:: ;
 postbuild:: ;
 
 $(DRIVER_KO): prebuild
-	$(MAKE) -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	$(MAKE) -C $(BUILD_DIR) M=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) modules
 	$(MAKE) -C $$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) postbuild
