--- a/vmnet/Makefile
+++ b/vmnet/Makefile
@@ -43,7 +43,11 @@ INCLUDE      += -I$(SRCROOT)/shared
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
@@ -98,6 +98,13 @@ auto-build: $(DRIVER_KO)
 $(DRIVER): $(DRIVER_KO)
 	if [ $< -nt $@ ] || [ ! -e $@ ] ; then cp -f $< $@; fi
 
+# Use SUBDIRS on 2.x, 3.x, 4.x.  Use M on newer kernels.
+ifeq ($(filter-out 2 3 4,$(firstword $(subst ., ,$(VM_UNAME)))),)
+DIRVAR := SUBDIRS
+else
+DIRVAR := M
+endif
+
 #
 # Define a setup target that gets built before the actual driver.
 # This target may not be used at all, but if it is then it will be defined
@@ -107,7 +114,7 @@ prebuild:: ;
 postbuild:: ;
 
 $(DRIVER_KO): prebuild
-	$(MAKE) -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	$(MAKE) -C $(BUILD_DIR) $(DIRVAR)=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) modules
 	$(MAKE) -C $$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) postbuild
--- a/vmnet/userif.c
+++ b/vmnet/userif.c
@@ -137,16 +137,21 @@
  */
 
 static INLINE int
-VNetUserIfMapPtr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapPtr(VA64 uAddr,      // IN: pointer to user memory
                  size_t size,     // IN: size of data
                  struct page **p, // OUT: locked page
                  void **ptr)      // OUT: kernel mapped pointer
 {
-   if (!access_ok(VERIFY_WRITE, (void *)uAddr, size) ||
-       (((uAddr + size - 1) & ~(PAGE_SIZE - 1)) !=
-        (uAddr & ~(PAGE_SIZE - 1)))) {
+   uint8 v;
+
+   /* Check area does not straddle two pages. */
+   if ((uAddr & (PAGE_SIZE - 1)) + size > PAGE_SIZE) {
       return -EINVAL;
    }
+   /* Check if it is user's area.  UserifLockPage() checks writability. */
+   if (copy_from_user(&v, (void *)(unsigned long)uAddr, sizeof v) != 0) {
+      return -EFAULT;
+   }
 
    *p = UserifLockPage(uAddr);
    if (*p == NULL) {
@@ -158,7 +163,7 @@
 }
 
 static INLINE int
-VNetUserIfMapUint32Ptr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapUint32Ptr(VA64 uAddr,      // IN: pointer to user memory
                        struct page **p, // OUT: locked page
                        uint32 **ptr)    // OUT: kernel mapped pointer
 {
@@ -201,7 +206,7 @@
       return -EBUSY;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->pollPtr, &pollPage,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->pollPtr, &pollPage,
                                         &pollPtr)) < 0) {
       return retval;
    }
@@ -213,7 +218,7 @@
       goto error_free;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->recvClusterPtr,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->recvClusterPtr,
                                         &recvClusterPage,
                                         &recvClusterCount)) < 0) {
       goto error_free;
From f404bc6855ea2c731b617d3b0a2971481eb31cbd Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Thu, 19 Sep 2019 12:20:20 +0200
Subject: [PATCH] vmnet: handle switch of skb_frag_t to bio_vec

The switch from custom skb_frag_t implementation to bio_vec in v5.4-rc1 is
mostly transparent for modules which use accessor for skb_frag_t members.
Unfortunately many users access the members directly and function
VNetCsumCopyDatagram() in vmnet is one of those.

Use accessors everywhere so that vmnet code is compatible with kernel 5.4
and newer. Use "compat_" prefix to avoid clashes with backports adding the
accessors to older codebase.
---
 vmnet-only/userif.c | 39 +++++++++++++++++++++++++++++----------
 1 file changed, 29 insertions(+), 10 deletions(-)

diff --git a/vmnet-only/userif.c b/vmnet-only/userif.c
index d385088..aab9478 100644
--- a/vmnet-only/userif.c
+++ b/vmnet-only/userif.c
@@ -78,13 +78,31 @@ static int  VNetUserIfSetUplinkState(VNetPort *port, uint8 linkUp);
 extern unsigned int  vnet_max_qlen;
 
 #if COMPAT_LINUX_VERSION_CHECK_LT(3, 2, 0)
-#   define compat_kmap(page) kmap(page)
-#   define compat_kunmap(page) kunmap(page)
+#   define compat_kmap_frag(frag) kmap((frag)->page)
+#   define compat_kunmap_frag(page) kunmap((frag)->page)
 #else
-#   define compat_kmap(page) kmap((page).p)
-#   define compat_kunmap(page) kunmap((page).p)
+#   define compat_kmap_frag(frag) kmap(skb_frag_page(frag))
+#   define compat_kunmap_frag(frag) kunmap(skb_frag_page(frag))
 #endif
 
+static unsigned int compat_skb_frag_size(const skb_frag_t *frag)
+{
+#if COMPAT_LINUX_VERSION_CHECK_LT(3, 2, 0)
+	return frag->size;
+#else
+	return skb_frag_size(frag);
+#endif
+}
+
+static unsigned int compat_skb_frag_off(const skb_frag_t *frag)
+{
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 4, 0)
+	return frag->page_offset;
+#else
+	return skb_frag_off(frag);
+#endif
+}
+
 /*
  *-----------------------------------------------------------------------------
  *
@@ -564,20 +582,21 @@ VNetCsumCopyDatagram(const struct sk_buff *skb,	// IN: skb to copy
    for (frag = skb_shinfo(skb)->frags;
 	frag != skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;
 	frag++) {
-      if (frag->size > 0) {
+      if (compat_skb_frag_size(frag) > 0) {
 	 unsigned int tmpCsum;
 	 const void *vaddr;
 
-	 vaddr = compat_kmap(frag->page);
-	 tmpCsum = csum_and_copy_to_user(vaddr + frag->page_offset,
-					 curr, frag->size, 0, &err);
-	 compat_kunmap(frag->page);
+	 vaddr = compat_kmap_frag(frag);
+	 tmpCsum = csum_and_copy_to_user(vaddr + compat_skb_frag_off(frag),
+					 curr, compat_skb_frag_size(frag), 0,
+					 &err);
+	 compat_kunmap_frag(frag);
 
 	 if (err) {
 	    return err;
 	 }
 	 csum = csum_block_add(csum, tmpCsum, curr - buf);
-	 curr += frag->size;
+	 curr += compat_skb_frag_size(frag);
       }
    }
 
