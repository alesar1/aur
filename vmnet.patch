--- a/vmnet/Makefile
+++ b/vmnet/Makefile
@@ -43,7 +43,11 @@ INCLUDE      += -I$(SRCROOT)/shared
 endif
 
 
+ifdef KVERSION
+VM_UNAME = $(KVERSION)
+else
 VM_UNAME = $(shell uname -r)
+endif
 
 # Header directory for the running kernel
 ifdef LINUXINCLUDE
@@ -98,6 +102,13 @@ auto-build: $(DRIVER_KO)
 $(DRIVER): $(DRIVER_KO)
 	if [ $< -nt $@ ] || [ ! -e $@ ] ; then cp -f $< $@; fi
 
+# Use SUBDIRS on 2.x, 3.x, 4.x.  Use M on newer kernels.
+ifeq ($(filter-out 2 3 4,$(firstword $(subst ., ,$(VM_UNAME)))),)
+DIRVAR := SUBDIRS
+else
+DIRVAR := M
+endif
+
 #
 # Define a setup target that gets built before the actual driver.
 # This target may not be used at all, but if it is then it will be defined
@@ -107,7 +118,7 @@ prebuild:: ;
 postbuild:: ;
 
 $(DRIVER_KO): prebuild
-	$(MAKE) -C $(BUILD_DIR) SUBDIRS=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
+	$(MAKE) -C $(BUILD_DIR) $(DIRVAR)=$$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) modules
 	$(MAKE) -C $$PWD SRCROOT=$$PWD/$(SRCROOT) \
 	  MODULEBUILDDIR=$(MODULEBUILDDIR) postbuild
--- a/vmnet/procfs.c
+++ a/vmnet/procfs.c
@@ -137,6 +137,7 @@ VNetProcShow(struct seq_file *p, // IN:
 }
 
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 18, 0)
 /*
  *----------------------------------------------------------------------
  *
@@ -168,6 +169,7 @@ static struct file_operations fops = {
    .release = single_release,
 };
 #endif
+#endif
 
 
 /*
@@ -203,7 +205,12 @@ VNetProcMakeEntryInt(VNetProcEntry   *pa
       } else {
          ent->data   = data;
          ent->fn     = fn;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 18, 0)
+         ent->pde    = proc_create_single_data(name, mode, parent->pde,
+                                               VNetProcShow, ent);
+#else
          ent->pde    = proc_create_data(name, mode, parent->pde, &fops, ent);
+#endif
       }
       if (ent->pde != NULL) {
          *ret = ent;
--- a/vmnet/userif.c
+++ b/vmnet/userif.c
@@ -78,11 +78,11 @@ static int  VNetUserIfSetUplinkState(VNe
 extern unsigned int  vnet_max_qlen;
 
 #if COMPAT_LINUX_VERSION_CHECK_LT(3, 2, 0)
-#   define compat_kmap(page) kmap(page)
-#   define compat_kunmap(page) kunmap(page)
-#else
-#   define compat_kmap(page) kmap((page).p)
-#   define compat_kunmap(page) kunmap((page).p)
+#   define skb_frag_page(frag) (frag)->page
+#   define skb_frag_size(frag) (frag)->size
+#endif
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 4, 0)
+#   define skb_frag_off(frag) (frag)->page_offset
 #endif
 
 /*
@@ -137,16 +137,21 @@ UserifLockPage(VA addr) // IN
  */
 
 static INLINE int
-VNetUserIfMapPtr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapPtr(VA64 uAddr,      // IN: pointer to user memory
                  size_t size,     // IN: size of data
                  struct page **p, // OUT: locked page
                  void **ptr)      // OUT: kernel mapped pointer
 {
-   if (!access_ok(VERIFY_WRITE, (void *)uAddr, size) ||
-       (((uAddr + size - 1) & ~(PAGE_SIZE - 1)) !=
-        (uAddr & ~(PAGE_SIZE - 1)))) {
+   uint8 v;
+
+   /* Check area does not straddle two pages. */
+   if ((uAddr & (PAGE_SIZE - 1)) + size > PAGE_SIZE) {
       return -EINVAL;
    }
+   /* Check if it is user's area.  UserifLockPage() checks writability. */
+   if (copy_from_user(&v, (void *)(unsigned long)uAddr, sizeof v) != 0) {
+      return -EFAULT;
+   }
 
    *p = UserifLockPage(uAddr);
    if (*p == NULL) {
@@ -158,7 +163,7 @@ VNetUserIfMapPtr(VA uAddr,        // IN:
 }
 
 static INLINE int
-VNetUserIfMapUint32Ptr(VA uAddr,        // IN: pointer to user memory
+VNetUserIfMapUint32Ptr(VA64 uAddr,      // IN: pointer to user memory
                        struct page **p, // OUT: locked page
                        uint32 **ptr)    // OUT: kernel mapped pointer
 {
@@ -201,7 +206,7 @@ VNetUserIfSetupNotify(VNetUserIF *userIf
       return -EBUSY;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->pollPtr, &pollPage,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->pollPtr, &pollPage,
                                         &pollPtr)) < 0) {
       return retval;
    }
@@ -213,7 +218,7 @@ VNetUserIfSetupNotify(VNetUserIF *userIf
       goto error_free;
    }
 
-   if ((retval = VNetUserIfMapUint32Ptr((VA)vn->recvClusterPtr,
+   if ((retval = VNetUserIfMapUint32Ptr(vn->recvClusterPtr,
                                         &recvClusterPage,
                                         &recvClusterCount)) < 0) {
       goto error_free;
@@ -550,7 +555,12 @@ VNetCsumCopyDatagram(const struct sk_buf
       return -EINVAL;
    }
 
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
    csum = csum_and_copy_to_user(skb->data + offset, curr, len, 0, &err);
+#else
+   csum = csum_and_copy_to_user(skb->data + offset, curr, len);
+   err = (csum == 0) ? -EFAULT : 0;
+#endif
    if (err) {
       return err;
    }
@@ -559,20 +569,26 @@ VNetCsumCopyDatagram(const struct sk_buf
    for (frag = skb_shinfo(skb)->frags;
 	frag != skb_shinfo(skb)->frags + skb_shinfo(skb)->nr_frags;
 	frag++) {
-      if (frag->size > 0) {
+      if (skb_frag_size(frag) > 0) {
 	 unsigned int tmpCsum;
 	 const void *vaddr;
 
-	 vaddr = compat_kmap(frag->page);
-	 tmpCsum = csum_and_copy_to_user(vaddr + frag->page_offset,
-					 curr, frag->size, 0, &err);
-	 compat_kunmap(frag->page);
+	 vaddr = kmap(skb_frag_page(frag));
+#if COMPAT_LINUX_VERSION_CHECK_LT(5, 10, 0)
+	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
+					 curr, skb_frag_size(frag), 0, &err);
+#else
+	 tmpCsum = csum_and_copy_to_user(vaddr + skb_frag_off(frag),
+					 curr, skb_frag_size(frag));
+	 err = (tmpCsum == 0) ? -EFAULT : 0;
+#endif
+	 kunmap(skb_frag_page(frag));
 
 	 if (err) {
 	    return err;
 	 }
 	 csum = csum_block_add(csum, tmpCsum, curr - buf);
-	 curr += frag->size;
+	 curr += skb_frag_size(frag);
       }
    }
 
# Fixing VMWare Player on Linux when using DHCP addresses: https://www.nikhef.nl/~janjust/vmnet/
@@ -973,6 +989,9 @@
    userIf = (VNetUserIF *)port->jack.private;
    hubJack = port->jack.peer;
 
+   /* never send link down events */
+   if (!linkUp) return 0;
+
    if (port->jack.state == FALSE || hubJack == NULL) {
       return -EINVAL;
    }
From 409623bd4693afada659af82e823a6291f70797a Mon Sep 17 00:00:00 2001
From: Michal Kubecek <mkubecek@suse.cz>
Date: Mon, 4 Apr 2022 02:05:17 +0200
Subject: [PATCH] vmnet: use netif_rx() on newer kernels

In mainline 5.18-rc1, commit baebdf48c360 ("net: dev: Makes sure netif_rx()
can be invoked in any context.") allows calling netif_rx() from any context
and commit 2655926aea9b ("net: Remove netif_rx_any_context() and
netif_rx_ni().") drops netif_rx_ni() as it is no longer needed.

Replace calls of netif_rx_ni() in VNetBridgeReceiveFromVNet() and
VNetNetIfReceive() by netif_rx() when building against kernel 5.18 and
newer.
---
 vmnet-only/bridge.c           | 2 +-
 vmnet-only/compat_netdevice.h | 9 +++++++++
 vmnet-only/netif.c            | 2 +-
 3 files changed, 11 insertions(+), 2 deletions(-)

diff --git a/vmnet-only/bridge.c b/vmnet-only/bridge.c
index c84f8ee..d6bd3c4 100644
--- a/vmnet-only/bridge.c
+++ b/vmnet-only/bridge.c
@@ -691,7 +691,7 @@ VNetBridgeReceiveFromVNet(VNetJack        *this, // IN: jack
           * not do it, or netif_rx_ni() will deadlock on the cli() lock --hpreg
           */
 
-	 netif_rx_ni(clone);
+	 compat_netif_rx_ni(clone);
 #	 if LOGLEVEL >= 4
 	 do_gettimeofday(&vnetTime);
 #	 endif
diff --git a/vmnet-only/compat_netdevice.h b/vmnet-only/compat_netdevice.h
index bb5001b..c6cc706 100644
--- a/vmnet-only/compat_netdevice.h
+++ b/vmnet-only/compat_netdevice.h
@@ -343,4 +343,13 @@ typedef u32 compat_netdev_features_t;
 #define compat_netif_trans_update(d) do { (d)->trans_start = jiffies; } while (0)
 #endif
 
+static inline int compat_netif_rx_ni(struct sk_buff *skb)
+{
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5, 18, 0)
+	return netif_rx(skb);
+#else
+	return netif_rx_ni(skb);
+#endif
+}
+
 #endif /* __COMPAT_NETDEVICE_H__ */
diff --git a/vmnet-only/netif.c b/vmnet-only/netif.c
index 8c3bbf8..35256a0 100644
--- a/vmnet-only/netif.c
+++ b/vmnet-only/netif.c
@@ -311,7 +311,7 @@ VNetNetIfReceive(VNetJack        *this, // IN: jack
    /* send to the host interface */
    skb->dev = netIf->dev;
    skb->protocol = eth_type_trans(skb, netIf->dev);
-   netif_rx_ni(skb);
+   compat_netif_rx_ni(skb);
    netIf->stats.rx_packets++;
 
    return;
