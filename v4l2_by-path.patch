From 57cc18a73a05e00338f2ece4adb88ef3c3b87db8 Mon Sep 17 00:00:00 2001
From: Grzegorz Godlewski <gg@gitgis.com>
Date: Mon, 16 May 2022 18:29:16 +0200
Subject: [PATCH] linux-v4l2: Save device by id or path

---
 plugins/linux-v4l2/v4l2-input.c | 127 ++++++++++++++++++++++----------
 1 file changed, 90 insertions(+), 37 deletions(-)

diff --git a/plugins/linux-v4l2/v4l2-input.c b/plugins/linux-v4l2/v4l2-input.c
index e9d6f1712bbb..95387ff0c11d 100644
--- a/plugins/linux-v4l2/v4l2-input.c
+++ b/plugins/linux-v4l2/v4l2-input.c
@@ -341,32 +341,27 @@ static void v4l2_props_set_enabled(obs_properties_t *props,
 	}
 }
 
-/*
- * List available devices
- */
-static void v4l2_device_list(obs_property_t *prop, obs_data_t *settings)
+static void v4l2_device_list_directory(obs_property_t *prop,
+				       const char *basedir,
+				       bool allow_duplicates)
 {
 	DIR *dirp;
 	struct dirent *dp;
 	struct dstr device;
-	bool cur_device_found;
-	size_t cur_device_index;
-	const char *cur_device_name;
 
 #ifdef __FreeBSD__
-	dirp = opendir("/dev");
+	dirp = opendir(basedir);
 #else
-	dirp = opendir("/sys/class/video4linux");
+	if (0 == strcmp("/dev/", basedir)) {
+		dirp = opendir("/sys/class/video4linux");
+	} else {
+		dirp = opendir(basedir);
+	}
 #endif
 	if (!dirp)
 		return;
 
-	cur_device_found = false;
-	cur_device_name = obs_data_get_string(settings, "device_id");
-
-	obs_property_list_clear(prop);
-
-	dstr_init_copy(&device, "/dev/");
+	dstr_init(&device);
 
 	while ((dp = readdir(dirp)) != NULL) {
 		int fd;
@@ -381,20 +376,30 @@ static void v4l2_device_list(obs_property_t *prop, obs_data_t *settings)
 		if (dp->d_type == DT_DIR)
 			continue;
 
-		dstr_resize(&device, 5);
-		dstr_cat(&device, dp->d_name);
+		char *dev_path = dp->d_name;
+		char buf[1024];
+		ssize_t len;
+		if ((len = readlink(dp->d_name, buf, sizeof(buf) - 1)) != -1) {
+			buf[len] = '\0';
+			dev_path = &buf[0];
+		}
+		dstr_copy(&device, basedir);
+		dstr_cat(&device, dev_path);
 
 		if ((fd = v4l2_open(device.array, O_RDWR | O_NONBLOCK)) == -1) {
-			blog(LOG_INFO, "Unable to open %s", device.array);
+			const char *errstr = strerror(errno);
+			blog(LOG_WARNING, "Unable to open %s: %s", device.array,
+			     errstr);
 			continue;
 		}
 
 		if (v4l2_ioctl(fd, VIDIOC_QUERYCAP, &video_cap) == -1) {
-			blog(LOG_INFO, "Failed to query capabilities for %s",
+			blog(LOG_WARNING, "Failed to query capabilities for %s",
 			     device.array);
 			v4l2_close(fd);
 			continue;
 		}
+		v4l2_close(fd);
 
 #ifndef V4L2_CAP_DEVICE_CAPS
 		caps = video_cap.capabilities;
@@ -406,26 +411,77 @@ static void v4l2_device_list(obs_property_t *prop, obs_data_t *settings)
 #endif
 
 		if (!(caps & V4L2_CAP_VIDEO_CAPTURE)) {
-			blog(LOG_INFO, "%s seems to not support video capture",
+			blog(LOG_WARNING,
+			     "%s seems to not support video capture",
 			     device.array);
-			v4l2_close(fd);
 			continue;
 		}
 
-		/* make sure device names are unique */
-		char unique_device_name[68];
-		sprintf(unique_device_name, "%s (%s)", video_cap.card,
-			video_cap.bus_info);
-		obs_property_list_add_string(prop, unique_device_name,
-					     device.array);
-		blog(LOG_INFO, "Found device '%s' at %s", video_cap.card,
-		     device.array);
-
-		/* check if this is the currently used device */
-		if (cur_device_name && !strcmp(cur_device_name, device.array))
-			cur_device_found = true;
+		bool device_already_added = false;
+
+		if (!allow_duplicates) {
+			size_t listidx = 0;
+			const char *item_name;
+			while (NULL != (item_name = obs_property_list_item_name(
+						prop, listidx++))) {
+				if (NULL !=
+				    strstr(item_name, video_cap.bus_info)) {
+					device_already_added = true;
+					break;
+				}
+			}
+		}
 
-		v4l2_close(fd);
+		if (!device_already_added) {
+			char unique_device_name[68];
+			if (0 == strcmp("/dev/v4l/by-path/", basedir)) {
+				sprintf(unique_device_name, "%s (%s)",
+					video_cap.bus_info, video_cap.card);
+			} else {
+				sprintf(unique_device_name, "%s (%s)",
+					video_cap.card, video_cap.bus_info);
+			}
+			obs_property_list_add_string(prop, unique_device_name,
+						     device.array);
+			blog(LOG_INFO, "Found device '%s' at %s",
+			     video_cap.card, device.array);
+		}
+	}
+
+	closedir(dirp);
+	dstr_free(&device);
+}
+
+/*
+ * List available devices
+ */
+static void v4l2_device_list(obs_property_t *prop, obs_data_t *settings)
+{
+	bool cur_device_found;
+	size_t cur_device_index;
+	const char *cur_device_name;
+
+	obs_property_list_clear(prop);
+
+#ifdef __FreeBSD__
+	v4l2_device_list_directory(prop, "/dev/", false);
+#else
+	v4l2_device_list_directory(prop, "/dev/v4l/by-id/", true);
+	v4l2_device_list_directory(prop, "/dev/v4l/by-path/", true);
+	v4l2_device_list_directory(prop, "/dev/", false);
+#endif
+
+	cur_device_found = false;
+	cur_device_name = obs_data_get_string(settings, "device_id");
+
+	size_t listidx = 0;
+	const char *item_name;
+	while (NULL !=
+	       (item_name = obs_property_list_item_string(prop, listidx++))) {
+		if (0 == strcmp(item_name, cur_device_name)) {
+			cur_device_found = true;
+			break;
+		}
 	}
 
 	/* add currently selected device if not present, but disable it ... */
@@ -434,9 +490,6 @@ static void v4l2_device_list(obs_property_t *prop, obs_data_t *settings)
 			prop, cur_device_name, cur_device_name);
 		obs_property_list_item_disable(prop, cur_device_index, true);
 	}
-
-	closedir(dirp);
-	dstr_free(&device);
 }
 
 /*
