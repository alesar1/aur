diff --git a/src/drm.cpp b/src/drm.cpp
index 9f68bb1..23ec11e 100644
--- a/src/drm.cpp
+++ b/src/drm.cpp
@@ -41,6 +41,8 @@ bool g_bDebugLayers = false;
 const char *g_sOutputName = nullptr;
 
 enum drm_mode_generation g_drmModeGeneration = DRM_MODE_GENERATE_CVT;
+enum drm_mode_rotate g_drmModeOrientation = DRM_MODE_PANEL_ORIENTATION_AUTO;
+
 
 static LogScope drm_log("drm");
 static LogScope drm_verbose_log("drm", LOG_SILENT);
@@ -1081,7 +1083,7 @@ void drm_lock_fbid( struct drm_t *drm, uint32_t fbid )
 void drm_unlock_fbid( struct drm_t *drm, uint32_t fbid )
 {
 	struct fb &fb = get_fb( *drm, fbid );
-	
+
 	assert( fb.held_refs > 0 );
 	if ( --fb.held_refs != 0 )
 		return;
@@ -1122,7 +1124,26 @@ drm_prepare_basic( struct drm_t *drm, const struct FrameInfo_t *frameInfo )
 
 	drm->fbids_in_req.push_back( fb_id );
 
-	add_plane_property(req, drm->primary, "rotation", g_bRotated ? DRM_MODE_ROTATE_270 : DRM_MODE_ROTATE_0);
+	switch ( g_drmModeOrientation )
+	{
+	case DRM_MODE_PANEL_ORIENTATION_NORMAL:
+		add_plane_property(req, drm->primary, "rotation", DRM_MODE_ROTATE_0);
+	  break;
+	case DRM_MODE_PANEL_ORIENTATION_RIGHT:
+		add_plane_property(req, drm->primary, "rotation", DRM_MODE_ROTATE_270);
+	  break;
+	case DRM_MODE_PANEL_ORIENTATION_LEFT:
+		add_plane_property(req, drm->primary, "rotation", DRM_MODE_ROTATE_90);
+	  break;
+	case DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN:
+		add_plane_property(req, drm->primary, "rotation", DRM_MODE_ROTATE_180);
+	  break;
+	/* we are keeping the original method used for by default to prevent a sudden break in compatibility for devices using this method.*/
+	case DRM_MODE_PANEL_ORIENTATION_AUTO:
+	default:
+		add_plane_property(req, drm->primary, "rotation", g_bRotated ? DRM_MODE_ROTATE_270 : DRM_MODE_ROTATE_0);
+	  break;
+	}
 
 	add_plane_property(req, drm->primary, "FB_ID", fb_id);
 	add_plane_property(req, drm->primary, "CRTC_ID", drm->crtc->id);
@@ -1258,9 +1279,26 @@ drm_prepare_liftoff( struct drm_t *drm, const struct FrameInfo_t *frameInfo )
 				crtcW = crtcH;
 				crtcH = w;
 			}
-
-			liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", g_bRotated ? DRM_MODE_ROTATE_270 : DRM_MODE_ROTATE_0);
-
+      switch ( g_drmModeOrientation )
+      {
+     	case DRM_MODE_PANEL_ORIENTATION_NORMAL:
+        liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", DRM_MODE_ROTATE_0);
+     	  break;
+     	case DRM_MODE_PANEL_ORIENTATION_RIGHT:
+     	  liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", DRM_MODE_ROTATE_270);
+        break;
+     	case DRM_MODE_PANEL_ORIENTATION_LEFT:
+     	  liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", DRM_MODE_ROTATE_90);
+     	  break;
+     	case DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN:
+     	  liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", DRM_MODE_ROTATE_180);
+        break;
+     	case DRM_MODE_PANEL_ORIENTATION_AUTO:
+     	default: /* We are using auto to ensure compatibility with device		add_plane_property(req, drm->primary, "rotation", g_bRotated ? DRM_MODE_ROTATE_270 : DRM_MODE_ROTATE_0);
+     s that used this method*/
+        liftoff_layer_set_property( drm->lo_layers[ i ], "rotation", g_bRotated ? DRM_MODE_ROTATE_270 : DRM_MODE_ROTATE_0);
+     	  break;
+     	}
 			liftoff_layer_set_property( drm->lo_layers[ i ], "CRTC_X", crtcX);
 			liftoff_layer_set_property( drm->lo_layers[ i ], "CRTC_Y", crtcY);
 
@@ -1386,13 +1424,13 @@ int drm_prepare( struct drm_t *drm, const struct FrameInfo_t *frameInfo )
 		if ( drm->crtc->has_gamma_lut && drm->pending.gamma_lut_id != drm->current.gamma_lut_id )
 		{
 			if (add_crtc_property(drm->req, drm->crtc, "GAMMA_LUT", drm->pending.gamma_lut_id) < 0)
-				return false;	
+				return false;
 		}
 
 		if ( drm->crtc->has_degamma_lut && drm->pending.degamma_lut_id != drm->current.degamma_lut_id )
 		{
 			if (add_crtc_property(drm->req, drm->crtc, "DEGAMMA_LUT", drm->pending.degamma_lut_id) < 0)
-				return false;	
+				return false;
 		}
 
 		if ( drm->crtc->has_ctm && drm->pending.ctm_id != drm->current.ctm_id )
@@ -1670,7 +1708,7 @@ bool drm_update_color_mtx(struct drm_t *drm)
 		drm_ctm.matrix[i] = color.s31_32;
 	}
 
-	uint32_t blob_id = 0;	
+	uint32_t blob_id = 0;
 	if (drmModeCreatePropertyBlob(drm->fd, &drm_ctm,
 			sizeof(struct drm_color_ctm), &blob_id) != 0) {
 		drm_log.errorf_errno("Unable to create CTM property blob");
@@ -1745,7 +1783,7 @@ bool drm_update_gamma_lut(struct drm_t *drm)
 		gamma_lut[i].blue  = drm_calc_lut_value( b_exp, drm->pending.color_linear_gain[2], drm->pending.color_gain[2], drm->pending.gain_blend );
 	}
 
-	uint32_t blob_id = 0;	
+	uint32_t blob_id = 0;
 	if (drmModeCreatePropertyBlob(drm->fd, gamma_lut,
 			lut_entries * sizeof(struct drm_color_lut), &blob_id) != 0) {
 		drm_log.errorf_errno("Unable to create gamma LUT property blob");
@@ -1793,7 +1831,7 @@ bool drm_update_degamma_lut(struct drm_t *drm)
 		degamma_lut[i].blue  = drm_quantize_lut_value( safe_pow( input, drm->pending.color_degamma_exponent[2] ) );
 	}
 
-	uint32_t blob_id = 0;	
+	uint32_t blob_id = 0;
 	if (drmModeCreatePropertyBlob(drm->fd, degamma_lut,
 			lut_entries * sizeof(struct drm_color_lut), &blob_id) != 0) {
 		drm_log.errorf_errno("Unable to create degamma LUT property blob");
@@ -1919,7 +1957,7 @@ bool drm_set_refresh( struct drm_t *drm, int refresh )
 						edid_data_t edid_data = {};
 						parse_edid( &edid_data, (const unsigned char *)blob->data, blob->length );
 
-						is_steam_deck_display = 
+						is_steam_deck_display =
 							( edid_data.make == EDID_ID( 'W', 'L', 'C' ) && !strncmp( edid_data.model, "ANX7530 U", sizeof( edid_data.model ) ) ) ||
 							( edid_data.make == EDID_ID( 'A', 'N', 'X' ) && !strncmp( edid_data.model, "ANX7530 U", sizeof( edid_data.model ) ) ) ||
 							( edid_data.make == EDID_ID( 'V', 'L', 'V' ) && !strncmp( edid_data.model, "ANX7530 U", sizeof( edid_data.model ) ) ) ||
diff --git a/src/drm.hpp b/src/drm.hpp
index caef02b..dd27cc1 100644
--- a/src/drm.hpp
+++ b/src/drm.hpp
@@ -171,7 +171,16 @@ enum drm_mode_generation {
 	DRM_MODE_GENERATE_FIXED,
 };
 
+enum drm_mode_rotate {
+	DRM_MODE_PANEL_ORIENTATION_NORMAL,
+	DRM_MODE_PANEL_ORIENTATION_RIGHT,
+	DRM_MODE_PANEL_ORIENTATION_LEFT,
+	DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN,
+	DRM_MODE_PANEL_ORIENTATION_AUTO,
+};
+
 extern enum drm_mode_generation g_drmModeGeneration;
+extern enum drm_mode_rotate g_drmModeOrientation;
 
 bool init_drm(struct drm_t *drm, int width, int height, int refresh);
 void finish_drm(struct drm_t *drm);
diff --git a/src/main.cpp b/src/main.cpp
index 32104a7..f60d293 100644
--- a/src/main.cpp
+++ b/src/main.cpp
@@ -78,6 +78,7 @@ const struct option *gamescope_options = (struct option[]){
 	{ "composite-debug", no_argument, nullptr, 0 },
 	{ "disable-xres", no_argument, nullptr, 'x' },
 	{ "fade-out-duration", required_argument, nullptr, 0 },
+	{ "force-orientation", required_argument, nullptr, 0 },
 
 	{} // keep last
 };
@@ -106,6 +107,7 @@ const char usage[] =
 	"  -e, --steam                    enable Steam integration\n"
 	" --xwayland-count                create N xwayland servers\n"
 	" --prefer-vk-device              prefer Vulkan device for compositing (ex: 1002:7300)\n"
+	" --force-orientation             rotate the display (left, right, normal)\n"
 	"\n"
 	"Nested mode options:\n"
 	"  -o, --nested-unfocused-refresh game refresh rate when unfocused\n"
@@ -215,6 +217,22 @@ static enum drm_mode_generation parse_drm_mode_generation(const char *str)
 	}
 }
 
+static enum drm_mode_rotate force_orientation (const char *str)
+{
+	if (strcmp(str, "normal") == 0) {
+		return DRM_MODE_PANEL_ORIENTATION_NORMAL;
+	} else if (strcmp(str, "right") == 0) {
+		return DRM_MODE_PANEL_ORIENTATION_RIGHT;
+	} else if (strcmp(str, "left") == 0) {
+		return DRM_MODE_PANEL_ORIENTATION_LEFT;
+	} else if (strcmp(str, "upsidedown") == 0) {
+		return DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN;
+	} else {
+		fprintf( stderr, "gamescope: invalid value for --force-orientation\n" );
+		exit(1);
+	}
+}
+
 static void handle_signal( int sig )
 {
 	switch ( sig ) {
@@ -369,6 +387,8 @@ int main(int argc, char **argv)
 					g_nTouchClickMode = g_nDefaultTouchClickMode;
 				} else if (strcmp(opt_name, "generate-drm-mode") == 0) {
 					g_drmModeGeneration = parse_drm_mode_generation( optarg );
+				} else if (strcmp(opt_name, "force-orientation") == 0) {
+					g_drmModeOrientation = force_orientation( optarg );
 				} else if (strcmp(opt_name, "sharpness") == 0 ||
 						   strcmp(opt_name, "fsr-sharpness") == 0) {
 					g_upscalerSharpness = atoi( optarg );
@@ -529,7 +549,7 @@ int main(int argc, char **argv)
 		fprintf( stderr, "Failed to initialize wlserver\n" );
 		return 1;
 	}
-	
+
 	gamescope_xwayland_server_t *base_server = wlserver_get_xwayland_server(0);
 
 	setenv("DISPLAY", base_server->get_nested_display_name(), 1);
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index f5f3629..8d58a2f 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -64,6 +64,7 @@ struct wlserver_content_override {
 enum wlserver_touch_click_mode g_nDefaultTouchClickMode = WLSERVER_TOUCH_CLICK_LEFT;
 enum wlserver_touch_click_mode g_nTouchClickMode = g_nDefaultTouchClickMode;
 
+
 static struct wl_list pending_surfaces = {0};
 
 static void wlserver_surface_set_wlr( struct wlserver_surface *surf, struct wlr_surface *wlr_surf );
@@ -878,9 +879,71 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time )
 {
 	if ( wlserver.mouse_focus_surface != NULL )
 	{
-		double tx = g_bRotated ? y : x;
-		double ty = g_bRotated ? 1.0 - x : y;
+		double tx;
+		double ty;
+		switch ( g_drmModeOrientation )
+	{
+	case DRM_MODE_PANEL_ORIENTATION_RIGHT:
+
+		tx = g_bRotated ? y : x;
+		ty = g_bRotated ? 1.0 - x : y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
+
+	case DRM_MODE_PANEL_ORIENTATION_LEFT:
+
+		tx = g_bRotated ? 1.0 - y : x;
+		ty = g_bRotated ? x : y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
 
+	case DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN:
+
+		tx = 1.0 - x;
+		ty = 1.0 - y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+	break;
+
+	case DRM_MODE_PANEL_ORIENTATION_NORMAL:
+
+		tx = x;
+		ty = y;
+		
 		tx *= g_nOutputWidth;
 		ty *= g_nOutputHeight;
 
@@ -893,6 +956,29 @@ void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time )
 		wlserver.mouse_surface_cursorx = tx;
 		wlserver.mouse_surface_cursory = ty;
 
+	break;
+
+	default: /* we are using the "auto" enum case to ensure compatibility for devices that were already using this*/
+		case DRM_MODE_PANEL_ORIENTATION_AUTO:
+
+		tx = g_bRotated ? y : x;
+		ty = g_bRotated ? 1.0 - x : y;
+		
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
+	}
+
 		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
 		{
 			wlr_seat_touch_notify_motion( wlserver.wlr.seat, time, touch_id, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
@@ -917,8 +1003,73 @@ void wlserver_touchdown( double x, double y, int touch_id, uint32_t time )
 {
 	if ( wlserver.mouse_focus_surface != NULL )
 	{
-		double tx = g_bRotated ? y : x;
-		double ty = g_bRotated ? 1.0 - x : y;
+		double tx;
+		double ty;
+
+		switch ( g_drmModeOrientation )
+	{
+
+	case DRM_MODE_PANEL_ORIENTATION_NORMAL:
+
+		tx = g_bRotated ? y : x;
+		ty = g_bRotated ? x : y;
+	
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
+
+	case DRM_MODE_PANEL_ORIENTATION_RIGHT:
+
+		tx = g_bRotated ? y : x;
+		ty = g_bRotated ? 1.0 - x : y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
+
+	case DRM_MODE_PANEL_ORIENTATION_LEFT:
+
+		tx = g_bRotated ? 1.0 - y : x;
+		ty = g_bRotated ? x : y;
+		
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+	break;
+
+	case DRM_MODE_PANEL_ORIENTATION_UPSIDEDOWN:
+
+		tx =  1.0 - x;
+		ty =  1.0 - y;
 
 		tx *= g_nOutputWidth;
 		ty *= g_nOutputHeight;
@@ -931,6 +1082,29 @@ void wlserver_touchdown( double x, double y, int touch_id, uint32_t time )
 
 		wlserver.mouse_surface_cursorx = tx;
 		wlserver.mouse_surface_cursory = ty;
+	break;
+
+		default: /* we are using the "auto" enum case to ensure compatibility for devices that were already using this*/
+		case DRM_MODE_PANEL_ORIENTATION_AUTO:
+
+		tx = g_bRotated ? y : x;
+		ty = g_bRotated ? 1.0 - x : y;
+		
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+		
+	break;
+
+	}
 
 		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
 		{
