diff -Naupr ipt-netflow-2.3/compat.h ipt-netflow/compat.h
--- ipt-netflow-2.3/compat.h	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow/compat.h	2019-03-06 19:13:31.334760141 +0700
@@ -206,7 +206,9 @@ err:
 }
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+#define num_physpages	totalram_pages()
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
 #define num_physpages	totalram_pages
 #endif
 
@@ -670,4 +672,63 @@ int dev_get_alias(const struct net_devic
 }
 #endif
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,39) && !defined(RHEL_MAJOR)
+static inline int is_vlan_dev(struct net_device *dev)
+{
+	return dev->priv_flags & IFF_802_1Q_VLAN;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+static inline struct nf_bridge_info *
+nf_bridge_info_get(const struct sk_buff *skb)
+{
+	return skb->nf_bridge;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+static inline void do_gettimeofday(struct timeval *tv)
+{
+	struct timespec64 ts64;
+	ktime_get_real_ts64(&ts64);
+	tv->tv_sec = ts64.tv_sec;
+	tv->tv_usec = ts64.tv_nsec/1000;
+}
+#endif
+
+#define TOLOWER(x) ((x) | 0x20)
+unsigned long long strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0;
+
+	if (!base) {
+		if (cp[0] == '0') {
+			if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
+				base = 16;
+			else
+				base = 8;
+		} else {
+			base = 10;
+		}
+	}
+
+	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
+		cp += 2;
+
+	while (isxdigit(*cp)) {
+		unsigned int value;
+
+		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
+		if (value >= base)
+			break;
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
 #endif /* COMPAT_NETFLOW_H */
diff -Naupr ipt-netflow-2.3/configure ipt-netflow/configure
--- ipt-netflow-2.3/configure	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow/configure	2019-03-06 19:13:31.334760141 +0700
@@ -247,7 +247,11 @@ iptables_try_pkgconfig() {
     if [ -s /etc/debian_version ]; then
       echo "! "
       echo "! Under Debian simply run this:"
-      echo "!   root# apt-get install iptables-dev pkg-config"
+      if apt-cache policy libxtables-dev 2>&1 | fgrep -q "Candidate:"; then
+        echo "!   root# apt-get install libxtables-dev pkg-config"
+      else
+        echo "!   root# apt-get install iptables-dev pkg-config"
+      fi
     elif [ -s /etc/redhat-release ]; then
       echo "! "
       arch=.`uname -m`
diff -Naupr ipt-netflow-2.3/ipt_NETFLOW.c ipt-netflow/ipt_NETFLOW.c
--- ipt-netflow-2.3/ipt_NETFLOW.c	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow/ipt_NETFLOW.c	2019-03-06 19:13:31.334760141 +0700
@@ -50,6 +50,7 @@
 #include <net/addrconf.h>
 #include <net/dst.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_bridge.h>
 #ifndef ENABLE_NAT
 # undef CONFIG_NF_NAT_NEEDED
 #endif
@@ -75,9 +76,6 @@
 #include "compat.h"
 #include "ipt_NETFLOW.h"
 #include "murmur3.h"
-#ifdef CONFIG_BRIDGE_NETFILTER
-# include <linux/netfilter_bridge.h>
-#endif
 #ifdef CONFIG_SYSCTL
 # include <linux/sysctl.h>
 #endif
@@ -1947,7 +1945,7 @@ static struct socket *usock_open_sock(st
 		} else {
 			printk(KERN_ERR "ipt_NETFLOW: error binding to device %s, errno %d\n",
 			    usock->sdev, -error);
-			return NULL;
+			goto err_free_sock;
 		}
 	}
 	if (!is_zero_addr(&usock->saddr)) {
@@ -1957,7 +1955,7 @@ static struct socket *usock_open_sock(st
 			salen = sizeof(struct sockaddr_in6);
 		if ((error = sock->ops->bind(sock, (struct sockaddr *)&usock->saddr, salen)) < 0) {
 			printk(KERN_ERR "ipt_NETFLOW: error binding socket %d\n", -error);
-			return NULL;
+			goto err_free_sock;
 		}
 	}
 
@@ -1970,10 +1968,12 @@ static struct socket *usock_open_sock(st
 		printk(KERN_ERR "ipt_NETFLOW: error connecting UDP socket %d,"
 		    " don't worry, will try reconnect later.\n", -error);
 		/* ENETUNREACH when no interfaces */
-		sock_release(sock);
-		return NULL;
+		goto err_free_sock;
 	}
 	return sock;
+err_free_sock:
+	sock_release(sock);
+	return NULL;
 }
 
 static void usock_connect(struct ipt_netflow_sock *usock, const int sendmsg)
@@ -2339,7 +2339,7 @@ static int add_destinations(const char *
 				++end;
 			if (succ &&
 			    (*end == ':' || *end == '.' || *end == 'p' || *end == '#'))
-				sin6->sin6_port = htons(simple_strtoul(++end, (char **)&end, 0));
+				sin6->sin6_port = htons(strtoul(++end, (char **)&end, 0));
 			if (succ && *end == '@') {
 				++end;
 				sout->sin6_family = AF_INET6;
@@ -2354,7 +2354,7 @@ static int add_destinations(const char *
 			sin->sin_port = htons(2055);
 			succ = in4_pton(ptr, len, (u8 *)&sin->sin_addr, -1, &end);
 			if (succ && *end == ':')
-				sin->sin_port = htons(simple_strtoul(++end, (char **)&end, 0));
+				sin->sin_port = htons(strtoul(++end, (char **)&end, 0));
 			if (succ && *end == '@') {
 				++end;
 				sout->sin_family = AF_INET;
@@ -4805,6 +4805,23 @@ static void parse_l2_header(const struct
 	/* get vlan tag that is saved in skb->vlan_tci */
 	if (vlan_tx_tag_present(skb))
 		tuple->tag[tag_num++] = htons(vlan_tx_tag_get(skb));
+	else if (skb->dev && is_vlan_dev(skb->dev)) {
+		struct net_device *vlan_dev = skb->dev;
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+		struct vlan_dev_priv *vlan = vlan_dev_priv(vlan_dev);
+
+		/* `if` condition is `#if`ed intentionally, and this is
+		 * just inversion of conditional from vlan_do_receive */
+		if (!(vlan
+		    && !(vlan->flags & VLAN_FLAG_REORDER_HDR)
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
+		    && !netif_is_macvlan_port(vlan_dev)
+		    && !netif_is_bridge_port(vlan_dev)
+#  endif
+		   ))
+# endif
+			tuple->tag[tag_num++] = htons(vlan_dev_vlan_id(vlan_dev));
+	}
 # endif
 	if (mac_header < skb->head ||
 	    mac_header + ETH_HLEN > skb->data)
@@ -4934,8 +4951,8 @@ static unsigned int netflow_target(
 	memset(&tuple, 0, sizeof(tuple));
 	tuple.l3proto = family;
 #ifdef ENABLE_PHYSDEV_OVER
-	if (skb->nf_bridge && skb->nf_bridge->physindev)
-		tuple.i_ifc = skb->nf_bridge->physindev->ifindex;
+	if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physindev)
+		tuple.i_ifc = nf_bridge_info_get(skb)->physindev->ifindex;
 	else /* FALLTHROUGH */
 #endif
 	tuple.i_ifc	= if_in? if_in->ifindex : -1;
@@ -5199,8 +5216,8 @@ do_protocols:
 		nf->tcp_flags = tcp_flags;
 		nf->o_ifc = if_out? if_out->ifindex : -1;
 #ifdef ENABLE_PHYSDEV_OVER
-		if (skb->nf_bridge && skb->nf_bridge->physoutdev)
-			nf->o_ifc = skb->nf_bridge->physoutdev->ifindex;
+		if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physoutdev)
+			nf->o_ifc = nf_bridge_info_get(skb)->physoutdev->ifindex;
 #endif
 
 #ifdef SNMP_RULES
@@ -5210,8 +5227,8 @@ do_protocols:
 #endif
 /* copy and snmp-resolve device with physdev overriding normal dev */
 #define copy_dev(out, physdev, dev) \
-		if (skb->nf_bridge && skb->nf_bridge->physdev) \
-			out = resolve_snmp(skb->nf_bridge->physdev); \
+		if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physdev) \
+			out = resolve_snmp(nf_bridge_info_get(skb)->physdev); \
 		else \
 			out = resolve_snmp(dev);
 #ifdef ENABLE_PHYSDEV
diff -Naupr ipt-netflow-2.3/README ipt-netflow/README
--- ipt-netflow-2.3/README	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow/README	2019-03-06 19:13:31.334760141 +0700
@@ -1,8 +1,8 @@
 ipt_NETFLOW linux 2.6.x-4.x kernel module by <abc@openwall.com> -- 2008-2018.
 
    High performance NetFlow v5, v9, IPFIX flow data export module for Linux
-   kernel. Created to be useful for highly loaded linux router. It should be
-   used as iptables target.
+   kernel. Created to be useful for linux routers in high-throughput networks.
+   It should be used as iptables target.
 
 
 =========================
@@ -111,7 +111,8 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
    Before this step it also would be useful to install pkg-config if don't
    already have.
 
-   If you have package system just install iptables-devel (or iptables-dev)
+   If you have package system just install iptables-devel (or on Debian, Ubuntu
+   and derivatives libxtables-dev if available, otherwise iptables-dev)
    package, otherwise install iptables source matching version of your
    installation from ftp://ftp.netfilter.org/pub/iptables/
 
