diff -Naupr ipt-netflow_orig/compat.h ipt-netflow_git/compat.h
--- ipt-netflow_orig/compat.h	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/compat.h	2019-06-01 12:33:22.887853266 +0700
@@ -206,7 +206,9 @@ err:
 }
 #endif
 
-#if LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+#define num_physpages	totalram_pages()
+#elif LINUX_VERSION_CODE >= KERNEL_VERSION(3,11,0)
 #define num_physpages	totalram_pages
 #endif
 
@@ -670,4 +672,63 @@ int dev_get_alias(const struct net_devic
 }
 #endif
 
+#if LINUX_VERSION_CODE <= KERNEL_VERSION(2,6,39) && !defined(RHEL_MAJOR)
+static inline int is_vlan_dev(struct net_device *dev)
+{
+	return dev->priv_flags & IFF_802_1Q_VLAN;
+}
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,0,0)
+static inline struct nf_bridge_info *
+nf_bridge_info_get(const struct sk_buff *skb)
+{
+	return skb->nf_bridge;
+}
+#endif
+
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(5,0,0)
+static inline void do_gettimeofday(struct timeval *tv)
+{
+	struct timespec64 ts64;
+	ktime_get_real_ts64(&ts64);
+	tv->tv_sec = ts64.tv_sec;
+	tv->tv_usec = ts64.tv_nsec/1000;
+}
+#endif
+
+#define TOLOWER(x) ((x) | 0x20)
+unsigned long long strtoul(const char *cp, char **endp, unsigned int base)
+{
+	unsigned long long result = 0;
+
+	if (!base) {
+		if (cp[0] == '0') {
+			if (TOLOWER(cp[1]) == 'x' && isxdigit(cp[2]))
+				base = 16;
+			else
+				base = 8;
+		} else {
+			base = 10;
+		}
+	}
+
+	if (base == 16 && cp[0] == '0' && TOLOWER(cp[1]) == 'x')
+		cp += 2;
+
+	while (isxdigit(*cp)) {
+		unsigned int value;
+
+		value = isdigit(*cp) ? *cp - '0' : TOLOWER(*cp) - 'a' + 10;
+		if (value >= base)
+			break;
+		result = result * base + value;
+		cp++;
+	}
+	if (endp)
+		*endp = (char *)cp;
+
+	return result;
+}
+
 #endif /* COMPAT_NETFLOW_H */
diff -Naupr ipt-netflow_orig/configure ipt-netflow_git/configure
--- ipt-netflow_orig/configure	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/configure	2019-06-01 12:33:22.887853266 +0700
@@ -247,7 +247,11 @@ iptables_try_pkgconfig() {
     if [ -s /etc/debian_version ]; then
       echo "! "
       echo "! Under Debian simply run this:"
-      echo "!   root# apt-get install iptables-dev pkg-config"
+      if apt-cache policy libxtables-dev 2>&1 | fgrep -q "Candidate:"; then
+        echo "!   root# apt-get install libxtables-dev pkg-config"
+      else
+        echo "!   root# apt-get install iptables-dev pkg-config"
+      fi
     elif [ -s /etc/redhat-release ]; then
       echo "! "
       arch=.`uname -m`
diff -Naupr ipt-netflow_orig/CREDITS ipt-netflow_git/CREDITS
--- ipt-netflow_orig/CREDITS	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/CREDITS	2019-06-01 12:33:22.884519926 +0700
@@ -45,7 +45,7 @@ Sign-off rule is that of the Linux kerne
 
 Principal author and project maintainer:
 
-   ABC <abc@openwall.com> [2008-2018]
+   ABC <abc@openwall.com> [2008-2019]
 
 
 Compatibility layer is using code from Linux Kernel and should be
@@ -61,6 +61,7 @@ Patch authors and submitters:
    Eric W. Biederman [2010]
    Giedrius Liubaviƒçius [2010]
    Igor Alov [2010]
+   Valentin V. Yankin [2011] prototype for SNMP-index
    Alexey Osipov [2011]
    Pavel Boldin [2012]
    Alexander Demenshin [2013]
@@ -69,11 +70,9 @@ Patch authors and submitters:
    Jeremy Drake [2013]
    Matthew Martin [2016] DKMS fixes
    alex-eri [2016, 2017] OpenWRT compatibility
-
-
-Reference or prototype code authors:
-
-   Valentin V. Yankin [2011] SNMP-index
+   xtaran [2018]
+   Thadeu Lima de Souza Cascardo @ Canonical [2019]
+   dbugnar [2019]
 
 
 Project supporters:
diff -Naupr ipt-netflow_orig/ipt_NETFLOW.c ipt-netflow_git/ipt_NETFLOW.c
--- ipt-netflow_orig/ipt_NETFLOW.c	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/ipt_NETFLOW.c	2019-06-01 12:33:22.891186609 +0700
@@ -1,6 +1,6 @@
 /*
  * This is NetFlow exporting module (NETFLOW target) for linux
- * (c) 2008-2018 <abc@openwall.com>
+ * (c) 2008-2019 <abc@openwall.com>
  *
  *
  *   This program is free software: you can redistribute it and/or modify
@@ -50,6 +50,7 @@
 #include <net/addrconf.h>
 #include <net/dst.h>
 #include <linux/netfilter_ipv4/ip_tables.h>
+#include <linux/netfilter_bridge.h>
 #ifndef ENABLE_NAT
 # undef CONFIG_NF_NAT_NEEDED
 #endif
@@ -75,9 +76,6 @@
 #include "compat.h"
 #include "ipt_NETFLOW.h"
 #include "murmur3.h"
-#ifdef CONFIG_BRIDGE_NETFILTER
-# include <linux/netfilter_bridge.h>
-#endif
 #ifdef CONFIG_SYSCTL
 # include <linux/sysctl.h>
 #endif
@@ -86,7 +84,7 @@
 # undef CONFIG_NF_NAT_NEEDED
 #endif
 
-#define IPT_NETFLOW_VERSION "2.2"   /* Note that if you are using git, you
+#define IPT_NETFLOW_VERSION "2.3"   /* Note that if you are using git, you
 				       will see version in other format. */
 #include "version.h"
 #ifdef GITVERSION
@@ -95,7 +93,7 @@
 #endif
 
 MODULE_LICENSE("GPL");
-MODULE_AUTHOR("<abc@telekom.ru>");
+MODULE_AUTHOR("<abc@openwall.com>");
 MODULE_DESCRIPTION("iptables NETFLOW target module");
 MODULE_VERSION(IPT_NETFLOW_VERSION);
 MODULE_ALIAS("ip6t_NETFLOW");
@@ -1942,12 +1940,20 @@ static struct socket *usock_open_sock(st
 		struct net_device *dev = dev_get_by_name(&init_net, usock->sdev);
 
 		if (dev) {
-			sock->sk->sk_bound_dev_if = dev->ifindex;
+			struct sock *sk = sock->sk;
+
+			/* SO_BINDTOIFINDEX */
+			sk->sk_bound_dev_if = dev->ifindex;
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,36)
+			if (sk->sk_prot->rehash)
+				sk->sk_prot->rehash(sk);
+#endif
+			sk_dst_reset(sk);
 			dev_put(dev);
 		} else {
 			printk(KERN_ERR "ipt_NETFLOW: error binding to device %s, errno %d\n",
 			    usock->sdev, -error);
-			return NULL;
+			goto err_free_sock;
 		}
 	}
 	if (!is_zero_addr(&usock->saddr)) {
@@ -1957,7 +1963,7 @@ static struct socket *usock_open_sock(st
 			salen = sizeof(struct sockaddr_in6);
 		if ((error = sock->ops->bind(sock, (struct sockaddr *)&usock->saddr, salen)) < 0) {
 			printk(KERN_ERR "ipt_NETFLOW: error binding socket %d\n", -error);
-			return NULL;
+			goto err_free_sock;
 		}
 	}
 
@@ -1970,10 +1976,12 @@ static struct socket *usock_open_sock(st
 		printk(KERN_ERR "ipt_NETFLOW: error connecting UDP socket %d,"
 		    " don't worry, will try reconnect later.\n", -error);
 		/* ENETUNREACH when no interfaces */
-		sock_release(sock);
-		return NULL;
+		goto err_free_sock;
 	}
 	return sock;
+err_free_sock:
+	sock_release(sock);
+	return NULL;
 }
 
 static void usock_connect(struct ipt_netflow_sock *usock, const int sendmsg)
@@ -2339,7 +2347,7 @@ static int add_destinations(const char *
 				++end;
 			if (succ &&
 			    (*end == ':' || *end == '.' || *end == 'p' || *end == '#'))
-				sin6->sin6_port = htons(simple_strtoul(++end, (char **)&end, 0));
+				sin6->sin6_port = htons(strtoul(++end, (char **)&end, 0));
 			if (succ && *end == '@') {
 				++end;
 				sout->sin6_family = AF_INET6;
@@ -2354,7 +2362,7 @@ static int add_destinations(const char *
 			sin->sin_port = htons(2055);
 			succ = in4_pton(ptr, len, (u8 *)&sin->sin_addr, -1, &end);
 			if (succ && *end == ':')
-				sin->sin_port = htons(simple_strtoul(++end, (char **)&end, 0));
+				sin->sin_port = htons(strtoul(++end, (char **)&end, 0));
 			if (succ && *end == '@') {
 				++end;
 				sout->sin_family = AF_INET;
@@ -4805,6 +4813,23 @@ static void parse_l2_header(const struct
 	/* get vlan tag that is saved in skb->vlan_tci */
 	if (vlan_tx_tag_present(skb))
 		tuple->tag[tag_num++] = htons(vlan_tx_tag_get(skb));
+	else if (skb->dev && is_vlan_dev(skb->dev)) {
+		struct net_device *vlan_dev = skb->dev;
+# if LINUX_VERSION_CODE >= KERNEL_VERSION(3,2,0)
+		struct vlan_dev_priv *vlan = vlan_dev_priv(vlan_dev);
+
+		/* `if` condition is `#if`ed intentionally, and this is
+		 * just inversion of conditional from vlan_do_receive */
+		if (!(vlan
+		    && !(vlan->flags & VLAN_FLAG_REORDER_HDR)
+#  if LINUX_VERSION_CODE >= KERNEL_VERSION(4,3,0)
+		    && !netif_is_macvlan_port(vlan_dev)
+		    && !netif_is_bridge_port(vlan_dev)
+#  endif
+		   ))
+# endif
+			tuple->tag[tag_num++] = htons(vlan_dev_vlan_id(vlan_dev));
+	}
 # endif
 	if (mac_header < skb->head ||
 	    mac_header + ETH_HLEN > skb->data)
@@ -4934,8 +4959,8 @@ static unsigned int netflow_target(
 	memset(&tuple, 0, sizeof(tuple));
 	tuple.l3proto = family;
 #ifdef ENABLE_PHYSDEV_OVER
-	if (skb->nf_bridge && skb->nf_bridge->physindev)
-		tuple.i_ifc = skb->nf_bridge->physindev->ifindex;
+	if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physindev)
+		tuple.i_ifc = nf_bridge_info_get(skb)->physindev->ifindex;
 	else /* FALLTHROUGH */
 #endif
 	tuple.i_ifc	= if_in? if_in->ifindex : -1;
@@ -5199,8 +5224,8 @@ do_protocols:
 		nf->tcp_flags = tcp_flags;
 		nf->o_ifc = if_out? if_out->ifindex : -1;
 #ifdef ENABLE_PHYSDEV_OVER
-		if (skb->nf_bridge && skb->nf_bridge->physoutdev)
-			nf->o_ifc = skb->nf_bridge->physoutdev->ifindex;
+		if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physoutdev)
+			nf->o_ifc = nf_bridge_info_get(skb)->physoutdev->ifindex;
 #endif
 
 #ifdef SNMP_RULES
@@ -5210,8 +5235,8 @@ do_protocols:
 #endif
 /* copy and snmp-resolve device with physdev overriding normal dev */
 #define copy_dev(out, physdev, dev) \
-		if (skb->nf_bridge && skb->nf_bridge->physdev) \
-			out = resolve_snmp(skb->nf_bridge->physdev); \
+		if (nf_bridge_info_get(skb) && nf_bridge_info_get(skb)->physdev) \
+			out = resolve_snmp(nf_bridge_info_get(skb)->physdev); \
 		else \
 			out = resolve_snmp(dev);
 #ifdef ENABLE_PHYSDEV
@@ -5698,7 +5723,11 @@ static void __exit ipt_netflow_fini(void
 	netflow_scan_and_export(AND_FLUSH);
 	del_timer_sync(&rate_timer);
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(5,1,0)
 	synchronize_sched();
+#else
+	synchronize_rcu();
+#endif
 
 	free_templates();
 	destination_removeall();
diff -Naupr ipt-netflow_orig/openwrt/Makefile ipt-netflow_git/openwrt/Makefile
--- ipt-netflow_orig/openwrt/Makefile	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/openwrt/Makefile	2019-06-01 12:33:22.891186609 +0700
@@ -5,7 +5,7 @@ PKG_NAME:=ipt-netflow
 PKG_RELEASE:=2
 
 PKG_SOURCE_URL:=https://github.com/aabc/$(PKG_NAME).git
-PKG_VERSION:=2.2
+PKG_VERSION:=2.3
 PKG_SOURCE_VERSION:=v$(PKG_VERSION)
 
 #TO BUILD development version uncomment 2 rows below and remove patches
diff -Naupr ipt-netflow_orig/README ipt-netflow_git/README
--- ipt-netflow_orig/README	2018-03-19 22:27:26.000000000 +0700
+++ ipt-netflow_git/README	2019-06-01 12:33:22.887853266 +0700
@@ -1,8 +1,8 @@
-ipt_NETFLOW linux 2.6.x-4.x kernel module by <abc@openwall.com> -- 2008-2018.
+ipt_NETFLOW linux 2.6.x-5.x kernel module by <abc@openwall.com> -- 2008-2019.
 
    High performance NetFlow v5, v9, IPFIX flow data export module for Linux
-   kernel. Created to be useful for highly loaded linux router. It should be
-   used as iptables target.
+   kernel. Created to be useful for linux routers in high-throughput networks.
+   It should be used as iptables target.
 
 
 =========================
@@ -39,7 +39,7 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
      Such as metering, exporting, sampling stat and reliability stat, sampling 
      configuration, network devices ifName, ifDescr list.
 
-   * Tested to compile and work out of the box on Centos 5, 6, 7, Debian and
+   * Tested to compile and work out of the box on Centos 6, 7, Debian and
    * Ubuntu. Many vanilla Linux kernels since 2.6.18 up to the latest (as of
    * writing is 3.19) are supported and tested.
 
@@ -111,7 +111,8 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
    Before this step it also would be useful to install pkg-config if don't
    already have.
 
-   If you have package system just install iptables-devel (or iptables-dev)
+   If you have package system just install iptables-devel (or on Debian, Ubuntu
+   and derivatives libxtables-dev if available, otherwise iptables-dev)
    package, otherwise install iptables source matching version of your
    installation from ftp://ftp.netfilter.org/pub/iptables/
 
