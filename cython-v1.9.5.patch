diff -ura src/GPy-1.9.5/GPy/models/state_space_cython.pyx src/GPy-1.9.5/GPy/models/state_space_cython.pyx
--- src/GPy-1.9.5/GPy/models/state_space_cython.pyx	2018-09-02 23:50:17.000000000 +0200
+++ src/GPy-1.9.5/GPy/models/state_space_cython.pyx	2018-09-16 16:16:08.000000000 +0200
@@ -484,7 +484,7 @@
             if matrix_index in self.Q_square_root_dict:
                 square_root = self.Q_square_root_dict[matrix_index]
             else:
-                if matrix_index not in self.Q_svd_dict
+                if matrix_index not in self.Q_svd_dict:
                     U,S,Vh = sp.linalg.svd( self.Qs[:,:, matrix_index], 
                                         full_matrices=False, compute_uv=True, 
                                         overwrite_a=False, check_finite=False)
@@ -514,7 +514,7 @@
             if matrix_index in self.Q_inverse_dict:
                 Q_inverse = self.Q_inverse_dict[matrix_index]
             else:
-                if matrix_index not in self.Q_svd_dict
+                if matrix_index not in self.Q_svd_dict:
                     U,S,Vh = sp.linalg.svd( self.Qs[:,:, matrix_index], 
                                         full_matrices=False, compute_uv=True, 
                                         overwrite_a=False, check_finite=False)
@@ -522,7 +522,7 @@
                 else:
                     U,S,Vh = self.Q_svd_dict[matrix_index]
                        
-               Q_inverse = Q_inverse = np.dot( Vh.T * ( 1.0/(S + jitter)) , U.T )
+                Q_inverse = Q_inverse = np.dot( Vh.T * ( 1.0/(S + jitter)) , U.T )
                 self.Q_inverse_dict[matrix_index] = Q_inverse
             
             return Q_inverse
@@ -998,4 +998,4 @@
         M[k+1,:,:] = m_upd # separate mean value for each time series
         P[k+1,:,:] = P_upd[0]
         
-    return (M, P, log_likelihood, grad_log_likelihood, p_dynamic_callables.reset(False))
\ No newline at end of file
+    return (M, P, log_likelihood, grad_log_likelihood, p_dynamic_callables.reset(False))
