diff --git a/include/ClientDB.py b/include/ClientDB.py
index 5b1b712..2fa1732 100755
--- a/include/ClientDB.py
+++ b/include/ClientDB.py
@@ -2491,7 +2491,7 @@ class DB( HydrusDB.HydrusDB ):
                 counts_iterable = self._c.execute( nonzero_counts_query )
                 
             
-            query_hash_ids = { id for ( id, count ) in counts_iterable if False not in ( pred( count ) for pred in tag_predicates ) }
+            query_hash_ids = { id for ( id, count ) in counts_iterable if False not in (lambda count:( pred( count ) for pred in tag_predicates ))(count) }
             
         
         #
@@ -6100,4 +6100,4 @@ class DB( HydrusDB.HydrusDB ):
         shutil.copytree( path + os.path.sep + 'client_thumbnails', HC.CLIENT_THUMBNAILS_DIR )
         shutil.copytree( path + os.path.sep + 'client_updates', HC.CLIENT_UPDATES_DIR )
         
-    
\ No newline at end of file
+    
diff --git a/include/ClientGUICanvas.py b/include/ClientGUICanvas.py
index 5882175..9d623ac 100755
--- a/include/ClientGUICanvas.py
+++ b/include/ClientGUICanvas.py
@@ -48,7 +48,8 @@ NON_ZOOMABLE_MIMES = list( HC.AUDIO ) + [ HC.APPLICATION_PDF ]
 
 EMBED_BUTTON_MIMES = [ HC.VIDEO_FLV, HC.APPLICATION_FLASH ]
 
-def CalculateCanvasZoom( media, ( canvas_width, canvas_height ) ):
+def CalculateCanvasZoom( media, canvas_dims ):
+    ( canvas_width, canvas_height ) = canvas_dims
     
     ( media_width, media_height ) = media.GetResolution()
     
diff --git a/include/ClientGUIDialogs.py b/include/ClientGUIDialogs.py
index 19ed8e3..398fc7d 100755
--- a/include/ClientGUIDialogs.py
+++ b/include/ClientGUIDialogs.py
@@ -243,7 +243,8 @@ class Dialog( wx.Dialog ):
     
     def EventDialogButton( self, event ): self.EndModal( event.GetId() )
     
-    def SetInitialSize( self, ( width, height ) ):
+    def SetInitialSize( self, dims ):
+        ( width, height ) = dims
         
         wx.Dialog.SetInitialSize( self, ( width, height ) )
         
diff --git a/include/ClientGUIManagement.py b/include/ClientGUIManagement.py
index 71b5491..0b4cf7c 100755
--- a/include/ClientGUIManagement.py
+++ b/include/ClientGUIManagement.py
@@ -63,26 +63,6 @@ def CreateManagementController( management_type, file_service_key = None ):
     
     return management_controller
     
-def CreateManagementControllerDumper( imageboard, media_results ):
-    
-    # this stuff doesn't work yet because media_results and imageboard are still yaml things
-    
-    management_controller = CreateManagementController( MANAGEMENT_TYPE_DUMPER )
-    
-    management_controller.SetVariable( 'imageboard', imageboard )
-    management_controller.SetVariable( 'media_results', media_results )
-    
-    self._current_hash = None
-    
-    self._dumping = False
-    self._actually_dumping = False
-    self._num_dumped = 0
-    self._next_dump_index = 0
-    self._next_dump_time = 0
-    
-    self._file_post_name = 'upfile'
-    
-    return management_controller
     
 def CreateManagementControllerImportGallery( site_type, gallery_type ):
     
@@ -659,734 +639,6 @@ class ManagementPanel( wx.lib.scrolledpanel.ScrolledPanel ):
     
     def TestAbleToClose( self ): pass
     
-class ManagementPanelDumper( ManagementPanel ):
-    
-    def __init__( self, parent, page, management_controller ):
-        
-        ManagementPanel.__init__( self, parent, page, management_controller )
-        
-        ( self._4chan_token, pin, timeout ) = wx.GetApp().Read( '4chan_pass' )
-        
-        self._have_4chan_pass = timeout > HydrusData.GetNow()
-        
-        self._timer = wx.Timer( self, ID_TIMER_DUMP )
-        self.Bind( wx.EVT_TIMER, self.TIMEREvent, id = ID_TIMER_DUMP )
-        
-        ( self._post_url, self._flood_time, self._form_fields, self._restrictions ) = self._imageboard.GetBoardInfo()
-        
-        # progress
-        
-        self._import_queue_panel = ClientGUICommon.StaticBox( self, 'import queue' )
-        
-        self._progress_info = wx.StaticText( self._import_queue_panel )
-        
-        self._progress_gauge = ClientGUICommon.Gauge( self._import_queue_panel )
-        self._progress_gauge.SetRange( len( media_results ) )
-        
-        self._start_button = wx.Button( self._import_queue_panel, label = 'start' )
-        self._start_button.Bind( wx.EVT_BUTTON, self.EventStartButton )
-        
-        self._import_queue_panel.AddF( self._progress_info, CC.FLAGS_EXPAND_PERPENDICULAR )
-        self._import_queue_panel.AddF( self._progress_gauge, CC.FLAGS_EXPAND_PERPENDICULAR )
-        self._import_queue_panel.AddF( self._start_button, CC.FLAGS_EXPAND_PERPENDICULAR )
-        
-        # thread options
-        
-        self._thread_panel = ClientGUICommon.StaticBox( self, 'thread options' )
-        
-        self._thread_fields = {}
-        
-        gridbox = wx.FlexGridSizer( 0, 2 )
-        
-        gridbox.AddGrowableCol( 1, 1 )
-        
-        for ( name, field_type, default, editable ) in self._form_fields:
-            
-            if field_type in ( CC.FIELD_TEXT, CC.FIELD_THREAD_ID ): field = wx.TextCtrl( self._thread_panel, value = default )
-            elif field_type == CC.FIELD_PASSWORD: field = wx.TextCtrl( self._thread_panel, value = default, style = wx.TE_PASSWORD )
-            else: continue
-            
-            self._thread_fields[ name ] = ( field_type, field )
-            
-            if editable:
-                
-                gridbox.AddF( wx.StaticText( self._thread_panel, label = name + ':' ), CC.FLAGS_MIXED )
-                gridbox.AddF( field, CC.FLAGS_EXPAND_BOTH_WAYS )
-                
-            else: field.Hide()
-            
-        
-        self._thread_panel.AddF( gridbox, CC.FLAGS_EXPAND_SIZER_PERPENDICULAR )
-        
-        # post options
-        
-        self._post_panel = ClientGUICommon.StaticBox( self, 'post options' )
-        
-        self._post_fields = {}
-        
-        postbox = wx.BoxSizer( wx.VERTICAL )
-        
-        self._post_info = wx.StaticText( self._post_panel, label = 'no file selected', style = wx.ALIGN_CENTER | wx.ST_NO_AUTORESIZE )
-        
-        for ( name, field_type, default, editable ) in self._form_fields:
-            
-            if field_type == CC.FIELD_VERIFICATION_RECAPTCHA:
-                
-                if self._have_4chan_pass: continue
-                
-                field = CaptchaControl( self._post_panel, field_type, default )
-                field.Bind( CAPTCHA_FETCH_EVENT, self.EventCaptchaRefresh )
-                
-            elif field_type == CC.FIELD_COMMENT: field = Comment( self._post_panel )
-            else: continue
-            
-            self._post_fields[ name ] = ( field_type, field, default )
-            
-            postbox.AddF( field, CC.FLAGS_EXPAND_PERPENDICULAR )
-            
-        
-        gridbox = wx.FlexGridSizer( 0, 2 )
-        
-        gridbox.AddGrowableCol( 1, 1 )
-        
-        for ( name, field_type, default, editable ) in self._form_fields:
-            
-            if field_type == CC.FIELD_CHECKBOX:
-                
-                field = wx.CheckBox( self._post_panel )
-                
-                field.SetValue( default == 'True' )
-                
-            else: continue
-            
-            self._post_fields[ name ] = ( field_type, field, default )
-            
-            gridbox.AddF( wx.StaticText( self._post_panel, label = name + ':' ), CC.FLAGS_MIXED )
-            gridbox.AddF( field, CC.FLAGS_EXPAND_BOTH_WAYS )
-            
-        
-        for ( name, field_type, default, editable ) in self._form_fields:
-            
-            if field_type == CC.FIELD_FILE: self._file_post_name = name
-            
-        
-        self._post_panel.AddF( self._post_info, CC.FLAGS_EXPAND_PERPENDICULAR )
-        self._post_panel.AddF( postbox, CC.FLAGS_EXPAND_SIZER_PERPENDICULAR )
-        self._post_panel.AddF( gridbox, CC.FLAGS_EXPAND_SIZER_PERPENDICULAR )
-        
-        # misc
-        
-        self._advanced_tag_options = ClientGUICollapsible.CollapsibleOptionsTags( self, namespaces = [ 'creator', 'series', 'title', 'volume', 'chapter', 'page', 'character', 'person', 'all others' ] )
-        
-        # arrange stuff
-        
-        vbox = wx.BoxSizer( wx.VERTICAL )
-        
-        self._MakeSort( vbox )
-        
-        vbox.AddF( self._import_queue_panel, CC.FLAGS_EXPAND_PERPENDICULAR )
-        vbox.AddF( self._thread_panel, CC.FLAGS_EXPAND_PERPENDICULAR )
-        vbox.AddF( self._post_panel, CC.FLAGS_EXPAND_PERPENDICULAR )
-        vbox.AddF( self._advanced_tag_options, CC.FLAGS_EXPAND_PERPENDICULAR )
-        
-        self._MakeCurrentSelectionTagsBox( vbox )
-        
-        self.SetSizer( vbox )
-        
-        HydrusGlobals.pubsub.sub( self, 'FocusChanged', 'focus_changed' )
-        HydrusGlobals.pubsub.sub( self, 'SortedMediaPulse', 'sorted_media_pulse' )
-        
-        self._sorted_media_hashes = [ media_result.GetHash() for media_result in media_results ]
-        
-        self._hashes_to_media = { media_result.GetHash() : ClientMedia.MediaSingleton( media_result ) for media_result in media_results }
-        
-        self._hashes_to_dump_info = {}
-        
-        for ( hash, media ) in self._hashes_to_media.items():
-            
-            dump_status_enum = CC.DUMPER_NOT_DUMPED
-            
-            dump_status_string = 'not yet dumped'
-            
-            post_field_info = []
-            
-            for ( name, ( field_type, field, default ) ) in self._post_fields.items():
-                
-                if field_type == CC.FIELD_COMMENT:
-                    
-                    post_field_info.append( ( name, field_type, ( self._GetInitialComment( media ), '' ) ) )
-                    
-                elif field_type == CC.FIELD_CHECKBOX: post_field_info.append( ( name, field_type, default == 'True' ) )
-                elif field_type == CC.FIELD_VERIFICATION_RECAPTCHA: post_field_info.append( ( name, field_type, None ) )
-                
-            
-            self._hashes_to_dump_info[ hash ] = ( dump_status_enum, dump_status_string, post_field_info )
-            
-        
-        self.Bind( wx.EVT_MENU, self.EventMenu )
-        
-        self._timer.Start( 1000, wx.TIMER_CONTINUOUS )
-        
-    
-    def _THREADDoDump( self, hash, post_field_info, headers, body ):
-        
-        try:
-            
-            response = wx.GetApp().DoHTTP( HC.POST, self._post_url, request_headers = headers, body = body )
-            
-            ( status, phrase ) = ClientDownloading.Parse4chanPostScreen( response )
-            
-        except Exception as e:
-            
-            ( status, phrase ) = ( 'big error', HydrusData.ToString( e ) )
-            
-        
-        wx.CallAfter( self.CALLBACKDoneDump, hash, post_field_info, status, phrase )
-        
-    
-    def _FreezeCurrentMediaPostInfo( self ):
-        
-        ( dump_status_enum, dump_status_string, post_field_info ) = self._hashes_to_dump_info[ self._current_hash ]
-        
-        post_field_info = []
-        
-        for ( name, ( field_type, field, default ) ) in self._post_fields.items():
-            
-            if field_type == CC.FIELD_COMMENT: post_field_info.append( ( name, field_type, field.GetValues() ) )
-            elif field_type == CC.FIELD_CHECKBOX: post_field_info.append( ( name, field_type, field.GetValue() ) )
-            elif field_type == CC.FIELD_VERIFICATION_RECAPTCHA: post_field_info.append( ( name, field_type, field.GetValues() ) )
-            
-        
-        self._hashes_to_dump_info[ self._current_hash ] = ( dump_status_enum, dump_status_string, post_field_info )
-        
-    
-    def _GetInitialComment( self, media ):
-        
-        hash = media.GetHash()
-        
-        try: index = self._sorted_media_hashes.index( hash )
-        except: return 'media removed'
-        
-        num_files = len( self._sorted_media_hashes )
-        
-        if index == 0:
-            
-            total_size = sum( [ m.GetSize() for m in self._hashes_to_media.values() ] )
-            
-            initial = 'Hydrus Network Client is starting a dump of ' + HydrusData.ToString( num_files ) + ' files, totalling ' + HydrusData.ConvertIntToBytes( total_size ) + ':' + os.linesep * 2
-            
-        else: initial = ''
-        
-        initial += HydrusData.ConvertValueRangeToPrettyString( index + 1, num_files )
-        
-        advanced_tag_options = self._advanced_tag_options.GetInfo()
-        
-        for ( service_key, namespaces ) in advanced_tag_options.items():
-            
-            tags_manager = media.GetTagsManager()
-            
-            try: service = wx.GetApp().GetServicesManager().GetService( service_key )
-            except HydrusExceptions.NotFoundException: continue
-            
-            service_key = service.GetServiceKey()
-            
-            current = tags_manager.GetCurrent( service_key )
-            pending = tags_manager.GetPending( service_key )
-            
-            tags = current.union( pending )
-            
-            tags_to_include = []
-            
-            for namespace in namespaces:
-                
-                if namespace == 'all others': tags_to_include.extend( [ tag for tag in tags if not True in ( tag.startswith( n ) for n in namespaces if n != 'all others' ) ] )
-                else: tags_to_include.extend( [ tag for tag in tags if tag.startswith( namespace + ':' ) ] )
-                
-            
-            initial += os.linesep * 2 + ', '.join( tags_to_include )
-            
-        
-        return initial
-        
-    
-    def _ShowCurrentMedia( self ):
-        
-        if self._current_hash is None:
-            
-            self._post_info.SetLabel( 'no file selected' )
-            
-            for ( name, ( field_type, field, default ) ) in self._post_fields.items():
-                
-                if field_type == CC.FIELD_CHECKBOX: field.SetValue( False )
-                
-                field.Disable()
-                
-            
-        else:
-            
-            num_files = len( self._sorted_media_hashes )
-            
-            ( dump_status_enum, dump_status_string, post_field_info ) = self._hashes_to_dump_info[ self._current_hash ]
-            
-            index = self._sorted_media_hashes.index( self._current_hash )
-            
-            self._post_info.SetLabel( HydrusData.ConvertValueRangeToPrettyString( index + 1, num_files ) + ': ' + dump_status_string )
-            
-            for ( name, field_type, value ) in post_field_info:
-                
-                ( field_type, field, default ) = self._post_fields[ name ]
-                
-                if field_type == CC.FIELD_COMMENT:
-                    
-                    ( initial, append ) = value
-                    
-                    field.EnableWithValues( initial, append )
-                    
-                elif field_type == CC.FIELD_CHECKBOX:
-                    
-                    field.SetValue( value )
-                    field.Enable()
-                    
-                elif field_type == CC.FIELD_VERIFICATION_RECAPTCHA:
-                    
-                    if value is None: field.Enable()
-                    else:
-                        
-                        ( challenge, bitmap, captcha_runs_out, entry, ready ) = value
-                        
-                        field.EnableWithValues( challenge, bitmap, captcha_runs_out, entry, ready )
-                        
-                    
-                
-            
-            if dump_status_enum in ( CC.DUMPER_DUMPED_OK, CC.DUMPER_UNRECOVERABLE_ERROR ):
-                
-                for ( name, ( field_type, field, default ) ) in self._post_fields.items():
-                    
-                    if field_type == CC.FIELD_CHECKBOX: field.SetValue( False )
-                    
-                    field.Disable()
-                    
-                
-            
-        
-    
-    def _UpdatePendingInitialComments( self ):
-        
-        hashes_to_dump = self._sorted_media_hashes[ self._next_dump_index : ]
-        
-        for hash in hashes_to_dump:
-            
-            if hash == self._current_hash: self._FreezeCurrentMediaPostInfo()
-            
-            ( dump_status_enum, dump_status_string, post_field_info ) = self._hashes_to_dump_info[ hash ]
-            
-            new_post_field_info = []
-            
-            for ( name, field_type, value ) in post_field_info:
-                
-                if field_type == CC.FIELD_COMMENT:
-                    
-                    ( initial, append ) = value
-                    
-                    media = self._hashes_to_media[ hash ]
-                    
-                    initial = self._GetInitialComment( media )
-                    
-                    new_post_field_info.append( ( name, field_type, ( initial, append ) ) )
-                    
-                else: new_post_field_info.append( ( name, field_type, value ) )
-                
-            
-            self._hashes_to_dump_info[ hash ] = ( dump_status_enum, dump_status_string, new_post_field_info )
-            
-            if hash == self._current_hash: self._ShowCurrentMedia()
-            
-        
-    
-    def CALLBACKDoneDump( self, hash, post_field_info, status, phrase ):
-        
-        self._actually_dumping = False
-        
-        if HC.options[ 'play_dumper_noises' ]:
-            
-            if status == 'success': HydrusAudioHandling.PlayNoise( 'success' )
-            else: HydrusAudioHandling.PlayNoise( 'error' )
-            
-        
-        if status == 'success':
-            
-            dump_status_enum = CC.DUMPER_DUMPED_OK
-            dump_status_string = 'dumped ok'
-            
-            if hash == self._current_hash: HydrusGlobals.pubsub.pub( 'set_focus', self._page_key, None )
-            
-            self._next_dump_time = HydrusData.GetNow() + self._flood_time
-            
-            self._num_dumped += 1
-            
-            self._progress_gauge.SetValue( self._num_dumped )
-            
-            self._next_dump_index += 1
-            
-        elif status == 'captcha':
-            
-            dump_status_enum = CC.DUMPER_RECOVERABLE_ERROR
-            dump_status_string = 'captcha was incorrect'
-            
-            self._next_dump_time = HydrusData.GetNow() + 10
-            
-            new_post_field_info = []
-            
-            for ( name, field_type, value ) in post_field_info:
-                
-                if field_type == CC.FIELD_VERIFICATION_RECAPTCHA: new_post_field_info.append( ( name, field_type, None ) )
-                else: new_post_field_info.append( ( name, field_type, value ) )
-                
-                if hash == self._current_hash:
-                    
-                    ( field_type, field, default ) = self._post_fields[ name ]
-                    
-                    field.Enable()
-                    
-                
-            
-            post_field_info = new_post_field_info
-            
-        elif status == 'too quick':
-            
-            dump_status_enum = CC.DUMPER_RECOVERABLE_ERROR
-            dump_status_string = ''
-            
-            self._progress_info.SetLabel( 'Flood limit hit, retrying.' )
-            
-            self._next_dump_time = HydrusData.GetNow() + self._flood_time
-            
-        elif status == 'big error':
-            
-            dump_status_enum = CC.DUMPER_UNRECOVERABLE_ERROR
-            dump_status_string = ''
-            
-            HydrusData.ShowText( phrase )
-            
-            self._progress_info.SetLabel( 'error: ' + phrase )
-            
-            self._start_button.Disable()
-            
-            self._timer.Stop()
-            
-        elif 'Thread specified does not exist' in phrase:
-            
-            dump_status_enum = CC.DUMPER_UNRECOVERABLE_ERROR
-            dump_status_string = ''
-            
-            self._progress_info.SetLabel( 'thread specified does not exist!' )
-            
-            self._start_button.Disable()
-            
-            self._timer.Stop()
-            
-        else:
-            
-            dump_status_enum = CC.DUMPER_UNRECOVERABLE_ERROR
-            dump_status_string = phrase
-            
-            if hash == self._current_hash: HydrusGlobals.pubsub.pub( 'set_focus', self._page_key, None )
-            
-            self._next_dump_time = HydrusData.GetNow() + self._flood_time
-            
-            self._next_dump_index += 1
-            
-        
-        self._hashes_to_dump_info[ hash ] = ( dump_status_enum, dump_status_string, post_field_info )
-        
-        HydrusGlobals.pubsub.pub( 'file_dumped', self._page_key, hash, dump_status_enum )
-        
-        if self._next_dump_index == len( self._sorted_media_hashes ):
-            
-            self._progress_info.SetLabel( 'done - ' + HydrusData.ToString( self._num_dumped ) + ' dumped' )
-            
-            self._start_button.Disable()
-            
-            self._timer.Stop()
-            
-            self._dumping = False
-            
-        
-    
-    def EventCaptchaRefresh( self, event ):
-        
-        try:
-            
-            index = self._sorted_media_hashes.index( self._current_hash )
-            
-            if ( ( index + 1 ) - self._next_dump_index ) * ( self._flood_time + 10 ) > 5 * 60: event.Veto()
-            
-        except: event.Veto()
-        
-    
-    def EventMenu( self, event ):
-        
-        action = ClientCaches.MENU_EVENT_ID_TO_ACTION_CACHE.GetAction( event.GetId() )
-        
-        if action is not None:
-            
-            ( command, data ) = action
-            
-            if command == 'advanced_tag_options_changed': self._UpdatePendingInitialComments()
-            else: event.Skip()
-            
-        
-    
-    def EventStartButton( self, event ):
-        
-        if self._start_button.GetLabel() in ( 'start', 'continue' ):
-            
-            for ( name, ( field_type, field ) ) in self._thread_fields.items():
-                
-                if field_type == CC.FIELD_THREAD_ID:
-                    
-                    try: int( field.GetValue() )
-                    except:
-                        
-                        # let's assume they put the url in
-                        
-                        value = field.GetValue()
-                        
-                        thread_id = value.split( '/' )[ -1 ]
-                        
-                        try: int( thread_id )
-                        except:
-                            
-                            self._progress_info.SetLabel( 'set thread_id field first' )
-                            
-                            return
-                            
-                        
-                        field.SetValue( thread_id )
-                        
-                    
-                
-            
-            for ( field_type, field ) in self._thread_fields.values(): field.Disable()
-            
-            self._dumping = True
-            self._start_button.SetLabel( 'pause' )
-            
-            if self._next_dump_time == 0: self._next_dump_time = HydrusData.GetNow() + 5
-            
-            # disable thread fields here
-            
-        else:
-            
-            for ( field_type, field ) in self._thread_fields.values(): field.Enable()
-            
-            self._dumping = False
-            
-            if self._num_dumped == 0: self._start_button.SetLabel( 'start' )
-            else: self._start_button.SetLabel( 'continue' )
-            
-        
-    
-    def FocusChanged( self, page_key, media ):
-        
-        if page_key == self._page_key:
-            
-            if media is None: hash = None
-            else: hash = media.GetHash()
-            
-            if hash != self._current_hash:
-                
-                old_hash = self._current_hash
-                
-                if old_hash is not None: self._FreezeCurrentMediaPostInfo()
-                
-                self._current_hash = hash
-                
-                self._ShowCurrentMedia()
-                
-            
-        
-    
-    def SortedMediaPulse( self, page_key, sorted_media ):
-        
-        if page_key == self._page_key:
-            
-            self._sorted_media_hashes = [ media.GetHash() for media in sorted_media ]
-            
-            self._hashes_to_media = { hash : self._hashes_to_media[ hash ] for hash in self._sorted_media_hashes }
-            
-            new_hashes_to_dump_info = {}
-            
-            for ( hash, ( dump_status_enum, dump_status_string, post_field_info ) ) in self._hashes_to_dump_info.items():
-                
-                if hash not in self._sorted_media_hashes: continue
-                
-                new_post_field_info = []
-                
-                for ( name, field_type, value ) in post_field_info:
-                    
-                    if field_type == CC.FIELD_COMMENT:
-                        
-                        ( initial, append ) = value
-                        
-                        media = self._hashes_to_media[ hash ]
-                        
-                        initial = self._GetInitialComment( media )
-                        
-                        value = ( initial, append )
-                        
-                    
-                    new_post_field_info.append( ( name, field_type, value ) )
-                    
-                
-                new_hashes_to_dump_info[ hash ] = ( dump_status_enum, dump_status_string, new_post_field_info )
-                
-            
-            self._hashes_to_dump_info = new_hashes_to_dump_info
-            
-            self._ShowCurrentMedia()
-            
-            if self._current_hash is None and len( self._sorted_media_hashes ) > 0:
-                
-                hash_to_select = self._sorted_media_hashes[0]
-                
-                media_to_select = self._hashes_to_media[ hash_to_select ]
-                
-                HydrusGlobals.pubsub.pub( 'set_focus', self._page_key, media_to_select )
-                
-            
-        
-    
-    def TestAbleToClose( self ):
-        
-        if self._dumping:
-            
-            with ClientGUIDialogs.DialogYesNo( self, 'This page is still dumping. Are you sure you want to close it?' ) as dlg:
-                
-                if dlg.ShowModal() == wx.ID_NO: raise Exception()
-                
-            
-        
-    
-    def TIMEREvent( self, event ):
-        
-        if self._controller.IsPaused(): return
-        
-        if self._actually_dumping: return
-        
-        if self._dumping:
-            
-            time_left = self._next_dump_time - HydrusData.GetNow()
-            
-            if time_left < 1:
-                
-                try:
-                    
-                    hash = self._sorted_media_hashes[ self._next_dump_index ]
-                    
-                    wait = False
-                    
-                    if hash == self._current_hash: self._FreezeCurrentMediaPostInfo()
-                    
-                    ( dump_status_enum, dump_status_string, post_field_info ) = self._hashes_to_dump_info[ hash ]
-                    
-                    for ( name, field_type, value ) in post_field_info:
-                        
-                        if field_type == CC.FIELD_VERIFICATION_RECAPTCHA:
-                            
-                            if value is None:
-                                
-                                wait = True
-                                
-                                break
-                                
-                            else:
-                                
-                                ( challenge, bitmap, captcha_runs_out, entry, ready ) = value
-                                
-                                if HydrusData.TimeHasPassed( captcha_runs_out ) or not ready:
-                                    
-                                    wait = True
-                                    
-                                    break
-                                    
-                                
-                            
-                        
-                    
-                    if wait: self._progress_info.SetLabel( 'waiting for captcha' )
-                    else:
-                        
-                        self._progress_info.SetLabel( 'dumping' ) # 100% cpu time here - may or may not be desirable
-                        
-                        post_fields = []
-                        
-                        for ( name, ( field_type, field ) ) in self._thread_fields.items():
-                            
-                            post_fields.append( ( name, field_type, field.GetValue() ) )
-                            
-                        
-                        for ( name, field_type, value ) in post_field_info:
-                            
-                            if field_type == CC.FIELD_VERIFICATION_RECAPTCHA:
-                                
-                                ( challenge, bitmap, captcha_runs_out, entry, ready ) = value
-                                
-                                post_fields.append( ( 'recaptcha_challenge_field', field_type, challenge ) )
-                                post_fields.append( ( 'recaptcha_response_field', field_type, entry ) )
-                                
-                            elif field_type == CC.FIELD_COMMENT:
-                                
-                                ( initial, append ) = value
-                                
-                                comment = initial
-                                
-                                if len( append ) > 0: comment += os.linesep * 2 + append
-                                
-                                post_fields.append( ( name, field_type, comment ) )
-                                
-                            else: post_fields.append( ( name, field_type, value ) )
-                            
-                        
-                        media = self._hashes_to_media[ hash ]
-                        
-                        mime = media.GetMime()
-                        
-                        path = ClientFiles.GetFilePath( hash, mime )
-                        
-                        with open( path, 'rb' ) as f: file = f.read()
-                        
-                        post_fields.append( ( self._file_post_name, CC.FIELD_FILE, ( hash, mime, file ) ) )
-                        
-                        ( ct, body ) = HydrusNetworking.GenerateDumpMultipartFormDataCTAndBody( post_fields )
-                        
-                        headers = {}
-                        headers[ 'Content-Type' ] = ct
-                        if self._have_4chan_pass: headers[ 'Cookie' ] = 'pass_enabled=1; pass_id=' + self._4chan_token
-                        
-                        self._actually_dumping = True
-                        
-                        HydrusThreading.CallToThread( self._THREADDoDump, hash, post_field_info, headers, body )
-                        
-                    
-                except Exception as e:
-                    
-                    ( status, phrase ) = ( 'big error', HydrusData.ToString( e ) )
-                    
-                    wx.CallAfter( self.CALLBACKDoneDump, hash, post_field_info, status, phrase )
-                    
-                
-            else: self._progress_info.SetLabel( 'dumping next file in ' + HydrusData.ToString( time_left ) + ' seconds' )
-            
-        else:
-            
-            if self._num_dumped == 0: self._progress_info.SetLabel( 'will dump to ' + self._imageboard.GetName() )
-            else: self._progress_info.SetLabel( 'paused after ' + HydrusData.ToString( self._num_dumped ) + ' files dumped' )
-            
-        
-    
-management_panel_types_to_classes[ MANAGEMENT_TYPE_DUMPER ] = ManagementPanelDumper
 
 class ManagementPanelImport( ManagementPanel ):
     
diff --git a/include/ClientImporting.py b/include/ClientImporting.py
deleted file mode 100644
index 98576c6..0000000
--- a/include/ClientImporting.py
+++ /dev/null
@@ -1,558 +0,0 @@
-import ClientConstants as CC
-import HydrusConstants as HC
-import HydrusData
-import HydrusSerialisable
-import threading
-import traceback
-
-class ImportController( HydrusSerialisable.SerialisableBase ):
-    
-    def __init__( self ):
-        
-        HydrusSerialisable.SerialisableBase.__init__( self )
-        
-        # queues of stuff, where every kind of queue can be serialised
-        # hence don't have __init__ for subclasses! nothing beyond temp vars
-        # everything must fit inside what I declare here
-        # subclasses should mostly fill in _ProcessQueue kind of stuff.
-        # don't forget THREAD stuff, which should probably be explicitly started by the managementpanel?
-        # also, what about page_key? how are we reporting new imports and so on? maybe that can be temp var in the daemonspawner
-        
-        # hence maybe make a 'queue' object representing a list of urls or whatever -- maybe a urlcache can do that job.
-        
-        # a number of queues
-        # a thing that extends a queue using a search
-        # a list of searches that will be built into queues
-        
-        # maybe some class variables saying what parts to engage, like HDD doesn't accept new queues and so on
-        
-        self._file_status_counts = {}
-        
-        # if I decide to link search_seeds to the import_seed_queues, then why not bundle the import_seed_queue into the search_seed_info?
-        # yes, this is a good idea.
-        
-        self._import_seed_queues = []
-        self._importer_status = ( '', 0, 1 )
-        
-        self._search_seeds = SeedQueue()
-        self._searcher_status = ( '', 0, 1 )
-        
-        self._options = {}
-        
-        self._lock = threading.Lock()
-        self._import_status = ''
-        
-    
-    def _GetSerialisableInfo( self ):
-        
-        # collapse file status counts into a list because of stupid int dict json thing
-        
-        serialisable_url_cache = HydrusSerialisable.GetSerialisableTuple( self._url_cache )
-        
-        serialisable_options = { name : HydrusSerialisable.GetSerialisableTuple( options ) for ( name, options ) in self._options.items() }
-        
-        return ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, serialisable_url_cache, serialisable_options )
-        
-    
-    def _InitialiseFromSerialisableInfo( self, serialisable_info ):
-        
-        ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, serialisable_url_cache_tuple, serialisable_options_tuple ) = serialisable_info
-        
-        self._url_cache = HydrusSerialisable.CreateFromSerialisableTuple( serialisable_url_cache_tuple )
-        
-        self._options = { name : HydrusSerialisable.CreateFromSerialisableTuple( serialisable_suboptions_tuple ) for ( name, serialisable_suboptions_tuple ) in serialisable_options_tuple.items() }
-        
-    
-    def _ProcessImportSeed( self, seed, seed_info ):
-        
-        raise NotImplementedError()
-        
-    
-    def _ProcessSearchSeed( self, seed, seed_info ):
-        
-        raise NotImplementedError()
-        
-    
-    def _DAEMONProcessImportSeeds( self ):
-        
-        while True:
-            
-            # if importer paused
-            
-            with self._lock:
-                
-                result = None
-                
-                # determine paused/cancelled status via searchseedqueue or whatever
-                
-                for import_seed_queue in self._import_seed_queues:
-                    
-                    result = import_seed_queue.GetNextUnknownSeed()
-                    
-                    if result is not None:
-                        
-                        # remember current import_seed_queue so we can set seed status later
-                        
-                        break
-                        
-                    
-                
-            
-            if result is not None:
-                
-                ( seed, seed_info ) = result
-                
-                self._ProcessImportSeed( import_seed, seed_info )
-                
-            
-        
-    
-    def _DAEMONProcessSearchSeeds( self ):
-        
-        while True:
-            
-            # if searcher paused
-            
-            with self._lock:
-                
-                result = import_seed_queue.GetNextUnknownSeed()
-                
-                
-            
-            if result is not None:
-                
-                ( seed, seed_info ) = result
-                
-                self._ProcessSearchSeed( seed, seed_info )
-                
-            
-        
-    
-    def GetOptions( self, name ):
-        
-        with self._lock:
-            
-            return self._options[ name ]
-            
-        
-    
-    def GetStatuses( self ):
-        
-        with self._lock:
-            
-            return ( dict( self._file_status_counts ), self._import_status, self._current_queue_status, self._searcher_status )
-            
-        
-    
-    def PauseSearcher( self ):
-        
-        with self._lock:
-            
-            self._searcher_paused = True
-            
-        
-    
-    def ResumeCurrentQueue( self ):
-        
-        with self._lock:
-            
-            self._current_queue_paused = False
-            
-        
-    
-    def ResumeSearcher( self ):
-        
-        with self._lock:
-            
-            self._searcher_paused = False
-            
-        
-    
-    def SetOptions( self, name, options ):
-        
-        with self._lock:
-            
-            self._options[ name ] = options
-            
-        
-    
-class ImportControllerHDD( HydrusSerialisable.SerialisableBase ):
-    
-    SERIALISABLE_TYPE = HydrusSerialisable.SERIALISABLE_TYPE_HDD_IMPORT
-    SERIALISABLE_VERSION = 1
-    
-    def __init__( self ):
-        
-        HydrusSerialisable.SerialisableBase.__init__( self )
-        
-        # this stuff is all moved to the search seed
-        self._paths_info = None
-        self._paths_to_tags = None
-        self._delete_file_after_import = None
-        self._import_file_options = None
-        
-        self._lock = threading.Lock()
-        
-    
-    def _GetSerialisableInfo( self ):
-        
-        serialisable_url_cache = HydrusSerialisable.GetSerialisableTuple( self._url_cache )
-        
-        serialisable_options = { name : HydrusSerialisable.GetSerialisableTuple( options ) for ( name, options ) in self._options.items() }
-        
-        return ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, serialisable_url_cache, serialisable_options )
-        
-    
-    def _InitialiseFromSerialisableInfo( self, serialisable_info ):
-        
-        ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, serialisable_url_cache_tuple, serialisable_options_tuple ) = serialisable_info
-        
-        self._url_cache = HydrusSerialisable.CreateFromSerialisableTuple( serialisable_url_cache_tuple )
-        
-        self._options = { name : HydrusSerialisable.CreateFromSerialisableTuple( serialisable_suboptions_tuple ) for ( name, serialisable_suboptions_tuple ) in serialisable_options_tuple.items() }
-        
-    
-    def GetImportStatus( self ):
-        
-        with self._lock:
-            
-            return self._import_status
-            
-        
-    
-    def GetQueueStatus( self ):
-        
-        with self._lock:
-            
-            gauge_value = self._current_position
-            gauge_range = len( self._paths_info )
-            
-            # return progress string
-            # also return string for num_successful and so on
-            
-            pass
-            
-        
-    
-    def GetTuple( self ):
-        
-        return ( self._paths_info, self._paths_to_tags, self._delete_file_after_import, self._import_file_options )
-        
-    
-    def MainLoop( self ):
-        
-        # use the lock sparingly, remember
-        # obey pause and hc.shutdown
-        # maybe also an internal shutdown, on managementpanel cleanupbeforedestroy
-        # update file_status_counts
-        # increment current_position
-        
-        pass
-        
-    
-    def Pause( self ):
-        
-        with self._lock:
-            
-            self._paused = True
-            
-        
-    
-    def Resume( self ):
-        
-        with self._lock:
-            
-            self._paused = False
-            
-        
-    
-    def SetTuple( self, paths_info, paths_to_tags, delete_file_after_import, import_file_options ):
-        
-        self._paths_info = paths_info
-        self._paths_to_tags = paths_to_tags
-        self._delete_file_after_import = delete_file_after_import
-        self._import_file_options = import_file_options
-        
-    
-    def Start( self ):
-        
-        # init a daemon to work through the list
-        
-        pass
-        
-    
-HydrusSerialisable.SERIALISABLE_TYPES_TO_OBJECT_TYPES[ HydrusSerialisable.SERIALISABLE_TYPE_HDD_IMPORT ] = HDDImport
-
-class GalleryQuery( HydrusSerialisable.SerialisableBase ):
-    
-    SERIALISABLE_TYPE = HydrusSerialisable.SERIALISABLE_TYPE_GALLERY_QUERY
-    SERIALISABLE_VERSION = 1
-    
-    def __init__( self, name ):
-        
-        HydrusSerialisable.SerialisableBase.__init__( self )
-        
-        self._site_type = None
-        self._query_type = None
-        self._query = None
-        self._get_tags_if_redundant = False
-        self._file_limit = 500
-        self._paused = False
-        self._page_index = 0
-        self._url_cache = None
-        self._options = {}
-        
-    
-    def _GetSerialisableInfo( self ):
-        
-        serialisable_url_cache = HydrusSerialisable.GetSerialisableTuple( self._url_cache )
-        
-        serialisable_options = { name : HydrusSerialisable.GetSerialisableTuple( options ) for ( name, options ) in self._options.items() }
-        
-        return ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, self._file_limit, serialisable_url_cache, serialisable_options )
-        
-    
-    def _InitialiseFromSerialisableInfo( self, serialisable_info ):
-        
-        ( self._site_type, self._query_type, self._query, self._get_tags_if_redundant, serialisable_url_cache_tuple, serialisable_options_tuple ) = serialisable_info
-        
-        self._url_cache = HydrusSerialisable.CreateFromSerialisableTuple( serialisable_url_cache_tuple )
-        
-        self._options = { name : HydrusSerialisable.CreateFromSerialisableTuple( serialisable_suboptions_tuple ) for ( name, serialisable_suboptions_tuple ) in serialisable_options_tuple.items() }
-        
-    
-    def GetQuery( self ):
-        
-        return self._query
-        
-    
-    def SetTuple( self, site_type, query_type, query, get_tags_if_redundant, file_limit, options ):
-        
-        self._site_type = site_type
-        self._query_type = query_type
-        self._query = query
-        self._get_tags_if_redundant = get_tags_if_redundant
-        self._file_limit = file_limit
-        self._url_cache = URLCache()
-        self._options = options
-        
-    
-HydrusSerialisable.SERIALISABLE_TYPES_TO_OBJECT_TYPES[ HydrusSerialisable.SERIALISABLE_TYPE_GALLERY_QUERY ] = GalleryQuery
-
-class SubscriptionController( HydrusSerialisable.SerialisableBaseNamed ):
-    
-    SERIALISABLE_TYPE = HydrusSerialisable.SERIALISABLE_TYPE_SUBSCRIPTION
-    SERIALISABLE_VERSION = 1
-    
-    def __init__( self, name ):
-        
-        HydrusSerialisable.SerialisableBaseNamed.__init__( self, name )
-        
-        self._site_type = None
-        self._query_type = None
-        self._query = None
-        self._get_tags_if_redundant = False
-        self._file_limit = 500
-        self._periodic = None
-        self._page_index = 0
-        self._url_cache = None
-        self._options = {}
-        
-    
-    def _GetSerialisableInfo( self ):
-        
-        return ( HydrusSerialisable.GetSerialisableTuple( self._gallery_query ), HydrusSerialisable.GetSerialisableTuple( self._periodic ) )
-        
-    
-    def _InitialiseFromSerialisableInfo( self, serialisable_info ):
-        
-        ( serialised_gallery_query_tuple, serialised_periodic_tuple ) = serialisable_info
-        
-        self._gallery_query = HydrusSerialisable.CreateFromSerialisableTuple( serialised_gallery_query_tuple )
-        
-        self._periodic = HydrusSerialisable.CreateFromSerialisableTuple( serialised_periodic_tuple )
-        
-    
-HydrusSerialisable.SERIALISABLE_TYPES_TO_OBJECT_TYPES[ HydrusSerialisable.SERIALISABLE_TYPE_SUBSCRIPTION ] = Subscription
-
-class SeedQueue( HydrusSerialisable.SerialisableBase ):
-    
-    SERIALISABLE_TYPE = HydrusSerialisable.SERIALISABLE_TYPE_SEED_QUEUE
-    SERIALISABLE_VERSION = 1
-    
-    def __init__( self ):
-        
-        HydrusSerialisable.SerialisableBase.__init__( self )
-        
-        self._seeds_ordered = []
-        self._seeds_to_info = {}
-        
-        self._lock = threading.Lock()
-        
-    
-    def _GetSerialisableInfo( self ):
-        
-        with self._lock:
-            
-            serialisable_info = []
-            
-            for seed in self._seeds_ordered:
-                
-                seed_info = self._seeds_to_info[ seed ]
-                
-                serialisable_info.append( ( seed, seed_info ) )
-                
-            
-            return serialisable_info
-            
-        
-    
-    def _InitialiseFromSerialisableInfo( self, serialisable_info ):
-        
-        with self._lock:
-            
-            for ( seed, seed_info ) in serialisable_info:
-                
-                self._seeds_ordered.append( seed )
-                
-                self._seeds_to_info[ seed ] = seed_info
-                
-            
-        
-    
-    def AddSeed( self, seed, additional_info = None ):
-        
-        with self._lock:
-            
-            if seed in self._seeds_to_info:
-                
-                self._seeds_ordered.remove( seed )
-                
-            
-            self._seeds_ordered.append( seed )
-            
-            seed_info = {}
-            
-            seed_info[ 'status' ] = CC.STATUS_UNKNOWN
-            seed_info[ 'timestamp' ] = HydrusData.GetNow()
-            seed_info[ 'note' ] = ''
-            
-            if additional_info is not None:
-                
-                seed_info.update( additional_info )
-                
-            
-            self._seeds_to_info[ seed ] = seed_info
-            
-            
-        
-    
-    def AdvanceSeed( self, seed ):
-        
-        with self._lock:
-            
-            if seed in self._seeds_to_info:
-                
-                index = self._seeds_ordered.index( seed )
-                
-                if index > 0:
-                    
-                    self._seeds_ordered.remove( seed )
-                    
-                    self._seeds_ordered.insert( index - 1, seed )
-                    
-                
-            
-        
-    
-    def DelaySeed( self, seed ):
-        
-        with self._lock:
-            
-            if seed in self._seeds_to_info:
-                
-                index = self._seeds_ordered.index( seed )
-                
-                if index < len( self._seeds_ordered ) - 1:
-                    
-                    self._seeds_ordered.remove( seed )
-                    
-                    self._seeds_ordered.insert( index + 1, seed )
-                    
-                
-            
-        
-    
-    def GetNextUnknownSeed( self ):
-        
-        with self._lock:
-            
-            for seed in self._seeds_ordered:
-                
-                seed_info = self._seeds_to_info[ seed ]
-                
-                if seed_info[ 'status' ] == CC.STATUS_UNKNOWN:
-                    
-                    return ( seed, seed_info )
-                    
-                
-            
-        
-        return None
-        
-    
-    def GetSeeds( self ):
-        
-        with self._lock:
-            
-            return list( self._seeds_ordered )
-            
-        
-    
-    def GetSeedsDisplayInfo( self ):
-        
-        with self._lock:
-            
-            all_info = []
-            
-            for seed in self._seeds_ordered:
-                
-                seed_info = self._seeds_to_info[ seed ]
-                
-                timestamp = seed_info[ 'timestamp' ]
-                status = seed_info[ 'status' ]
-                note = seed_info[ 'note' ]
-                
-                all_info.append( ( seed, status, timestamp, note ) )
-                
-            
-            return all_info
-            
-        
-    
-    def RemoveSeed( self, seed ):
-        
-        with self._lock:
-            
-            if seed in self._seeds_to_info:
-                
-                del self._seeds_to_info[ seed ]
-                
-                self._seeds_ordered.remove( seed )
-                
-            
-        
-    
-    def SetSeedStatus( self, seed, status, note = '' ):
-        
-        with self._lock:
-            
-            seed_info = self._seeds_to_info[ seed ]
-            
-            seed_info[ 'status' ] = status
-            seed_info[ 'timestamp' ] = HydrusData.GetNow()
-            seed_info[ 'note' ] = note
-            
-        
-    
-HydrusSerialisable.SERIALISABLE_TYPES_TO_OBJECT_TYPES[ HydrusSerialisable.SERIALISABLE_TYPE_SEED_QUEUE ] = SeedQueue
diff --git a/include/HydrusData.py b/include/HydrusData.py
index 60345e8..2a9d747 100644
--- a/include/HydrusData.py
+++ b/include/HydrusData.py
@@ -999,15 +999,15 @@ class ClientToServerContentUpdatePackage( HydrusYAMLBase ):
                 
                 if data_type in ( HC.CONTENT_DATA_TYPE_TAG_SIBLINGS, HC.CONTENT_DATA_TYPE_TAG_PARENTS ) and action in ( HC.CONTENT_UPDATE_PENDING, HC.CONTENT_UPDATE_PETITION ):
                     
-                    munge_row = lambda ( pair, reason ): pair
+                    munge_row = lambda tup: tup[0]
                     
                 elif data_type == HC.CONTENT_DATA_TYPE_FILES and action == HC.CONTENT_UPDATE_PETITION:
                     
-                    munge_row = lambda ( hashes, reason ): hashes
+                    munge_row = lambda tup: tup[0]
                     
                 elif data_type == HC.CONTENT_DATA_TYPE_MAPPINGS and action == HC.CONTENT_UPDATE_PETITION:
                     
-                    munge_row = lambda ( tag, hashes, reason ): ( tag, hashes )
+                    munge_row = lambda tup: tup[:-1]
                     
                 
             else: new_action = action
diff --git a/include/HydrusImageHandling.py b/include/HydrusImageHandling.py
index 97c2fca..a69fe4e 100755
--- a/include/HydrusImageHandling.py
+++ b/include/HydrusImageHandling.py
@@ -50,7 +50,8 @@ def ConvertToPngIfBmp( path ):
             
         
     
-def EfficientlyResizeNumpyImage( numpy_image, ( target_x, target_y ) ):
+def EfficientlyResizeNumpyImage( numpy_image, target_dims ):
+    ( target_x, target_y ) = target_dims
     
     ( im_y, im_x, depth ) = numpy_image.shape
     
@@ -63,7 +64,8 @@ def EfficientlyResizeNumpyImage( numpy_image, ( target_x, target_y ) ):
     
     return cv2.resize( result, ( target_x, target_y ), interpolation = cv2.INTER_LINEAR )
     
-def EfficientlyResizePILImage( pil_image, ( target_x, target_y ) ):
+def EfficientlyResizePILImage( pil_image, target_dims ):
+    ( target_x, target_y ) = target_dims
     
     ( im_x, im_y ) = pil_image.size
     
@@ -76,7 +78,8 @@ def EfficientlyResizePILImage( pil_image, ( target_x, target_y ) ):
     
     return pil_image.resize( ( target_x, target_y ), PILImage.ANTIALIAS )
     
-def EfficientlyThumbnailNumpyImage( numpy_image, ( target_x, target_y ) ):
+def EfficientlyThumbnailNumpyImage( numpy_image, target_dims ):
+    ( target_x, target_y ) = target_dims
     
     ( im_y, im_x, depth ) = numpy_image.shape
     
@@ -86,7 +89,8 @@ def EfficientlyThumbnailNumpyImage( numpy_image, ( target_x, target_y ) ):
     
     return cv2.resize( numpy_image, ( target_x, target_y ), interpolation = cv2.INTER_AREA )
     
-def EfficientlyThumbnailPILImage( pil_image, ( target_x, target_y ) ):
+def EfficientlyThumbnailPILImage( pil_image, target_dims ):
+    ( target_x, target_y ) = target_dims
     
     ( im_x, im_y ) = pil_image.size
     
@@ -348,7 +352,9 @@ def GetResolutionAndNumFrames( path ):
     
     return ( ( x, y ), num_frames )
     
-def GetThumbnailResolution( ( im_x, im_y ), ( target_x, target_y ) ):
+def GetThumbnailResolution( im_dims, target_dims ):
+    ( im_x, im_y ) = im_dims
+    ( target_x, target_y ) = target_dims
     
     im_x = float( im_x )
     im_y = float( im_y )
diff --git a/include/HydrusMessageHandling.py b/include/HydrusMessageHandling.py
index dbd6c95..cbc017f 100755
--- a/include/HydrusMessageHandling.py
+++ b/include/HydrusMessageHandling.py
@@ -164,235 +164,3 @@ class Message( HydrusData.HydrusYAMLBase ):
         return verifier.verify( hash_object, self._signature )
         
     
-# here begins the new stuff, I'm pretty sure
-
-class Identity( object ): # should be a yamlable object
-    
-    def __init__( self ):
-        
-        # no name, right? we associate names and addresses with the identity, but the id only has keys
-        
-        # store key_type -> key
-        # hence need a key_type enum
-        
-        pass
-        
-    
-class IMManager( object ):
-    
-    def __init__( self ):
-        
-        self._accounts = {}
-        self._contexts = {}
-        self._persistent_connections = {}
-        self._temporary_connections = {}
-        
-        # go fetch all accounts from the db
-        
-        # set up many pubsubs
-        
-        # start up some sort of daemon to keep our accounts logged in
-        
-        pass
-        
-    
-    def _GetContext( self, identifier_local, name_local, identifier_remote, name_remote ):
-        
-        if ( identifier_remote, name_remote ) not in self._contexts[ identifier_local ]:
-            
-            account = self._accounts[ ( identifier_local, name_local ) ]
-            
-            context = HydrusEncryption.HydrusOTRContext( account, identifier_remote, name_remote )
-            
-            self._contexts[ ( identifier_local, name_local, identifier_remote, name_remote ) ] = context
-            
-        
-        context = self._contexts[ identifier_local ][ ( identifier_remote, name_remote ) ]
-        
-        return context
-        
-    
-    def LoginPersistentConnections( self ):
-        
-        # this is on a daemon thread, so move to twisted
-        
-        for ( identifier, name ) in self._accounts.keys():
-            
-            if ( identifier, name ) not in self._persistent_connections:
-                
-                # get host, port for that identity
-                
-                creator = ClientCreator( reactor, HydrusServerAMP.MessagingClientProtocol )
-                
-                deferred = creator.connectTCP( host, port )
-                
-                # deferred is called with the connection, or an error
-                # callRemote to register with session key and whatnot
-                
-                self._persistent_connections[ ( identifier, name ) ] = connection
-                
-            
-        
-    
-    def ReceiveMessage( self, identifier_from, name_from, identifier_to, name_to, message ):
-        
-        # currently on wx loop
-        # move it to the twisted loop
-        
-        if ( identifier_from, name_from, identifier_to, name_to ) not in self._temporary_connections:
-            
-            self._temporary_connections[ ( identifier_from, name_from, identifier_to, name_to ) ] = self._persistent_connections[ ( identifier_to, name_to ) ]
-            # this should have a better error, if the _to doesn't exist
-            # we should really just disregard it, and any other weirdness
-            
-        
-        context = self._GetContext( identifier_to, name_to, identifier_from, name_from )
-        
-        response = context.receiveMessage( message )
-        
-        if response is not None:
-            
-            ( decrypted_message, gumpf ) = response
-            
-            message_object = yaml.safe_load( decrypted_message )
-            
-            # do the pubsub
-            
-        
-    
-    def RemovePersistentConnection( self, identifier, name ):
-        
-        # if it is still alive, loseConnection or whatever.
-        # remove it
-        # pubsub the login daemon
-        
-        pass
-        
-    
-    def RemoveTemporaryConnection( self, identifier_from, name_from, identifier_to, name_to ):
-        
-        # if it is still alive, loseConnection or whatever.
-        # remove it
-        
-        pass
-        
-    
-    def SendMessage( self, identifier_from, name_from, identifier_to, name_to, message ):
-        
-        context = self._GetContext( identifier_from, name_from, identifier_to, name_to )
-        
-        context.sendMessage( potr.context.FRAGMENT_SEND_ALL, message )
-        
-    
-    def SendEncryptedMessage( self, identifier_from, name_from, identifier_to, name_to, message ):
-        
-        # currently on wx loop
-        # move it to the twisted loop
-        
-        connection = self._temporary_connections[ ( identifier_from, name_from, identifier_to, name_to ) ]
-        
-        connection.callRemote( HydrusServerAMP.IMMessageServer, identifier_to = identifier_to, name_to = name_to, message = message )
-        
-        # if it breaks, we should pubsub that it broke
-        
-    
-    def StartTalking( self, identifier_from, name_from, identifier_to, name_to ):
-        
-        # currently on wx loop
-        # move it to the twisted loop
-        
-        # fetch host and port for that id
-        
-        creator = ClientCreator( reactor, HydrusServerAMP.MessagingClientProtocol )
-        
-        deferred = creator.connectTCP( host, port )
-        
-        # deferred is called with the connection, or an error
-        # callRemote to register identifier_from and name_from as temp login
-        # then add to temp_connections
-        
-        self._temporary_connections[ ( identifier_from, name_from, identifier_to, name_to ) ] = connection
-        
-        message = '' # this is just to get the OTR handshake going; it'll never be sent
-        
-        connection.callRemote( HydrusServerAMP.IMMessageServer, identifier_to = identifier_to, name_to = name_to, message = message )
-        
-        # how do I detect when we are ready to do encrypted comms?
-        # I can check periodically context.status, but that is a _little_ bleh
-        # I can write a pubsub in the setStatus thing in context
-        # check that article again, or the code, on the exact name
-        
-        # do a pubsub to say we are ready to do encrypted comms
-        
-        # if it fails, we should pubsub that it broke
-        
-    
-    def StopTalking( self, identifier, name ):
-        
-        # close temp connection
-        # 
-        
-        pass
-        
-    
-class IMMessage( HydrusData.HydrusYAMLBase ):
-    
-    yaml_tag = u'!IMMessage'
-    
-class IMMessageQuestion( IMMessage ):
-    
-    yaml_tag = u'!IMMessageQuestion'
-    
-    def __init__( self, job_key = None ):
-        
-        if job_key is None: job_key = HydrusData.GenerateKey()
-        
-        self._job_key = job_key
-        
-    
-    def GenerateAnswer( self, answer ):
-        
-        return IMMessageQuestionAnswer( self._job_key, answer )
-        
-    
-    def GetJobKey( self ): return self._job_key
-    
-class IMMessageQuestionAnswer( IMMessageQuestion ):
-    
-    yaml_tag = u'!IMMessageQuestionAnswer'
-    
-    def __init__( self, job_key, answer ):
-        
-        IMMessageQuestion.__init__( self, job_key )
-        
-        self._answer = answer
-        
-    
-    def GetAnswer( self ): return self._answer
-    
-class IMMessageQuestionFiles( IMMessageQuestion ):
-    
-    yaml_tag = u'!IMMessageFiles'
-    
-    def __init__( self, media_results ):
-        
-        IMMessageQuestion.__init__( self )
-        
-        self._text = text
-        
-    
-IM_MESSAGE_TYPE_CONVO = 0
-IM_MESSAGE_TYPE_STATUS = 1
-
-class IMMessageText( IMMessage ):
-    
-    yaml_tag = u'!IMMessageText'
-    
-    def __init__( self, message_type, text ):
-        
-        self._type = message_type
-        self._text = text
-        
-    
-    def ToTuple( self ): return ( self._type, self._text )
-    
\ No newline at end of file
diff --git a/include/HydrusSerialisable.py b/include/HydrusSerialisable.py
index d26bf20..9518fc2 100644
--- a/include/HydrusSerialisable.py
+++ b/include/HydrusSerialisable.py
@@ -131,4 +131,4 @@ class SerialisableBaseNamed( SerialisableBase ):
     def GetName( self ): return self._name
     
     def SetName( self, name ): self._name = name
-    
\ No newline at end of file
+    
diff --git a/include/HydrusTags.py b/include/HydrusTags.py
index 3bc8528..75c7f7b 100644
--- a/include/HydrusTags.py
+++ b/include/HydrusTags.py
@@ -352,7 +352,7 @@ class TagsManagerSimple( object ):
         combined_current = combined_statuses_to_tags[ HC.CURRENT ]
         combined_pending = combined_statuses_to_tags[ HC.PENDING ]
         
-        slice = { tag for tag in combined_current.union( combined_pending ) if True in ( tag.startswith( namespace + ':' ) for namespace in namespaces ) }
+        slice = { tag for tag in combined_current.union( combined_pending ) if True in (lambda tag:( tag.startswith( namespace + ':' ) for namespace in namespaces ))(tag) }
         
         if collapse_siblings:
             
