diff --git a/src/modules/FFmpeg/FFDecSW.cpp b/src/modules/FFmpeg/FFDecSW.cpp
index 73462faf..e12aef85 100644
--- a/src/modules/FFmpeg/FFDecSW.cpp
+++ b/src/modules/FFmpeg/FFDecSW.cpp
@@ -371,7 +371,7 @@ void FFDecSW::setPixelFormat()
 	const AVPixFmtDescriptor *pixDesc = av_pix_fmt_desc_get(codec_ctx->pix_fmt);
 	if (!pixDesc) //Invalid pixel format
 		return;
-	dontConvert = supportedPixelFormats.contains((QMPlay2PixelFormat)codec_ctx->pix_fmt);
+	dontConvert = supportedPixelFormats.contains(QMPlay2PixelFormatConvert::fromFFmpeg(codec_ctx->pix_fmt));
 	if (dontConvert)
 	{
 		chromaShiftW = pixDesc->log2_chroma_w;
@@ -380,14 +380,15 @@ void FFDecSW::setPixelFormat()
 	}
 	else for (int i = 0; i < supportedPixelFormats.count(); ++i)
 	{
-		const AVPixFmtDescriptor *supportedPixDesc = av_pix_fmt_desc_get((AVPixelFormat)supportedPixelFormats.at(i));
+		const AVPixelFormat pixFmt = (AVPixelFormat)QMPlay2PixelFormatConvert::toFFmpeg(supportedPixelFormats.at(i));
+		const AVPixFmtDescriptor *supportedPixDesc = av_pix_fmt_desc_get(pixFmt);
 		if (i == 0 || (supportedPixDesc->log2_chroma_w == pixDesc->log2_chroma_w && supportedPixDesc->log2_chroma_h == pixDesc->log2_chroma_h))
 		{
 			//Use first format as default (mostly QMPlay2PixelFormat::YUV420P) and look at next formats,
 			//otherwise break the loop if found proper format.
 			chromaShiftW = supportedPixDesc->log2_chroma_w;
 			chromaShiftH = supportedPixDesc->log2_chroma_h;
-			desiredPixFmt = (int)supportedPixelFormats.at(i);
+			desiredPixFmt = pixFmt;
 			if (i != 0)
 				break;
 		}
diff --git a/src/qmplay2/CMakeLists.txt b/src/qmplay2/CMakeLists.txt
index 41dfefb6..5402c75e 100644
--- a/src/qmplay2/CMakeLists.txt
+++ b/src/qmplay2/CMakeLists.txt
@@ -87,6 +87,7 @@ set(QMPLAY2_SRC
     Buffer.cpp
     NetworkAccess.cpp
     Version.cpp
+    PixelFormats.cpp
     YouTubeDL.cpp
     Notifies.cpp
     NotifiesTray.cpp
diff --git a/src/qmplay2/ImgScaler.cpp b/src/qmplay2/ImgScaler.cpp
index 580bdbe0..106726c2 100644
--- a/src/qmplay2/ImgScaler.cpp
+++ b/src/qmplay2/ImgScaler.cpp
@@ -34,7 +34,7 @@ bool ImgScaler::create(const VideoFrameSize &size, int newWdst, int newHdst, boo
 {
 	m_srcH = size.height;
 	m_dstLinesize = newWdst << 2;
-	return (m_swsCtx = sws_getCachedContext(m_swsCtx, size.width, m_srcH, isNV12 ? AV_PIX_FMT_NV12 : (AVPixelFormat)size.getFormat(), newWdst, newHdst, AV_PIX_FMT_RGB32, SWS_BILINEAR, nullptr, nullptr, nullptr));
+	return (m_swsCtx = sws_getCachedContext(m_swsCtx, size.width, m_srcH, isNV12 ? AV_PIX_FMT_NV12 : (AVPixelFormat)QMPlay2PixelFormatConvert::toFFmpeg(size.getFormat()), newWdst, newHdst, AV_PIX_FMT_RGB32, SWS_BILINEAR, nullptr, nullptr, nullptr));
 }
 void ImgScaler::scale(const VideoFrame &src, void *dst)
 {
diff --git a/src/qmplay2/PixelFormats.cpp b/src/qmplay2/PixelFormats.cpp
new file mode 100644
index 00000000..3ae7862e
--- /dev/null
+++ b/src/qmplay2/PixelFormats.cpp
@@ -0,0 +1,69 @@
+/*
+	QMPlay2 is a video and audio player.
+	Copyright (C) 2010-2018  Błażej Szczygieł
+
+	This program is free software: you can redistribute it and/or modify
+	it under the terms of the GNU Lesser General Public License as published
+	by the Free Software Foundation, either version 3 of the License, or
+	(at your option) any later version.
+
+	This program is distributed in the hope that it will be useful,
+	but WITHOUT ANY WARRANTY; without even the implied warranty of
+	MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+	GNU Lesser General Public License for more details.
+
+	You should have received a copy of the GNU Lesser General Public License
+	along with this program.  If not, see <http://www.gnu.org/licenses/>.
+*/
+
+#include <PixelFormats.hpp>
+
+extern "C"
+{
+	#include <libavutil/pixfmt.h>
+}
+
+namespace QMPlay2PixelFormatConvert {
+
+int toFFmpeg(QMPlay2PixelFormat pixFmt)
+{
+	switch (pixFmt)
+	{
+		case QMPlay2PixelFormat::YUV420P:
+			return AV_PIX_FMT_YUV420P;
+		case QMPlay2PixelFormat::YUV422P:
+			return AV_PIX_FMT_YUV422P;
+		case QMPlay2PixelFormat::YUV444P:
+			return AV_PIX_FMT_YUV444P;
+		case QMPlay2PixelFormat::YUV410P:
+			return AV_PIX_FMT_YUV410P;
+		case QMPlay2PixelFormat::YUV411P:
+			return AV_PIX_FMT_YUV411P;
+		case QMPlay2PixelFormat::YUV440P:
+			return AV_PIX_FMT_YUV440P;
+		default:
+			break;
+	}
+	return AV_PIX_FMT_NONE;
+}
+QMPlay2PixelFormat fromFFmpeg(int pixFmt)
+{
+	switch (pixFmt)
+	{
+		case AV_PIX_FMT_YUV420P:
+			return QMPlay2PixelFormat::YUV420P;
+		case AV_PIX_FMT_YUV422P:
+			return QMPlay2PixelFormat::YUV422P;
+		case AV_PIX_FMT_YUV444P:
+			return QMPlay2PixelFormat::YUV444P;
+		case AV_PIX_FMT_YUV410P:
+			return QMPlay2PixelFormat::YUV410P;
+		case AV_PIX_FMT_YUV411P:
+			return QMPlay2PixelFormat::YUV411P;
+		case AV_PIX_FMT_YUV440P:
+			return QMPlay2PixelFormat::YUV440P;
+	}
+	return QMPlay2PixelFormat::None;
+}
+
+}
diff --git a/src/qmplay2/headers/PixelFormats.hpp b/src/qmplay2/headers/PixelFormats.hpp
index 96524564..a32c9ab4 100644
--- a/src/qmplay2/headers/PixelFormats.hpp
+++ b/src/qmplay2/headers/PixelFormats.hpp
@@ -18,10 +18,14 @@
 
 #pragma once
 
+#include <QMPlay2Lib.hpp>
+
 #include <QVector>
 
-enum class QMPlay2PixelFormat //Compatible with FFmpeg
+enum class QMPlay2PixelFormat
 {
+	None    = -1,
+
 	YUV420P =  0,
 	YUV422P =  4,
 	YUV444P =  5,
@@ -32,3 +36,10 @@ enum class QMPlay2PixelFormat //Compatible with FFmpeg
 	Count   =  6
 };
 using QMPlay2PixelFormats = QVector<QMPlay2PixelFormat>;
+
+namespace QMPlay2PixelFormatConvert {
+
+QMPLAY2SHAREDLIB_EXPORT int toFFmpeg(QMPlay2PixelFormat pixFmt);
+QMPLAY2SHAREDLIB_EXPORT QMPlay2PixelFormat fromFFmpeg(int pixFmt);
+
+}
