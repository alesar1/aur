From 371ef6a8e0260bd15b0d3ccc29bb25d8a5dd7a4d Mon Sep 17 00:00:00 2001
From: elp0t0r1c0 <elpotorico@protonmail.com>
Date: Fri, 29 Nov 2019 21:44:29 +0100
Subject: [PATCH 1/2] Fix #31: add missing algorithm header

---
 img4tool/img4tool.cpp | 33 +++++++++++++++++----------------
 1 file changed, 17 insertions(+), 16 deletions(-)

diff --git a/img4tool/img4tool.cpp b/img4tool/img4tool.cpp
index ac62916..3746257 100644
--- a/img4tool/img4tool.cpp
+++ b/img4tool/img4tool.cpp
@@ -10,6 +10,7 @@
 #include <stdio.h>
 #include <string.h>
 #include <array>
+#include <algorithm>
 #include <arpa/inet.h>
 #include "ASN1DERElement.hpp"
 #include <libgeneral/macros.h>
@@ -369,7 +370,7 @@ void tihmstar::img4tool::printIM4P(const void *buf, size_t size){
                     {
                         ASN1DERElement versionTag = tag[0];
                         ASN1DERElement sizeTag    = tag[1];
-                        
+
                         assure(versionTag.tag().isConstructed == ASN1DERElement::Primitive);
                         assure(versionTag.tag().tagNumber == ASN1DERElement::TagINTEGER);
                         assure(versionTag.tag().tagClass == ASN1DERElement::Universal);
@@ -480,22 +481,22 @@ ASN1DERElement tihmstar::img4tool::getIM4RFromIMG4(const ASN1DERElement &img4){
     ASN1DERElement im4r = container[0];
 
     assure(isIM4R(im4r));
-    
+
     return im4r;
 }
 
 ASN1DERElement tihmstar::img4tool::getBNCNFromIM4R(const ASN1DERElement &im4r){
     assure(isIM4R(im4r));
-    
+
     ASN1DERElement set = im4r[1];
     ASN1DERElement bncnTag = set[0];
     size_t ptagVal = 0;
     ASN1DERElement ptag = parsePrivTag(bncnTag.buf(), bncnTag.size(), &ptagVal);
     ASN1DERElement octet = ptag[1];
-    
+
     //convert big endian to little endian
     std::string octetString{(char*)octet.payload(),octet.payloadSize()};
-    
+
     ASN1DERElement retval({ASN1DERElement::TagOCTET, ASN1DERElement::Primitive, ASN1DERElement::Universal},octetString.c_str(),octetString.size());
     return retval;
 }
@@ -564,7 +565,7 @@ ASN1DERElement tihmstar::img4tool::uncompressIfNeeded(const ASN1DERElement &comp
         ASN1DERElement compressingSequence = origIM4P[5];
         ASN1DERElement versionTag = compressingSequence[0];
         ASN1DERElement sizeTag    = compressingSequence[1];
-        
+
         assure(versionTag.tag().isConstructed == ASN1DERElement::Primitive);
         assure(versionTag.tag().tagNumber == ASN1DERElement::TagINTEGER);
         assure(versionTag.tag().tagClass == ASN1DERElement::Universal);
@@ -574,10 +575,10 @@ ASN1DERElement tihmstar::img4tool::uncompressIfNeeded(const ASN1DERElement &comp
         assure(sizeTag.tag().isConstructed == ASN1DERElement::Primitive);
         assure(sizeTag.tag().tagNumber == ASN1DERElement::TagINTEGER);
         assure(sizeTag.tag().tagClass == ASN1DERElement::Universal);
-        
+
         unpackedLen = sizeTag.getIntegerValue();
         unpacked = (char*)malloc(unpackedLen);
-        
+
         if ((uncompSizeReal = lzfse_decode_buffer((uint8_t*)unpacked, unpackedLen, (const uint8_t*)compressedOctet.payload(), compressedOctet.payloadSize(), NULL)) == unpackedLen) {
             retVal = ASN1DERElement({ASN1DERElement::TagNumber::TagOCTET,ASN1DERElement::Primitive, ASN1DERElement::Universal}, unpacked, unpackedLen);
             printf("ok\n");
@@ -780,9 +781,9 @@ bool tihmstar::img4tool::isGeneratorValidForIM4M(const ASN1DERElement &im4m, std
     try {
         ASN1DERElement bnch = getValFromIM4M(im4m,'BNCH');
         uint64_t gen = 0;
-        
+
         sscanf(generator.c_str(), "0x%16llx", &gen);
-        
+
         if (bnch.payloadSize() == SHA_DIGEST_LENGTH) {
             std::array<char, SHA_DIGEST_LENGTH> tmp{'\0'};
             std::string hash{tmp.begin(),tmp.end()};
@@ -915,7 +916,7 @@ bool tihmstar::img4tool::isIM4R(const ASN1DERElement &im4r) noexcept{
         assure(set.tag().tagClass == ASN1DERElement::TagClass::Universal);
 
         ASN1DERElement bncnTag = set[0];
-        
+
         size_t ptagVal = 0;
         ASN1DERElement ptag = parsePrivTag(bncnTag.buf(), bncnTag.size(), &ptagVal);
         assure(ptagVal == htonl('BNCN'));
@@ -1079,7 +1080,7 @@ bool tihmstar::img4tool::im4mMatchesBuildIdentity(const ASN1DERElement &im4m, pl
             checksPassed = false;
             findDGST = ignoreWhitelist[0]+1;
         }
-        
+
         printf("[IMG4TOOL] checking buildidentity matches board ... ");
         if (!doesIM4MBoardMatchBuildIdentity(im4m, buildIdentity)) {
             printf("NO\n");
@@ -1135,19 +1136,19 @@ bool tihmstar::img4tool::im4mMatchesBuildIdentity(const ASN1DERElement &im4m, pl
                     continue;
                 }
             }
-            
+
             {
                 if (!strncmp(eKey, "Savage,",strlen("Savage,"))) {
                     printf("IGN (custom ignore: Savage)\n");
                     continue;
                 }
             }
-            
+
             if (!(pDigest = plist_dict_get_item(eVal, "Digest"))) {
                 printf("IGN (no digest in BuildManifest)\n");
                 continue;
             }
-            
+
             assure(plist_get_node_type(pDigest) == PLIST_DATA);
             plist_get_data_val(pDigest, &digest, &digestLen);
 
@@ -1194,7 +1195,7 @@ bool tihmstar::img4tool::im4mMatchesBuildIdentity(const ASN1DERElement &im4m, pl
                     }
                 }
             }
-            
+
             if (!hasDigit) {
                 if (findDGST.size()) {
                     printf("IGN (hash not found in im4m, but ignoring since we only care about '%s')\n",findDGST.c_str());
-- 
2.24.0

