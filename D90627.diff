diff --git a/python/mozbuild/mozbuild/configure/__init__.py b/python/mozbuild/mozbuild/configure/__init__.py
--- a/python/mozbuild/mozbuild/configure/__init__.py
+++ b/python/mozbuild/mozbuild/configure/__init__.py
@@ -877,17 +877,63 @@
 
     def _apply_imports(self, func, glob):
         for _from, _import, _as in self._imports.pop(func, ()):
-            _from = '%s.' % _from if _from else ''
-            if _as:
-                glob[_as] = self._get_one_import('%s%s' % (_from, _import))
-            else:
-                what = _import.split('.')[0]
-                glob[what] = self._get_one_import('%s%s' % (_from, what))
+            self._get_one_import(_from, _import, _as, glob)
+
+    def _handle_wrapped_import(self, _from, _import, _as, glob):
+        """Given the name of a module, "import" a mocked package into the glob
+        iff the module is one that we wrap (either for the sandbox or for the
+        purpose of testing). Applies if the wrapped module is exposed by an
+        attribute of `self`.
+
+        For example, if the import statement is `from os import environ`, then
+        this function will set
+        glob['environ'] = self._wrapped_os.environ.
+
+        Iff this function handles the given import, return True.
+        """
+        attr_module_pairs = [
+            (a, a[len('_wrapped_'):].replace('_', '.'))
+            for a in dir(self) if a.startswith('_wrapped_')
+        ]
+        name = _from or _import
+        chosen = [
+            (attr, module) for (attr, module) in attr_module_pairs
+            if name == module or name.startswith(module + '.')
+        ]
+        assert len(chosen) <= 1
+        if not chosen:
+            return False
+        attr, module = chosen[0]
+        wrapped = getattr(self, attr)
+        if _as or _from:
+            glob[_as or _import] = self._recursively_get_property(
+                module, (_from + '.' if _from else '') + _import, wrapped)
+        else:
+            glob[module] = wrapped
+        return True
+
+    def _recursively_get_property(self, module, what, wrapped):
+        """Traverse the wrapper object `wrapped` (which represents the module
+        `module`) and return the property represented by `what`, which may be a
+        series of nested attributes.
+
+        For example, if `module` is 'os' and `what` is 'os.path.join',
+        return `wrapped.path.join`.
+        """
+        if what == module:
+            return wrapped
+        assert what.startswith(module + '.')
+        attrs = what[len(module + '.'):].split('.')
+        for attr in attrs:
+            wrapped = getattr(wrapped, attr)
+        return wrapped
 
     @memoized_property
     def _wrapped_os(self):
         wrapped_os = {}
         exec_('from os import *', {}, wrapped_os)
+        # Special case os and os.environ so that os.environ is our copy of
+        # the environment.
         wrapped_os['environ'] = self._environ
         return ReadOnlyNamespace(**wrapped_os)
 
@@ -913,19 +959,17 @@
 
         return ReadOnlyNamespace(**wrapped_subprocess)
 
-    def _get_one_import(self, what):
-        # The special `__sandbox__` module gives access to the sandbox
-        # instance.
-        if what == '__sandbox__':
-            return self
-        # Special case for the open() builtin, because otherwise, using it
-        # fails with "IOError: file() constructor not accessible in
-        # restricted mode". We also make open() look more like python 3's,
-        # decoding to unicode strings unless the mode says otherwise.
-        if what == '__builtin__.open' or what == 'builtins.open':
-            if six.PY3:
-                return open
-
+    @memoized_property
+    def _wrapped_six_moves_builtins(self):
+        wrapped_six_moves_builtins = {}
+        exec_('from six.moves.builtins import *', {},
+              wrapped_six_moves_builtins)
+
+        if not six.PY3:
+            # Special case for the open() builtin, because otherwise, using it
+            # fails with "IOError: file() constructor not accessible in
+            # restricted mode". We also make open() look more like python 3's,
+            # decoding to unicode strings unless the mode says otherwise.
             def wrapped_open(name, mode=None, buffering=None):
                 args = (name,)
                 kwargs = {}
@@ -937,33 +981,31 @@
                         return open(*args, **kwargs)
                 kwargs['encoding'] = system_encoding
                 return codecs.open(*args, **kwargs)
-            return wrapped_open
-        # Special case os and os.environ so that os.environ is our copy of
-        # the environment.
-        if what == 'os.environ':
-            return self._environ
-        if what == 'os':
-            return self._wrapped_os
-        # And subprocess, so that its functions use our os.environ
-        if what == 'subprocess':
-            return self._wrapped_subprocess
-        if what in ('subprocess.call', 'subprocess.check_call',
-                    'subprocess.check_output', 'subprocess.Popen'):
-            return getattr(self._wrapped_subprocess, what[len('subprocess.'):])
+            wrapped_six_moves_builtins['open'] = wrapped_open
+
+        return ReadOnlyNamespace(**wrapped_six_moves_builtins)
+
+    def _get_one_import(self, _from, _import, _as, glob):
+        """Perform the given import, placing the result into the dict glob."""
+        if not _from and _import == '__builtin__':
+            glob[_as or '__builtin__'] = __builtin__
+            return
+        if _from == '__builtin__':
+            _from = 'six.moves.builtins'
+        # The special `__sandbox__` module gives access to the sandbox
+        # instance.
+        if not _from and _import == '__sandbox__':
+            glob[_as or _import] = self
+            return
+        if self._handle_wrapped_import(_from, _import, _as, glob):
+            return
+        # If we've gotten this far, we should just do a normal import.
         # Until this proves to be a performance problem, just construct an
         # import statement and execute it.
-        import_line = ''
-        if '.' in what:
-            _from, what = what.rsplit('.', 1)
-            if _from == '__builtin__' or _from.startswith('__builtin__.'):
-                _from = _from.replace('__builtin__', 'six.moves.builtins')
-            import_line += 'from %s ' % _from
-        if what == '__builtin__':
-            what = 'six.moves.builtins'
-        import_line += 'import %s as imported' % what
-        glob = {}
+        import_line = '%simport %s%s' % (
+            ('from %s ' % _from) if _from else '', _import,
+            (' as %s' % _as) if _as else '')
         exec_(import_line, {}, glob)
-        return glob['imported']
 
     def _resolve_and_set(self, data, name, value, when=None):
         # Don't set anything when --help was on the command line
diff --git a/python/mozbuild/mozbuild/test/configure/common.py b/python/mozbuild/mozbuild/test/configure/common.py
--- a/python/mozbuild/mozbuild/test/configure/common.py
+++ b/python/mozbuild/mozbuild/test/configure/common.py
@@ -15,7 +15,10 @@
 from six import StringIO
 
 from mozbuild.configure import ConfigureSandbox
-from mozbuild.util import ReadOnlyNamespace
+from mozbuild.util import (
+    memoized_property,
+    ReadOnlyNamespace,
+)
 from mozpack import path as mozpath
 from six import string_types
 
@@ -45,7 +48,7 @@
     def exists(self, path):
         if path in self._paths:
             return True
-        if mozpath.basedir(path, [topsrcdir, topobjdir]):
+        if mozpath.basedir(path, [topsrcdir, topobjdir, tempfile.tempdir]):
             return os.path.exists(path)
         return False
 
@@ -57,6 +60,15 @@
             return os.path.isfile(path)
         return False
 
+    def expanduser(self, path):
+        return os.path.expanduser(path)
+
+    def isdir(self, path):
+        return os.path.isdir(path)
+
+    def getsize(self, path):
+        return os.path.getsize(path)
+
 
 class ConfigureTestSandbox(ConfigureSandbox):
     '''Wrapper around the ConfigureSandbox for testing purposes.
@@ -99,80 +111,65 @@
 
         os_path.update(self.OS.path.__dict__)
 
-        self.imported_os = ReadOnlyNamespace(path=ReadOnlyNamespace(**os_path))
-
-        self.modules = kwargs.pop('modules', {}) or {}
+        os_contents = {}
+        exec('from os import *', {}, os_contents)
+        os_contents['path'] = ReadOnlyNamespace(**os_path)
+        os_contents['environ'] = dict(environ)
+        self.imported_os = ReadOnlyNamespace(**os_contents)
 
         super(ConfigureTestSandbox, self).__init__(config, environ, *args,
                                                    **kwargs)
 
-    def _get_one_import(self, what):
-        if what in self.modules:
-            return self.modules[what]
-
-        if what == 'mozfile.which':
-            return self.which
-
-        if what == 'mozfile':
-            return ReadOnlyNamespace(
-                which=self.which,
-            )
-
-        if what == 'subprocess.Popen':
-            return self.Popen
-
-        if what == 'subprocess':
-            return ReadOnlyNamespace(
-                CalledProcessError=subprocess.CalledProcessError,
-                check_output=self.check_output,
-                PIPE=subprocess.PIPE,
-                STDOUT=subprocess.STDOUT,
-                Popen=self.Popen,
-            )
-
-        if what == 'os.path':
-            return self.imported_os.path
-
-        if what == 'os.path.exists':
-            return self.imported_os.path.exists
-
-        if what == 'os.path.isfile':
-            return self.imported_os.path.isfile
-
-        if what == 'ctypes.wintypes':
-            return ReadOnlyNamespace(
+    @memoized_property
+    def _wrapped_mozfile(self):
+        return ReadOnlyNamespace(which=self.which)
+
+    @memoized_property
+    def _wrapped_os(self):
+        return self.imported_os
+
+    @memoized_property
+    def _wrapped_subprocess(self):
+        return ReadOnlyNamespace(
+            CalledProcessError=subprocess.CalledProcessError,
+            check_output=self.check_output,
+            PIPE=subprocess.PIPE,
+            STDOUT=subprocess.STDOUT,
+            Popen=self.Popen,
+        )
+
+    @memoized_property
+    def _wrapped_ctypes(self):
+        class CTypesFunc(object):
+            def __init__(self, func):
+                self._func = func
+
+            def __call__(self, *args, **kwargs):
+                return self._func(*args, **kwargs)
+
+        return ReadOnlyNamespace(
+            create_unicode_buffer=self.create_unicode_buffer,
+            windll=ReadOnlyNamespace(
+                kernel32=ReadOnlyNamespace(
+                    GetShortPathNameW=CTypesFunc(self.GetShortPathNameW),
+                )
+            ),
+            wintypes=ReadOnlyNamespace(
                 LPCWSTR=0,
                 LPWSTR=1,
                 DWORD=2,
-            )
-
-        if what == 'ctypes':
-            class CTypesFunc(object):
-                def __init__(self, func):
-                    self._func = func
-
-                def __call__(self, *args, **kwargs):
-                    return self._func(*args, **kwargs)
-
-            return ReadOnlyNamespace(
-                create_unicode_buffer=self.create_unicode_buffer,
-                windll=ReadOnlyNamespace(
-                    kernel32=ReadOnlyNamespace(
-                        GetShortPathNameW=CTypesFunc(self.GetShortPathNameW),
-                    )
-                ),
-            )
-
-        if what == '_winreg':
-            def OpenKey(*args, **kwargs):
-                raise WindowsError()
+            ),
+        )
 
-            return ReadOnlyNamespace(
-                HKEY_LOCAL_MACHINE=0,
-                OpenKey=OpenKey,
-            )
+    @memoized_property
+    def _wrapped__winreg(self):
+        def OpenKey(*args, **kwargs):
+            raise WindowsError()
 
-        return super(ConfigureTestSandbox, self)._get_one_import(what)
+        return ReadOnlyNamespace(
+            HKEY_LOCAL_MACHINE=0,
+            OpenKey=OpenKey,
+        )
 
     def create_unicode_buffer(self, *args, **kwargs):
         class Buffer(object):
@@ -257,7 +254,7 @@
         return 0, args[0], ''
 
     def get_sandbox(self, paths, config, args=[], environ={}, mozconfig='',
-                    out=None, logger=None, modules=None):
+                    out=None, logger=None, cls=ConfigureTestSandbox):
         kwargs = {}
         if logger:
             kwargs['logger'] = logger
@@ -293,9 +290,8 @@
                                'config.guess')] = self.config_guess
             paths[mozpath.join(autoconf_dir, 'config.sub')] = self.config_sub
 
-            sandbox = ConfigureTestSandbox(paths, config, environ,
-                                           ['configure'] + target + args,
-                                           modules=modules, **kwargs)
+            sandbox = cls(paths, config, environ, ['configure'] + target + args,
+                          **kwargs)
             sandbox.include_file(os.path.join(topsrcdir, 'moz.configure'))
 
             return sandbox
diff --git a/python/mozbuild/mozbuild/test/configure/test_moz_configure.py b/python/mozbuild/mozbuild/test/configure/test_moz_configure.py
--- a/python/mozbuild/mozbuild/test/configure/test_moz_configure.py
+++ b/python/mozbuild/mozbuild/test/configure/test_moz_configure.py
@@ -7,9 +7,22 @@
 from mozunit import main
 from mozbuild.util import (
     exec_,
+    memoized_property,
     ReadOnlyNamespace,
 )
-from common import BaseConfigureTest
+from common import BaseConfigureTest, ConfigureTestSandbox
+
+
+def sandbox_class(platform):
+    class ConfigureTestSandboxOverridingPlatform(ConfigureTestSandbox):
+        @memoized_property
+        def _wrapped_sys(self):
+            sys = {}
+            exec_('from sys import *', sys)
+            sys['platform'] = platform
+            return ReadOnlyNamespace(**sys)
+
+    return ConfigureTestSandboxOverridingPlatform
 
 
 class TargetTest(BaseConfigureTest):
@@ -22,13 +35,7 @@
             platform = 'openbsd6'
         else:
             raise Exception('Missing platform for HOST {}'.format(self.HOST))
-        wrapped_sys = {}
-        exec_('from sys import *', wrapped_sys)
-        wrapped_sys['platform'] = platform
-        modules = {
-            'sys': ReadOnlyNamespace(**wrapped_sys),
-        }
-        sandbox = self.get_sandbox({}, {}, args, env, modules=modules)
+        sandbox = self.get_sandbox({}, {}, args, env, cls=sandbox_class(platform))
         return sandbox._value_for(sandbox['target']).alias
 
