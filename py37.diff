diff --git a/tensorflow/workspace.bzl b/tensorflow/workspace.bzl
index eb5b5796c4..c4f6bd5ebd 100644
--- a/tensorflow/workspace.bzl
+++ b/tensorflow/workspace.bzl
@@ -690,6 +690,7 @@ def tf_workspace(path_prefix="", tf_repo_name=""):
       strip_prefix = "cython-3732784c45cfb040a5b0936951d196f83a12ea17",
       build_file = clean_dep("//third_party:cython.BUILD"),
       delete = ["BUILD.bazel"],
+      patch_file = clean_dep("//third_party:py37.patch"),
   )
 
   tf_http_archive(
diff --git a/third_party/py37.patch b/third_party/py37.patch
new file mode 100644
index 0000000000..a2f71034c4
--- /dev/null
+++ b/third_party/py37.patch
@@ -0,0 +1,202 @@
+diff --git a/Cython/Compiler/ExprNodes.py b/Cython/Compiler/ExprNodes.py
+index ad0a72b..d7ffb9c 100644
+--- a/Cython/Compiler/ExprNodes.py
++++ b/Cython/Compiler/ExprNodes.py
+@@ -2866,18 +2866,18 @@ class WithExitCallNode(ExprNode):
+     # The __exit__() call of a 'with' statement.  Used in both the
+     # except and finally clauses.
+ 
+-    # with_stat  WithStatNode                the surrounding 'with' statement
+-    # args       TupleNode or ResultStatNode the exception info tuple
+-    # await      AwaitExprNode               the await expression of an 'async with' statement
++    # with_stat   WithStatNode                the surrounding 'with' statement
++    # args        TupleNode or ResultStatNode the exception info tuple
++    # await_expr  AwaitExprNode               the await expression of an 'async with' statement
+ 
+-    subexprs = ['args', 'await']
++    subexprs = ['args', 'await_expr']
+     test_if_run = True
+-    await = None
++    await_expr = None
+ 
+     def analyse_types(self, env):
+         self.args = self.args.analyse_types(env)
+-        if self.await:
+-            self.await = self.await.analyse_types(env)
++        if self.await_expr:
++            self.await_expr = self.await_expr.analyse_types(env)
+         self.type = PyrexTypes.c_bint_type
+         self.is_temp = True
+         return self
+@@ -2904,12 +2904,12 @@ class WithExitCallNode(ExprNode):
+         code.putln(code.error_goto_if_null(result_var, self.pos))
+         code.put_gotref(result_var)
+ 
+-        if self.await:
++        if self.await_expr:
+             # FIXME: result_var temp currently leaks into the closure
+-            self.await.generate_evaluation_code(code, source_cname=result_var, decref_source=True)
+-            code.putln("%s = %s;" % (result_var, self.await.py_result()))
+-            self.await.generate_post_assignment_code(code)
+-            self.await.free_temps(code)
++            self.await_expr.generate_evaluation_code(code, source_cname=result_var, decref_source=True)
++            code.putln("%s = %s;" % (result_var, self.await_expr.py_result()))
++            self.await_expr.generate_post_assignment_code(code)
++            self.await_expr.free_temps(code)
+ 
+         if self.result_is_used:
+             self.allocate_temp_result(code)
+diff --git a/Cython/Compiler/ParseTreeTransforms.py b/Cython/Compiler/ParseTreeTransforms.py
+index 7ee9861..129cd24 100644
+--- a/Cython/Compiler/ParseTreeTransforms.py
++++ b/Cython/Compiler/ParseTreeTransforms.py
+@@ -1292,7 +1292,7 @@ class WithTransform(CythonTransform, SkipDeclarations):
+                                 pos, with_stat=node,
+                                 test_if_run=False,
+                                 args=excinfo_target,
+-                                await=ExprNodes.AwaitExprNode(pos, arg=None) if is_async else None)),
++                                await_expr=ExprNodes.AwaitExprNode(pos, arg=None) if is_async else None)),
+                         body=Nodes.ReraiseStatNode(pos),
+                     ),
+                 ],
+@@ -1314,7 +1314,7 @@ class WithTransform(CythonTransform, SkipDeclarations):
+                     test_if_run=True,
+                     args=ExprNodes.TupleNode(
+                         pos, args=[ExprNodes.NoneNode(pos) for _ in range(3)]),
+-                    await=ExprNodes.AwaitExprNode(pos, arg=None) if is_async else None)),
++                    await_expr=ExprNodes.AwaitExprNode(pos, arg=None) if is_async else None)),
+             handle_error_case=False,
+         )
+         return node
+diff --git a/Cython/Utility/Coroutine.c b/Cython/Utility/Coroutine.c
+index f6afa78..4a7d723 100644
+--- a/Cython/Utility/Coroutine.c
++++ b/Cython/Utility/Coroutine.c
+@@ -1719,13 +1719,20 @@ static void __Pyx__ReturnWithStopIteration(PyObject* value) {
+         Py_INCREF(value);
+         exc = value;
+     }
++    #if CYTHON_FAST_THREAD_STATE
+     __Pyx_PyThreadState_assign
+-    if (!$local_tstate_cname->exc_type) {
++    #if PY_VERSION_HEX >= 0x030700A2
++    if (!$local_tstate_cname->exc_state.exc_type)
++    #else
++    if (!$local_tstate_cname->exc_type)
++    #endif
++    {
+         // no chaining needed => avoid the overhead in PyErr_SetObject()
+         Py_INCREF(PyExc_StopIteration);
+         __Pyx_ErrRestore(PyExc_StopIteration, exc, NULL);
+         return;
+     }
++    #endif
+ #else
+     args = PyTuple_Pack(1, value);
+     if (unlikely(!args)) return;
+diff --git a/Cython/Utility/Exceptions.c b/Cython/Utility/Exceptions.c
+index 6b891e9..d49a2b2 100644
+--- a/Cython/Utility/Exceptions.c
++++ b/Cython/Utility/Exceptions.c
+@@ -357,12 +357,21 @@ static int __Pyx_GetException(PyObject **type, PyObject **value, PyObject **tb)
+     *value = local_value;
+     *tb = local_tb;
+ #if CYTHON_FAST_THREAD_STATE
++    #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 7
++    tmp_type = tstate->exc_state.exc_type;
++    tmp_value = tstate->exc_state.exc_value;
++    tmp_tb = tstate->exc_state.exc_traceback;
++    tstate->exc_state.exc_type = local_type;
++    tstate->exc_state.exc_value = local_value;
++    tstate->exc_state.exc_traceback = local_tb;
++    #else
+     tmp_type = tstate->exc_type;
+     tmp_value = tstate->exc_value;
+     tmp_tb = tstate->exc_traceback;
+     tstate->exc_type = local_type;
+     tstate->exc_value = local_value;
+     tstate->exc_traceback = local_tb;
++    #endif
+     // Make sure tstate is in a consistent state when we XDECREF
+     // these objects (DECREF may run arbitrary code).
+     Py_XDECREF(tmp_type);
+@@ -392,9 +401,15 @@ static CYTHON_INLINE void __Pyx_ReraiseException(void) {
+     PyObject *type = NULL, *value = NULL, *tb = NULL;
+ #if CYTHON_FAST_THREAD_STATE
+     PyThreadState *tstate = PyThreadState_GET();
++    #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 7
++    type = tstate->exc_state.exc_type;
++    value = tstate->exc_state.exc_value;
++    tb = tstate->exc_state.exc_traceback;
++    #else
+     type = tstate->exc_type;
+     value = tstate->exc_value;
+     tb = tstate->exc_traceback;
++    #endif
+ #else
+     PyErr_GetExcInfo(&type, &value, &tb);
+ #endif
+@@ -438,9 +453,15 @@ static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject
+ 
+ #if CYTHON_FAST_THREAD_STATE
+ static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
++    #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 7
++    *type = tstate->exc_state.exc_type;
++    *value = tstate->exc_state.exc_value;
++    *tb = tstate->exc_state.exc_traceback;
++    #else
+     *type = tstate->exc_type;
+     *value = tstate->exc_value;
+     *tb = tstate->exc_traceback;
++    #endif
+     Py_XINCREF(*type);
+     Py_XINCREF(*value);
+     Py_XINCREF(*tb);
+@@ -448,12 +469,22 @@ static CYTHON_INLINE void __Pyx__ExceptionSave(PyThreadState *tstate, PyObject *
+ 
+ static CYTHON_INLINE void __Pyx__ExceptionReset(PyThreadState *tstate, PyObject *type, PyObject *value, PyObject *tb) {
+     PyObject *tmp_type, *tmp_value, *tmp_tb;
++
++    #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 7
++    tmp_type = tstate->exc_state.exc_type;
++    tmp_value = tstate->exc_state.exc_value;
++    tmp_tb = tstate->exc_state.exc_traceback;
++    tstate->exc_state.exc_type = type;
++    tstate->exc_state.exc_value = value;
++    tstate->exc_state.exc_traceback = tb;
++    #else
+     tmp_type = tstate->exc_type;
+     tmp_value = tstate->exc_value;
+     tmp_tb = tstate->exc_traceback;
+     tstate->exc_type = type;
+     tstate->exc_value = value;
+     tstate->exc_traceback = tb;
++    #endif
+     Py_XDECREF(tmp_type);
+     Py_XDECREF(tmp_value);
+     Py_XDECREF(tmp_tb);
+@@ -476,6 +507,16 @@ static CYTHON_INLINE void __Pyx_ExceptionSwap(PyObject **type, PyObject **value,
+ #if CYTHON_FAST_THREAD_STATE
+ static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject **type, PyObject **value, PyObject **tb) {
+     PyObject *tmp_type, *tmp_value, *tmp_tb;
++
++    #if PY_MAJOR_VERSION >= 3 && PY_MINOR_VERSION >= 7
++    tmp_type = tstate->exc_state.exc_type;
++    tmp_value = tstate->exc_state.exc_value;
++    tmp_tb = tstate->exc_state.exc_traceback;
++
++    tstate->exc_state.exc_type = *type;
++    tstate->exc_state.exc_value = *value;
++    tstate->exc_state.exc_traceback = *tb;
++    #else
+     tmp_type = tstate->exc_type;
+     tmp_value = tstate->exc_value;
+     tmp_tb = tstate->exc_traceback;
+@@ -484,6 +525,7 @@ static CYTHON_INLINE void __Pyx__ExceptionSwap(PyThreadState *tstate, PyObject *
+     tstate->exc_value = *value;
+     tstate->exc_traceback = *tb;
+ 
++    #endif
+     *type = tmp_type;
+     *value = tmp_value;
+     *tb = tmp_tb;
