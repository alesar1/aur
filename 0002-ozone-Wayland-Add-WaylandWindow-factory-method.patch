From 53e253ee8daeff98359dfd1fd8f9374879e6aaa5 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Fri, 6 Dec 2019 19:55:37 +0000
Subject: [PATCH 2/9] ozone/Wayland: Add WaylandWindow factory method.

To hide future different types of WaylandWindows (WaylandSurface,
WaylandPopup and WaylandSubsurface), add a factory method, which
will handle everything on its own.

Also make unittests and OzonePlatformWayland use this factory.

Bug: 1028919
Change-Id: I745f99024b6657be3686ee92b0baf4c93f08b9a7
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1954470
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Reviewed-by: Michael Spang <spang@chromium.org>
Cr-Commit-Position: refs/heads/master@{#722586}
---
 ui/ozone/platform/wayland/BUILD.gn            |   1 +
 .../wayland/host/wayland_pointer_unittest.cc  |   5 +-
 .../wayland/host/wayland_screen_unittest.cc   |   5 +-
 .../platform/wayland/host/wayland_window.cc   | 132 +++++++++---------
 .../platform/wayland/host/wayland_window.h    |  17 ++-
 .../wayland/host/wayland_window_factory.cc    |  26 ++++
 .../host/wayland_window_manager_unittests.cc  |   8 +-
 .../wayland/host/wayland_window_unittest.cc   | 120 ++++++++--------
 .../wayland/ozone_platform_wayland.cc         |   6 +-
 .../platform/wayland/test/wayland_test.cc     |   4 +-
 .../wayland_buffer_manager_unittest.cc        |   6 +-
 11 files changed, 184 insertions(+), 146 deletions(-)
 create mode 100644 ui/ozone/platform/wayland/host/wayland_window_factory.cc

diff --git a/ui/ozone/platform/wayland/BUILD.gn b/ui/ozone/platform/wayland/BUILD.gn
index 9c2cbc52500b..a9c0302f162f 100644
--- a/ui/ozone/platform/wayland/BUILD.gn
+++ b/ui/ozone/platform/wayland/BUILD.gn
@@ -95,6 +95,7 @@ source_set("wayland") {
     "host/wayland_touch.h",
     "host/wayland_window.cc",
     "host/wayland_window.h",
+    "host/wayland_window_factory.cc",
     "host/wayland_window_manager.cc",
     "host/wayland_window_manager.h",
     "host/wayland_window_observer.cc",
diff --git a/ui/ozone/platform/wayland/host/wayland_pointer_unittest.cc b/ui/ozone/platform/wayland/host/wayland_pointer_unittest.cc
index be9cd942d6ec..b96f2e6f73f9 100644
--- a/ui/ozone/platform/wayland/host/wayland_pointer_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_pointer_unittest.cc
@@ -72,14 +72,15 @@ TEST_P(WaylandPointerTest, Enter) {
 
 TEST_P(WaylandPointerTest, Leave) {
   MockPlatformWindowDelegate other_delegate;
-  WaylandWindow other_window(&other_delegate, connection_.get());
   gfx::AcceleratedWidget other_widget = gfx::kNullAcceleratedWidget;
   EXPECT_CALL(other_delegate, OnAcceleratedWidgetAvailable(_))
       .WillOnce(SaveArg<0>(&other_widget));
+
   PlatformWindowInitProperties properties;
   properties.bounds = gfx::Rect(0, 0, 10, 10);
   properties.type = PlatformWindowType::kWindow;
-  ASSERT_TRUE(other_window.Initialize(std::move(properties)));
+  auto other_window = WaylandWindow::Create(&other_delegate, connection_.get(),
+                                            std::move(properties));
   ASSERT_NE(other_widget, gfx::kNullAcceleratedWidget);
 
   Sync();
diff --git a/ui/ozone/platform/wayland/host/wayland_screen_unittest.cc b/ui/ozone/platform/wayland/host/wayland_screen_unittest.cc
index e1e3cc823ac3..9198aa88e054 100644
--- a/ui/ozone/platform/wayland/host/wayland_screen_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_screen_unittest.cc
@@ -89,13 +89,12 @@ class WaylandScreenTest : public WaylandTest {
       PlatformWindowType window_type,
       gfx::AcceleratedWidget parent_widget,
       MockPlatformWindowDelegate* delegate) {
-    auto window = std::make_unique<WaylandWindow>(delegate, connection_.get());
     PlatformWindowInitProperties properties;
     properties.bounds = bounds;
     properties.type = window_type;
     properties.parent_widget = parent_widget;
-    EXPECT_TRUE(window->Initialize(std::move(properties)));
-    return window;
+    return WaylandWindow::Create(delegate, connection_.get(),
+                                 std::move(properties));
   }
 
   void UpdateOutputGeometry(wl_resource* output_resource,
diff --git a/ui/ozone/platform/wayland/host/wayland_window.cc b/ui/ozone/platform/wayland/host/wayland_window.cc
index 95c6e5a46b3e..da9a4cb368b8 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window.cc
@@ -85,72 +85,6 @@ WaylandWindow* WaylandWindow::FromSurface(wl_surface* surface) {
       wl_proxy_get_user_data(reinterpret_cast<wl_proxy*>(surface)));
 }
 
-bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
-  // Properties contain DIP bounds but the buffer scale is initially 1 so it's
-  // OK to assign.  The bounds will be recalculated when the buffer scale
-  // changes.
-  DCHECK_EQ(buffer_scale_, 1);
-  bounds_px_ = properties.bounds;
-  opacity_ = properties.opacity;
-
-  surface_.reset(wl_compositor_create_surface(connection_->compositor()));
-  if (!surface_) {
-    LOG(ERROR) << "Failed to create wl_surface";
-    return false;
-  }
-  wl_surface_set_user_data(surface_.get(), this);
-  AddSurfaceListener();
-
-  connection_->wayland_window_manager()->AddWindow(GetWidget(), this);
-
-  ui::PlatformWindowType ui_window_type = properties.type;
-  switch (ui_window_type) {
-    case ui::PlatformWindowType::kMenu:
-    case ui::PlatformWindowType::kPopup:
-      parent_window_ = GetParentWindow(properties.parent_widget);
-
-      // Popups need to know their scale earlier to position themselves.
-      if (!parent_window_) {
-        LOG(ERROR) << "Failed to get a parent window for this popup";
-        return false;
-      }
-
-      SetBufferScale(parent_window_->buffer_scale_, false);
-      ui_scale_ = parent_window_->ui_scale_;
-
-      // TODO(msisov, jkim): Handle notification windows, which are marked
-      // as popup windows as well. Those are the windows that do not have
-      // parents and pop up when the browser receives a notification.
-      CreateShellPopup();
-      break;
-    case ui::PlatformWindowType::kTooltip:
-      // Tooltips subsurfaces are created on demand, upon ::Show calls.
-      is_tooltip_ = true;
-      break;
-    case ui::PlatformWindowType::kWindow:
-    case ui::PlatformWindowType::kBubble:
-    case ui::PlatformWindowType::kDrag:
-      // TODO(msisov): Figure out what kind of surface we need to create for
-      // bubble and drag windows.
-      CreateShellSurface();
-      break;
-  }
-
-  if (shell_surface_ && !properties.wm_class_class.empty())
-    shell_surface_->SetAppId(properties.wm_class_class);
-
-  connection_->ScheduleFlush();
-
-  PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
-  delegate_->OnAcceleratedWidgetAvailable(GetWidget());
-
-  // Will do nothing for popups because they have got their scale above.
-  UpdateBufferScale(false);
-
-  MaybeUpdateOpaqueRegion();
-  return true;
-}
-
 void WaylandWindow::UpdateBufferScale(bool update_bounds) {
   DCHECK(connection_->wayland_output_manager());
   const auto* screen = connection_->wayland_output_manager()->wayland_screen();
@@ -792,6 +726,72 @@ void WaylandWindow::OnDragSessionClose(uint32_t dnd_action) {
   connection_->ResetPointerFlags();
 }
 
+bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
+  // Properties contain DIP bounds but the buffer scale is initially 1 so it's
+  // OK to assign.  The bounds will be recalculated when the buffer scale
+  // changes.
+  DCHECK_EQ(buffer_scale_, 1);
+  bounds_px_ = properties.bounds;
+  opacity_ = properties.opacity;
+
+  surface_.reset(wl_compositor_create_surface(connection_->compositor()));
+  if (!surface_) {
+    LOG(ERROR) << "Failed to create wl_surface";
+    return false;
+  }
+  wl_surface_set_user_data(surface_.get(), this);
+  AddSurfaceListener();
+
+  connection_->wayland_window_manager()->AddWindow(GetWidget(), this);
+
+  ui::PlatformWindowType ui_window_type = properties.type;
+  switch (ui_window_type) {
+    case ui::PlatformWindowType::kMenu:
+    case ui::PlatformWindowType::kPopup:
+      parent_window_ = GetParentWindow(properties.parent_widget);
+
+      // Popups need to know their scale earlier to position themselves.
+      if (!parent_window_) {
+        LOG(ERROR) << "Failed to get a parent window for this popup";
+        return false;
+      }
+
+      SetBufferScale(parent_window_->buffer_scale_, false);
+      ui_scale_ = parent_window_->ui_scale_;
+
+      // TODO(msisov, jkim): Handle notification windows, which are marked
+      // as popup windows as well. Those are the windows that do not have
+      // parents and pop up when the browser receives a notification.
+      CreateShellPopup();
+      break;
+    case ui::PlatformWindowType::kTooltip:
+      // Tooltips subsurfaces are created on demand, upon ::Show calls.
+      is_tooltip_ = true;
+      break;
+    case ui::PlatformWindowType::kWindow:
+    case ui::PlatformWindowType::kBubble:
+    case ui::PlatformWindowType::kDrag:
+      // TODO(msisov): Figure out what kind of surface we need to create for
+      // bubble and drag windows.
+      CreateShellSurface();
+      break;
+  }
+
+  if (shell_surface_ && !properties.wm_class_class.empty())
+    shell_surface_->SetAppId(properties.wm_class_class);
+
+  connection_->ScheduleFlush();
+
+  PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
+  delegate_->OnAcceleratedWidgetAvailable(GetWidget());
+
+  // Will do nothing for popups because they have got their scale above.
+  UpdateBufferScale(false);
+
+  MaybeUpdateOpaqueRegion();
+  return true;
+}
+
 void WaylandWindow::SetBoundsDip(const gfx::Rect& bounds_dip) {
   SetBounds(gfx::ScaleToRoundedRect(bounds_dip, buffer_scale_));
 }
diff --git a/ui/ozone/platform/wayland/host/wayland_window.h b/ui/ozone/platform/wayland/host/wayland_window.h
index 4233216d7a6f..b8cdc991e30e 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.h
+++ b/ui/ozone/platform/wayland/host/wayland_window.h
@@ -40,13 +40,16 @@ class WaylandWindow : public PlatformWindow,
                       public WmMoveResizeHandler,
                       public WmDragHandler {
  public:
-  WaylandWindow(PlatformWindowDelegate* delegate,
-                WaylandConnection* connection);
   ~WaylandWindow() override;
 
-  static WaylandWindow* FromSurface(wl_surface* surface);
+  // A factory method that can create any of the derived types of WaylandWindow
+  // (WaylandSurface, WaylandPopup and WaylandSubsurface).
+  static std::unique_ptr<WaylandWindow> Create(
+      PlatformWindowDelegate* delegate,
+      WaylandConnection* connection,
+      PlatformWindowInitProperties properties);
 
-  bool Initialize(PlatformWindowInitProperties properties);
+  static WaylandWindow* FromSurface(wl_surface* surface);
 
   // Updates the surface buffer scale of the window.  Top level windows take
   // scale from the output attached to either their current display or the
@@ -168,6 +171,12 @@ class WaylandWindow : public PlatformWindow,
  private:
   FRIEND_TEST_ALL_PREFIXES(WaylandScreenTest, SetBufferScale);
 
+  WaylandWindow(PlatformWindowDelegate* delegate,
+                WaylandConnection* connection);
+
+  // Initializes the WaylandWindow with supplied properties.
+  bool Initialize(PlatformWindowInitProperties properties);
+
   void SetBoundsDip(const gfx::Rect& bounds_dip);
   void SetBufferScale(int32_t scale, bool update_bounds);
 
diff --git a/ui/ozone/platform/wayland/host/wayland_window_factory.cc b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
new file mode 100644
index 000000000000..19da59357d55
--- /dev/null
+++ b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
@@ -0,0 +1,26 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/host/wayland_window.h"
+
+#include <memory>
+
+#include "ui/ozone/platform/wayland/host/wayland_window.h"
+
+namespace ui {
+
+// static
+std::unique_ptr<WaylandWindow> WaylandWindow::Create(
+    PlatformWindowDelegate* delegate,
+    WaylandConnection* connection,
+    PlatformWindowInitProperties properties) {
+  // TODO(msisov): once WaylandWindow becomes a base class, add switch cases to
+  // create different Wayland windows.
+  std::unique_ptr<WaylandWindow> window(
+      new WaylandWindow(delegate, connection));
+  return window->Initialize(std::move(properties)) ? std::move(window)
+                                                   : nullptr;
+}
+
+}  // namespace ui
\ No newline at end of file
diff --git a/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc b/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
index 737c7cdd25d9..64a387723560 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_manager_unittests.cc
@@ -36,12 +36,8 @@ class WaylandWindowManagerTest : public WaylandTest {
     PlatformWindowInitProperties properties;
     properties.bounds = bounds;
     properties.type = type;
-
-    std::unique_ptr<WaylandWindow> window =
-        std::make_unique<WaylandWindow>(delegate, connection_.get());
-
-    EXPECT_TRUE(window->Initialize(std::move(properties)));
-    return window;
+    return WaylandWindow::Create(delegate, connection_.get(),
+                                 std::move(properties));
   }
 
   WaylandWindowManager* manager_ = nullptr;
diff --git a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
index f8dc4429c073..b03a28daadf2 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
@@ -150,20 +150,19 @@ class WaylandWindowTest : public WaylandTest {
     return result;
   }
 
-  bool CreateWaylandWindowWithParams(PlatformWindowType type,
-                                     gfx::AcceleratedWidget parent_widget,
-                                     const gfx::Rect bounds,
-                                     MockPlatformWindowDelegate* delegate,
-                                     std::unique_ptr<WaylandWindow>* window) {
+  std::unique_ptr<WaylandWindow> CreateWaylandWindowWithParams(
+      PlatformWindowType type,
+      gfx::AcceleratedWidget parent_widget,
+      const gfx::Rect bounds,
+      MockPlatformWindowDelegate* delegate) {
     PlatformWindowInitProperties properties;
     // TODO(msisov): use a fancy method to calculate position of a popup window.
     properties.bounds = bounds;
     properties.type = type;
     properties.parent_widget = parent_widget;
 
-    *window = std::make_unique<WaylandWindow>(delegate, connection_.get());
-
-    return (*window)->Initialize(std::move(properties));
+    return WaylandWindow::Create(delegate, connection_.get(),
+                                 std::move(properties));
   }
 
   void InitializeWithSupportedHitTestValues(std::vector<int>* hit_tests) {
@@ -736,27 +735,29 @@ TEST_P(WaylandWindowTest, CanCreateMenuWindow) {
   ASSERT_TRUE(connection_->pointer() && connection_->touch());
   window_->SetPointerFocus(true);
 
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, gfx::kNullAcceleratedWidget,
-      gfx::Rect(0, 0, 10, 10), &menu_window_delegate, &menu_window));
+      gfx::Rect(0, 0, 10, 10), &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   Sync();
 
   window_->SetPointerFocus(false);
   window_->set_touch_focus(false);
 
-  EXPECT_FALSE(CreateWaylandWindowWithParams(
+  menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, gfx::kNullAcceleratedWidget,
-      gfx::Rect(0, 0, 10, 10), &menu_window_delegate, &menu_window));
+      gfx::Rect(0, 0, 10, 10), &menu_window_delegate);
+  EXPECT_FALSE(menu_window);
 
   Sync();
 
   window_->set_touch_focus(true);
 
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, gfx::kNullAcceleratedWidget,
-      gfx::Rect(0, 0, 10, 10), &menu_window_delegate, &menu_window));
+      gfx::Rect(0, 0, 10, 10), &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   Sync();
 }
@@ -767,29 +768,30 @@ TEST_P(WaylandWindowTest, CreateAndDestroyNestedMenuWindow) {
   EXPECT_CALL(menu_window_delegate, OnAcceleratedWidgetAvailable(_))
       .WillOnce(SaveArg<0>(&menu_window_widget));
 
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, widget_, gfx::Rect(0, 0, 10, 10),
-      &menu_window_delegate, &menu_window));
+      &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
   ASSERT_NE(menu_window_widget, gfx::kNullAcceleratedWidget);
 
   Sync();
 
   MockPlatformWindowDelegate nested_menu_window_delegate;
-  std::unique_ptr<WaylandWindow> nested_menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
-      PlatformWindowType::kMenu, menu_window_widget, gfx::Rect(20, 0, 10, 10),
-      &nested_menu_window_delegate, &nested_menu_window));
+  std::unique_ptr<WaylandWindow> nested_menu_window =
+      CreateWaylandWindowWithParams(
+          PlatformWindowType::kMenu, menu_window_widget,
+          gfx::Rect(20, 0, 10, 10), &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 }
 
 TEST_P(WaylandWindowTest, CanDispatchEventToMenuWindowNonNested) {
   MockPlatformWindowDelegate menu_window_delegate;
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, widget_, gfx::Rect(0, 0, 10, 10),
-      &menu_window_delegate, &menu_window));
+      &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   wl_seat_send_capabilities(server_.seat()->resource(),
                             WL_SEAT_CAPABILITY_POINTER);
@@ -812,18 +814,19 @@ TEST_P(WaylandWindowTest, CanDispatchEventToMenuWindowNested) {
   EXPECT_CALL(menu_window_delegate, OnAcceleratedWidgetAvailable(_))
       .WillOnce(SaveArg<0>(&menu_window_widget));
 
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, widget_, gfx::Rect(0, 0, 10, 10),
-      &menu_window_delegate, &menu_window));
+      &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   Sync();
 
   MockPlatformWindowDelegate nested_menu_window_delegate;
-  std::unique_ptr<WaylandWindow> nested_menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
-      PlatformWindowType::kMenu, menu_window_widget, gfx::Rect(20, 0, 10, 10),
-      &nested_menu_window_delegate, &nested_menu_window));
+  std::unique_ptr<WaylandWindow> nested_menu_window =
+      CreateWaylandWindowWithParams(
+          PlatformWindowType::kMenu, menu_window_widget,
+          gfx::Rect(20, 0, 10, 10), &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 
@@ -903,10 +906,10 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   MockPlatformWindowDelegate menu_window_delegate;
   gfx::Rect menu_window_bounds(gfx::Point(440, 76),
                                menu_window_positioner.size);
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, toplevel_window->GetWidget(),
-      menu_window_bounds, &menu_window_delegate, &menu_window));
+      menu_window_bounds, &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   Sync();
 
@@ -924,10 +927,11 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   MockPlatformWindowDelegate nested_menu_window_delegate;
   gfx::Rect nested_menu_window_bounds(gfx::Point(723, 156),
                                       nested_menu_window_positioner.size);
-  std::unique_ptr<WaylandWindow> nested_menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
-      PlatformWindowType::kMenu, menu_window_widget, nested_menu_window_bounds,
-      &nested_menu_window_delegate, &nested_menu_window));
+  std::unique_ptr<WaylandWindow> nested_menu_window =
+      CreateWaylandWindowWithParams(
+          PlatformWindowType::kMenu, menu_window_widget,
+          nested_menu_window_bounds, &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 
@@ -985,9 +989,10 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   // side. Thus, we have to check that anchor rect is correct.
   nested_menu_window.reset();
   nested_menu_window_bounds.set_origin({723, 258});
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  nested_menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, menu_window_widget, nested_menu_window_bounds,
-      &nested_menu_window_delegate, &nested_menu_window));
+      &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 
@@ -1050,9 +1055,10 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   window_->SetBounds(gfx::Rect(0, 0, 2493, 1413));
 
   menu_window_bounds.set_origin({2206, 67});
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, toplevel_window->GetWidget(),
-      menu_window_bounds, &menu_window_delegate, &menu_window));
+      menu_window_bounds, &menu_window_delegate);
+  EXPECT_TRUE(menu_window);
 
   Sync();
 
@@ -1066,9 +1072,10 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
   Sync();
 
   nested_menu_window_bounds.set_origin({1905, 147});
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  nested_menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, menu_window_widget, nested_menu_window_bounds,
-      &nested_menu_window_delegate, &nested_menu_window));
+      &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 
@@ -1096,9 +1103,10 @@ TEST_P(WaylandWindowTest, AdjustPopupBounds) {
 
   nested_menu_window.reset();
 
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  nested_menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, menu_window_widget, nested_menu_window_bounds,
-      &nested_menu_window_delegate, &nested_menu_window));
+      &nested_menu_window_delegate);
+  EXPECT_TRUE(nested_menu_window);
 
   Sync();
 
@@ -1174,10 +1182,10 @@ TEST_P(WaylandWindowTest, TooltipSimpleParent) {
   VerifyAndClearExpectations();
 
   gfx::Rect tooltip_window_bounds(gfx::Point(15, 15), gfx::Size(10, 10));
-  std::unique_ptr<WaylandWindow> tooltip_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> tooltip_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kTooltip, window_->GetWidget(), tooltip_window_bounds,
-      &delegate_, &tooltip_window));
+      &delegate_);
+  EXPECT_TRUE(tooltip_window);
 
   window_->SetPointerFocus(true);
 
@@ -1199,18 +1207,18 @@ TEST_P(WaylandWindowTest, TooltipNestedParent) {
   VerifyAndClearExpectations();
 
   gfx::Rect menu_window_bounds(gfx::Point(10, 10), gfx::Size(100, 100));
-  std::unique_ptr<WaylandWindow> menu_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> menu_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kMenu, window_->GetWidget(), menu_window_bounds,
-      &delegate_, &menu_window));
+      &delegate_);
+  EXPECT_TRUE(menu_window);
 
   VerifyAndClearExpectations();
 
   gfx::Rect tooltip_window_bounds(gfx::Point(15, 15), gfx::Size(10, 10));
-  std::unique_ptr<WaylandWindow> tooltip_window;
-  EXPECT_TRUE(CreateWaylandWindowWithParams(
+  std::unique_ptr<WaylandWindow> tooltip_window = CreateWaylandWindowWithParams(
       PlatformWindowType::kTooltip, menu_window->GetWidget(),
-      tooltip_window_bounds, &delegate_, &tooltip_window));
+      tooltip_window_bounds, &delegate_);
+  EXPECT_TRUE(tooltip_window);
 
   VerifyAndClearExpectations();
 
diff --git a/ui/ozone/platform/wayland/ozone_platform_wayland.cc b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
index 541d9c4848d7..dbf880e9a0c1 100644
--- a/ui/ozone/platform/wayland/ozone_platform_wayland.cc
+++ b/ui/ozone/platform/wayland/ozone_platform_wayland.cc
@@ -107,10 +107,8 @@ class OzonePlatformWayland : public OzonePlatform {
   std::unique_ptr<PlatformWindow> CreatePlatformWindow(
       PlatformWindowDelegate* delegate,
       PlatformWindowInitProperties properties) override {
-    auto window = std::make_unique<WaylandWindow>(delegate, connection_.get());
-    if (!window->Initialize(std::move(properties)))
-      return nullptr;
-    return std::move(window);
+    return WaylandWindow::Create(delegate, connection_.get(),
+                                 std::move(properties));
   }
 
   std::unique_ptr<display::NativeDisplayDelegate> CreateNativeDisplayDelegate()
diff --git a/ui/ozone/platform/wayland/test/wayland_test.cc b/ui/ozone/platform/wayland/test/wayland_test.cc
index 2bd8c38219c1..2543981d8c38 100644
--- a/ui/ozone/platform/wayland/test/wayland_test.cc
+++ b/ui/ozone/platform/wayland/test/wayland_test.cc
@@ -37,7 +37,6 @@ WaylandTest::WaylandTest()
   buffer_manager_gpu_ = std::make_unique<WaylandBufferManagerGpu>();
   surface_factory_ = std::make_unique<WaylandSurfaceFactory>(
       connection_.get(), buffer_manager_gpu_.get());
-  window_ = std::make_unique<WaylandWindow>(&delegate_, connection_.get());
 }
 
 WaylandTest::~WaylandTest() {}
@@ -52,7 +51,8 @@ void WaylandTest::SetUp() {
   PlatformWindowInitProperties properties;
   properties.bounds = gfx::Rect(0, 0, 800, 600);
   properties.type = PlatformWindowType::kWindow;
-  ASSERT_TRUE(window_->Initialize(std::move(properties)));
+  window_ = WaylandWindow::Create(&delegate_, connection_.get(),
+                                  std::move(properties));
   ASSERT_NE(widget_, gfx::kNullAcceleratedWidget);
 
   // Wait for the client to flush all pending requests from initialization.
diff --git a/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc b/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
index 21b0c3eefd9b..767f9354f6da 100644
--- a/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
+++ b/ui/ozone/platform/wayland/wayland_buffer_manager_unittest.cc
@@ -189,12 +189,12 @@ class WaylandBufferManagerTest : public WaylandTest {
 
   std::unique_ptr<WaylandWindow> CreateWindow() {
     testing::Mock::VerifyAndClearExpectations(&delegate_);
-    auto new_window =
-        std::make_unique<WaylandWindow>(&delegate_, connection_.get());
     PlatformWindowInitProperties properties;
     properties.bounds = gfx::Rect(0, 0, 800, 600);
     properties.type = PlatformWindowType::kWindow;
-    EXPECT_TRUE(new_window->Initialize(std::move(properties)));
+    auto new_window = WaylandWindow::Create(&delegate_, connection_.get(),
+                                            std::move(properties));
+    EXPECT_TRUE(new_window);
 
     Sync();
 
-- 
2.24.1

