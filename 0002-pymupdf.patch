diff -ru mupdf-1.17.0-source-orig/include/mupdf/fitz/config.h mupdf-1.17.0-source/include/mupdf/fitz/config.h
--- mupdf-1.17.0-source-orig/include/mupdf/fitz/config.h	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/include/mupdf/fitz/config.h	2020-09-20 12:36:22.644574741 +0800
@@ -2,13 +2,13 @@
 
 #define FZ_CONFIG_H
 
-/**
+/*
 	Enable the following for spot (and hence overprint/overprint
 	simulation) capable rendering. This forces FZ_PLOTTERS_N on.
 */
 /* #define FZ_ENABLE_SPOT_RENDERING 1 */
 
-/**
+/*
 	Choose which plotters we need.
 	By default we build all the plotters in. To avoid building
 	plotters in that aren't needed, define the unwanted
@@ -19,7 +19,7 @@
 /* #define FZ_PLOTTERS_CMYK 1 */
 /* #define FZ_PLOTTERS_N 1 */
 
-/**
+/*
 	Choose which document agents to include.
 	By default all are enabled. To avoid building unwanted
 	ones, define FZ_ENABLE_... to 0.
@@ -32,12 +32,12 @@
 /* #define FZ_ENABLE_HTML 1 */
 /* #define FZ_ENABLE_EPUB 1 */
 
-/**
+/*
 	Choose whether to enable ICC color profiles.
 */
-/* #define FZ_ENABLE_ICC 1 */
+#define FZ_ENABLE_ICC 1
 
-/**
+/*
 	Choose whether to enable JPEG2000 decoding.
 	By default, it is enabled, but due to frequent security
 	issues with the third party libraries we support disabling
@@ -45,14 +45,13 @@
 */
 /* #define FZ_ENABLE_JPX 1 */
 
-/**
+/*
 	Choose whether to enable JavaScript.
-	By default JavaScript is enabled both for mutool and PDF
-	interactivity.
+	By default JavaScript is enabled both for mutool and PDF interactivity.
 */
 /* #define FZ_ENABLE_JS 1 */
 
-/**
+/*
 	Choose which fonts to include.
 	By default we include the base 14 PDF fonts,
 	DroidSansFallback from Android for CJK, and
@@ -61,35 +60,32 @@
 	unwanted fonts.
 */
 /* To avoid all noto fonts except CJK, enable: */
-/* #define TOFU */
+#define TOFU // <=== PyMuPDF: not the complete NOTO!
 
-/* To skip the CJK font, enable: (this implicitly enables TOFU_CJK_EXT
- * and TOFU_CJK_LANG) */
+/* To skip the CJK font, enable: (this implicitly enables TOFU_CJK_EXT and TOFU_CJK_LANG) */
 /* #define TOFU_CJK */
 
-/* To skip CJK Extension A, enable: (this implicitly enables
- * TOFU_CJK_LANG) */
-/* #define TOFU_CJK_EXT */
+/* To skip CJK Extension A, enable: (this implicitly enables TOFU_CJK_LANG) */
+#define TOFU_CJK_EXT // <=== PyMuPDF: causes 1.5 MB extra size
 
 /* To skip CJK language specific fonts, enable: */
-/* #define TOFU_CJK_LANG */
+#define TOFU_CJK_LANG // <=== PyMuPDF
 
 /* To skip the Emoji font, enable: */
-/* #define TOFU_EMOJI */
+#define TOFU_EMOJI // <=== PyMuPDF
 
 /* To skip the ancient/historic scripts, enable: */
-/* #define TOFU_HISTORIC */
+#define TOFU_HISTORIC // <=== PyMuPDF
 
 /* To skip the symbol font, enable: */
-/* #define TOFU_SYMBOL */
+#define TOFU_SYMBOL // <=== PyMuPDF
 
 /* To skip the SIL fonts, enable: */
-/* #define TOFU_SIL */
+// #define TOFU_SIL // <=== PyMuPDF: ok to have it, only small fonts
 
 /* To skip the Base14 fonts, enable: */
 /* #define TOFU_BASE14 */
-/* (You probably really don't want to do that except for measurement
- * purposes!) */
+/* (You probably really don't want to do that except for measurement purposes!) */
 
 /* ---------- DO NOT EDIT ANYTHING UNDER THIS LINE ---------- */
 
diff -ru mupdf-1.17.0-source-orig/include/mupdf/pdf/page.h mupdf-1.17.0-source/include/mupdf/pdf/page.h
--- mupdf-1.17.0-source-orig/include/mupdf/pdf/page.h	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/include/mupdf/pdf/page.h	2020-09-20 12:36:22.651240999 +0800
@@ -114,10 +114,16 @@
 void pdf_filter_page_contents(fz_context *ctx, pdf_document *doc, pdf_page *page, pdf_filter_options *filter);
 void pdf_filter_annot_contents(fz_context *ctx, pdf_document *doc, pdf_annot *annot, pdf_filter_options *filter);
 
+enum {
+	PDF_REDACT_IMAGE_NONE,
+	PDF_REDACT_IMAGE_REMOVE,
+	PDF_REDACT_IMAGE_PIXELS,
+};
+
 typedef struct
 {
-	int no_black_boxes;
-	int keep_images;
+	int black_boxes;
+	int image_method;
 } pdf_redact_options;
 
 int pdf_redact_page(fz_context *ctx, pdf_document *doc, pdf_page *page, pdf_redact_options *opts);
diff -ru mupdf-1.17.0-source-orig/source/fitz/encode-fax.c mupdf-1.17.0-source/source/fitz/encode-fax.c
--- mupdf-1.17.0-source-orig/source/fitz/encode-fax.c	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/source/fitz/encode-fax.c	2020-09-20 12:36:22.647907870 +0800
@@ -120,7 +120,7 @@
 {
 	int a, b;
 
-	if (!line)
+	if (!line || x >= w)
 		return w;
 
 	if (x == -1)
@@ -147,7 +147,7 @@
 static inline int
 find_changing_color(const unsigned char *line, int x, int w, int color)
 {
-	if (!line)
+	if (!line || x >= w)
 		return w;
 	x = find_changing(line, x, w);
 	if (x < w && getbit(line, x) != color)
diff -ru mupdf-1.17.0-source-orig/source/pdf/pdf-clean.c mupdf-1.17.0-source/source/pdf/pdf-clean.c
--- mupdf-1.17.0-source-orig/source/pdf/pdf-clean.c	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/source/pdf/pdf-clean.c	2020-09-20 12:36:22.651240999 +0800
@@ -512,8 +512,8 @@
 			fz_rethrow(ctx);
 	}
 
-	n = pixmap->n + pixmap->s;
-	bpp = pixmap->n + pixmap->s + pixmap->alpha;
+	n = pixmap->n - pixmap->alpha;
+	bpp = pixmap->n;
 	if (fz_colorspace_is_subtractive(ctx, pixmap->colorspace))
 		white = 0;
 	else
@@ -529,7 +529,7 @@
 	{
 		for (x = r.x0; x < r.x1; ++x)
 		{
-			unsigned char *s = &pixmap->samples[y * pixmap->stride + x * bpp];
+			unsigned char *s = &pixmap->samples[(size_t)y * pixmap->stride + (size_t)x * bpp];
 			for (k = 0; k < n; ++k)
 				s[k] = white;
 			if (pixmap->alpha)
@@ -541,7 +541,51 @@
 }
 
 static fz_image *
-pdf_redact_image_filter(fz_context *ctx, void *opaque, fz_matrix ctm, const char *name, fz_image *image)
+pdf_redact_image_filter_remove(fz_context *ctx, void *opaque, fz_matrix ctm, const char *name, fz_image *image)
+{
+	fz_pixmap *redacted = NULL;
+	pdf_page *page = opaque;
+	pdf_annot *annot;
+	pdf_obj *qp;
+	fz_rect area;
+	fz_rect r;
+	int i, n;
+
+	fz_var(redacted);
+
+	area = fz_transform_rect(fz_unit_rect, ctm);
+
+	for (annot = pdf_first_annot(ctx, page); annot; annot = pdf_next_annot(ctx, annot))
+	{
+		if (pdf_dict_get(ctx, annot->obj, PDF_NAME(Subtype)) == PDF_NAME(Redact))
+		{
+			qp = pdf_dict_get(ctx, annot->obj, PDF_NAME(QuadPoints));
+			n = pdf_array_len(ctx, qp);
+			if (n > 0)
+			{
+				for (i = 0; i < n; i += 8)
+				{
+					r = fz_rect_from_quad(pdf_to_quad(ctx, qp, i));
+					r = fz_intersect_rect(r, area);
+					if (!fz_is_empty_rect(r))
+						return NULL;
+				}
+			}
+			else
+			{
+				r = pdf_dict_get_rect(ctx, annot->obj, PDF_NAME(Rect));
+				r = fz_intersect_rect(r, area);
+				if (!fz_is_empty_rect(r))
+					return NULL;
+			}
+		}
+	}
+
+	return fz_keep_image(ctx, image);
+}
+
+static fz_image *
+pdf_redact_image_filter_pixels(fz_context *ctx, void *opaque, fz_matrix ctm, const char *name, fz_image *image)
 {
 	fz_pixmap *redacted = NULL;
 	pdf_page *page = opaque;
@@ -697,23 +741,25 @@
 {
 	pdf_annot *annot;
 	int has_redactions = 0;
-	int no_black_boxes = 0;
-	int keep_images = 0;
+	int black_boxes = 0;
+	int image_method = PDF_REDACT_IMAGE_PIXELS;
 
 	pdf_filter_options filter;
 
 	if (opts)
 	{
-		no_black_boxes = opts->no_black_boxes;
-		keep_images = opts->keep_images;
+		black_boxes = opts->black_boxes;
+		image_method = opts->image_method;
 	}
 
 	memset(&filter, 0, sizeof filter);
 	filter.opaque = page;
 	filter.text_filter = pdf_redact_text_filter;
-	if (!keep_images)
-		filter.image_filter = pdf_redact_image_filter;
-	if (!no_black_boxes)
+	if (image_method == PDF_REDACT_IMAGE_PIXELS)
+		filter.image_filter = pdf_redact_image_filter_pixels;
+	if (image_method == PDF_REDACT_IMAGE_REMOVE)
+		filter.image_filter = pdf_redact_image_filter_remove;
+	if (black_boxes)
 		filter.end_page = pdf_redact_end_page;
 	filter.recurse = 0; /* don't redact patterns, softmasks, and type3 fonts */
 	filter.instance_forms = 1; /* redact xobjects with instancing */
diff -ru mupdf-1.17.0-source-orig/source/pdf/pdf-font-add.c mupdf-1.17.0-source/source/pdf/pdf-font-add.c
--- mupdf-1.17.0-source-orig/source/pdf/pdf-font-add.c	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/source/pdf/pdf-font-add.c	2020-09-20 12:36:22.647907870 +0800
@@ -21,10 +21,14 @@
 #else
 	const char *kind = FT_Get_X11_Font_Format(face);
 #endif
-	if (!strcmp(kind, "TrueType")) return 2;
-	if (!strcmp(kind, "Type 1")) return 1;
-	if (!strcmp(kind, "CFF")) return 3;
-	if (!strcmp(kind, "CID Type 1")) return 1;
+	if (!strcmp(kind, "TrueType"))
+		return 2;
+	if (!strcmp(kind, "Type 1"))
+		return 1;
+	if (!strcmp(kind, "CFF"))
+		return 3;
+	if (!strcmp(kind, "CID Type 1"))
+		return 1;
 	return 0;
 }
 
@@ -54,7 +58,7 @@
 	return fz_lookup_base14_font(ctx, pdf_clean_font_name(font->name), &size) == data;
 }
 
-static pdf_obj*
+static pdf_obj *
 pdf_add_font_file(fz_context *ctx, pdf_document *doc, fz_font *font)
 {
 	fz_buffer *buf = font->buffer;
@@ -136,9 +140,15 @@
 			switch (ft_font_file_kind(face))
 			{
 			default:
-			case 1: pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile), fileref); break;
-			case 2: pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile2), fileref); break;
-			case 3: pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile3), fileref); break;
+			case 1:
+				pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile), fileref);
+				break;
+			case 2:
+				pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile2), fileref);
+				break;
+			case 3:
+				pdf_dict_put_drop(ctx, fdobj, PDF_NAME(FontFile3), fileref);
+				break;
 			}
 		}
 
@@ -151,7 +161,7 @@
 }
 
 static void
-pdf_add_simple_font_widths(fz_context *ctx, pdf_document *doc, pdf_obj *fobj, fz_font *font, const char * const encoding[])
+pdf_add_simple_font_widths(fz_context *ctx, pdf_document *doc, pdf_obj *fobj, fz_font *font, const char *const encoding[])
 {
 	int width_table[256];
 	pdf_obj *widths;
@@ -196,7 +206,12 @@
 }
 
 /* Different states of starting, same width as last, or consecutive glyph */
-enum { FW_START, FW_SAME, FW_RUN };
+enum
+{
+	FW_START,
+	FW_SAME,
+	FW_RUN
+};
 
 /* ToDo: Ignore the default sized characters */
 static void
@@ -329,7 +344,7 @@
 }
 
 /* Descendant font construction used for CID font creation from ttf or Adobe type1 */
-static pdf_obj*
+static pdf_obj *
 pdf_add_descendant_cid_font(fz_context *ctx, pdf_document *doc, fz_font *font)
 {
 	FT_Face face = font->ft_face;
@@ -372,9 +387,9 @@
 	int n;
 	for (n = 1; k + n < size; ++n)
 	{
-		if ((k & 0xFF00) != ((k+n) & 0xFF00)) /* high byte changes */
+		if ((k & 0xFF00) != ((k + n) & 0xFF00)) /* high byte changes */
 			break;
-		if (table[k] + n != table[k+n])
+		if (table[k] + n != table[k + n])
 			break;
 	}
 	return n;
@@ -474,7 +489,7 @@
 							fz_append_printf(ctx, buf, "%d beginbfrange\n", num_seq);
 						count = 0;
 					}
-					fz_append_printf(ctx, buf, "<%04x> <%04x> <%04x>\n", k, k+n-1, table[k]);
+					fz_append_printf(ctx, buf, "<%04x> <%04x> <%04x>\n", k, k + n - 1, table[k]);
 					++count;
 				}
 			}
@@ -582,7 +597,7 @@
 		const char *glyph = glyph_names[i];
 		if (glyph)
 		{
-			if (last != i-1)
+			if (last != i - 1)
 				pdf_array_push_int(ctx, diff, i);
 			last = i;
 			pdf_array_push_name(ctx, diff, glyph);
@@ -624,9 +639,15 @@
 	switch (encoding)
 	{
 	default:
-	case PDF_SIMPLE_ENCODING_LATIN: enc = fz_glyph_name_from_windows_1252; break;
-	case PDF_SIMPLE_ENCODING_GREEK: enc = fz_glyph_name_from_iso8859_7; break;
-	case PDF_SIMPLE_ENCODING_CYRILLIC: enc = fz_glyph_name_from_koi8u; break;
+	case PDF_SIMPLE_ENCODING_LATIN:
+		enc = fz_glyph_name_from_windows_1252;
+		break;
+	case PDF_SIMPLE_ENCODING_GREEK:
+		enc = fz_glyph_name_from_iso8859_7;
+		break;
+	case PDF_SIMPLE_ENCODING_CYRILLIC:
+		enc = fz_glyph_name_from_koi8u;
+		break;
 	}
 
 	fobj = pdf_add_new_dict(ctx, doc, 10);
@@ -667,8 +688,7 @@
 	return fref;
 }
 
-int
-pdf_font_writing_supported(fz_font *font)
+int pdf_font_writing_supported(fz_font *font)
 {
 	if (font->ft_face == NULL || font->buffer == NULL || font->buffer->len < 4)
 		return 0;
@@ -686,7 +706,7 @@
 {
 	pdf_obj *fref, *font, *subfont, *fontdesc;
 	pdf_obj *dfonts;
-	fz_rect bbox = { -200, -200, 1200, 1200 };
+	fz_rect bbox = {-200, -200, 1200, 1200};
 	unsigned char digest[16];
 	int flags;
 
@@ -769,3 +789,21 @@
 
 	return fref;
 }
+
+void jm_valid_chars(fz_context *ctx, fz_font *font, void *arr)
+{
+	FT_Face face = font->ft_face;
+	FT_ULong ucs;
+	FT_UInt gid;
+	long *table = (long *)arr;
+	fz_lock(ctx, FZ_LOCK_FREETYPE);
+	ucs = FT_Get_First_Char(face, &gid);
+	while (gid > 0)
+	{
+		if (gid < (FT_ULong)face->num_glyphs && face->num_glyphs > 0)
+			table[gid] = (long)ucs;
+		ucs = FT_Get_Next_Char(face, ucs, &gid);
+	}
+	fz_unlock(ctx, FZ_LOCK_FREETYPE);
+	return;
+}
diff -ru mupdf-1.17.0-source-orig/source/tools/murun.c mupdf-1.17.0-source/source/tools/murun.c
--- mupdf-1.17.0-source-orig/source/tools/murun.c	2020-05-05 19:29:09.000000000 +0800
+++ mupdf-1.17.0-source/source/tools/murun.c	2020-09-20 12:36:22.647907870 +0800
@@ -33,18 +33,21 @@
 
 static int eval_print(js_State *J, const char *source)
 {
-	if (js_ploadstring(J, "[string]", source)) {
+	if (js_ploadstring(J, "[string]", source))
+	{
 		fprintf(stderr, "%s\n", js_trystring(J, -1, "Error"));
 		js_pop(J, 1);
 		return 1;
 	}
 	js_pushundefined(J);
-	if (js_pcall(J, 0)) {
+	if (js_pcall(J, 0))
+	{
 		fprintf(stderr, "%s\n", js_trystring(J, -1, "Error"));
 		js_pop(J, 1);
 		return 1;
 	}
-	if (js_isdefined(J, -1)) {
+	if (js_isdefined(J, -1))
+	{
 		printf("%s\n", js_tryrepr(J, -1, "can't convert to string"));
 	}
 	js_pop(J, 1);
@@ -85,9 +88,11 @@
 static void jsB_print(js_State *J)
 {
 	unsigned int i, top = js_gettop(J);
-	for (i = 1; i < top; ++i) {
+	for (i = 1; i < top; ++i)
+	{
 		const char *s = js_tostring(J, i);
-		if (i > 1) putchar(' ');
+		if (i > 1)
+			putchar(' ');
 		fputs(s, stdout);
 	}
 	putchar('\n');
@@ -97,9 +102,11 @@
 static void jsB_write(js_State *J)
 {
 	unsigned int i, top = js_gettop(J);
-	for (i = 1; i < top; ++i) {
+	for (i = 1; i < top; ++i)
+	{
 		const char *s = js_tostring(J, i);
-		if (i > 1) putchar(' ');
+		if (i > 1)
+			putchar(' ');
 		fputs(s, stdout);
 	}
 	js_pushundefined(J);
@@ -115,34 +122,40 @@
 	size_t t;
 
 	f = fopen(filename, "rb");
-	if (!f) {
+	if (!f)
+	{
 		js_error(J, "cannot open file: '%s'", filename);
 	}
 
-	if (fseek(f, 0, SEEK_END) < 0) {
+	if (fseek(f, 0, SEEK_END) < 0)
+	{
 		fclose(f);
 		js_error(J, "cannot seek in file: '%s'", filename);
 	}
 
 	n = ftell(f);
-	if (n < 0) {
+	if (n < 0)
+	{
 		fclose(f);
 		js_error(J, "cannot tell in file: '%s'", filename);
 	}
 
-	if (fseek(f, 0, SEEK_SET) < 0) {
+	if (fseek(f, 0, SEEK_SET) < 0)
+	{
 		fclose(f);
 		js_error(J, "cannot seek in file: '%s'", filename);
 	}
 
 	s = fz_malloc(ctx, n + 1);
-	if (!s) {
+	if (!s)
+	{
 		fclose(f);
 		js_error(J, "cannot allocate storage for file contents: '%s'", filename);
 	}
 
 	t = fread(s, 1, n, f);
-	if (t != (size_t) n) {
+	if (t != (size_t)n)
+	{
 		fz_free(ctx, s);
 		fclose(f);
 		js_error(J, "cannot read data from file: '%s'", filename);
@@ -161,8 +174,8 @@
 	if (!fgets(line, sizeof line, stdin))
 		js_error(J, "cannot read line from stdin");
 	n = strlen(line);
-	if (n > 0 && line[n-1] == '\n')
-		line[n-1] = 0;
+	if (n > 0 && line[n - 1] == '\n')
+		line[n - 1] = 0;
 	js_pushstring(J, line);
 }
 
@@ -185,15 +198,13 @@
 	"Function('exports', read(name+'.js'))(exports);\n"
 	"return exports;\n"
 	"}\n"
-	"require.cache = Object.create(null);\n"
-;
+	"require.cache = Object.create(null);\n";
 
 static const char *stacktrace_js =
 	"Error.prototype.toString = function() {\n"
 	"if (this.stackTrace) return this.name + ': ' + this.message + this.stackTrace;\n"
 	"return this.name + ': ' + this.message;\n"
-	"};\n"
-;
+	"};\n";
 
 /* destructors */
 
@@ -335,10 +346,13 @@
 {
 	fz_context *ctx = js_getcontext(J);
 	pdf_document *pdocument = pdf_document_from_fz_document(ctx, document);
-	if (pdocument) {
+	if (pdocument)
+	{
 		js_getregistry(J, "pdf_document");
 		js_newuserdata(J, "pdf_document", document, ffi_gc_fz_document);
-	} else {
+	}
+	else
+	{
 		js_getregistry(J, "fz_document");
 		js_newuserdata(J, "fz_document", document, ffi_gc_fz_document);
 	}
@@ -361,10 +375,13 @@
 {
 	fz_context *ctx = js_getcontext(J);
 	pdf_page *ppage = pdf_page_from_fz_page(ctx, page);
-	if (ppage) {
+	if (ppage)
+	{
 		js_getregistry(J, "pdf_page");
 		js_newuserdata(J, "pdf_page", page, ffi_gc_fz_page);
-	} else {
+	}
+	else
+	{
 		js_getregistry(J, "fz_page");
 		js_newuserdata(J, "fz_page", page, ffi_gc_fz_page);
 	}
@@ -398,7 +415,8 @@
 
 /* type conversions */
 
-struct color {
+struct color
+{
 	fz_colorspace *colorspace;
 	float color[FZ_MAX_COLORS];
 	float alpha;
@@ -409,12 +427,24 @@
 	if (js_iscoercible(J, idx))
 	{
 		fz_matrix matrix;
-		js_getindex(J, idx, 0); matrix.a = js_tonumber(J, -1); js_pop(J, 1);
-		js_getindex(J, idx, 1); matrix.b = js_tonumber(J, -1); js_pop(J, 1);
-		js_getindex(J, idx, 2); matrix.c = js_tonumber(J, -1); js_pop(J, 1);
-		js_getindex(J, idx, 3); matrix.d = js_tonumber(J, -1); js_pop(J, 1);
-		js_getindex(J, idx, 4); matrix.e = js_tonumber(J, -1); js_pop(J, 1);
-		js_getindex(J, idx, 5); matrix.f = js_tonumber(J, -1); js_pop(J, 1);
+		js_getindex(J, idx, 0);
+		matrix.a = js_tonumber(J, -1);
+		js_pop(J, 1);
+		js_getindex(J, idx, 1);
+		matrix.b = js_tonumber(J, -1);
+		js_pop(J, 1);
+		js_getindex(J, idx, 2);
+		matrix.c = js_tonumber(J, -1);
+		js_pop(J, 1);
+		js_getindex(J, idx, 3);
+		matrix.d = js_tonumber(J, -1);
+		js_pop(J, 1);
+		js_getindex(J, idx, 4);
+		matrix.e = js_tonumber(J, -1);
+		js_pop(J, 1);
+		js_getindex(J, idx, 5);
+		matrix.f = js_tonumber(J, -1);
+		js_pop(J, 1);
 		return matrix;
 	}
 	return fz_identity;
@@ -423,82 +453,138 @@
 static void ffi_pushmatrix(js_State *J, fz_matrix matrix)
 {
 	js_newarray(J);
-	js_pushnumber(J, matrix.a); js_setindex(J, -2, 0);
-	js_pushnumber(J, matrix.b); js_setindex(J, -2, 1);
-	js_pushnumber(J, matrix.c); js_setindex(J, -2, 2);
-	js_pushnumber(J, matrix.d); js_setindex(J, -2, 3);
-	js_pushnumber(J, matrix.e); js_setindex(J, -2, 4);
-	js_pushnumber(J, matrix.f); js_setindex(J, -2, 5);
+	js_pushnumber(J, matrix.a);
+	js_setindex(J, -2, 0);
+	js_pushnumber(J, matrix.b);
+	js_setindex(J, -2, 1);
+	js_pushnumber(J, matrix.c);
+	js_setindex(J, -2, 2);
+	js_pushnumber(J, matrix.d);
+	js_setindex(J, -2, 3);
+	js_pushnumber(J, matrix.e);
+	js_setindex(J, -2, 4);
+	js_pushnumber(J, matrix.f);
+	js_setindex(J, -2, 5);
 }
 
 static fz_point ffi_topoint(js_State *J, int idx)
 {
 	fz_point point;
-	js_getindex(J, idx, 0); point.x = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 1); point.y = js_tonumber(J, -1); js_pop(J, 1);
+	js_getindex(J, idx, 0);
+	point.x = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 1);
+	point.y = js_tonumber(J, -1);
+	js_pop(J, 1);
 	return point;
 }
 
 static void ffi_pushpoint(js_State *J, fz_point point)
 {
 	js_newarray(J);
-	js_pushnumber(J, point.x); js_setindex(J, -2, 0);
-	js_pushnumber(J, point.y); js_setindex(J, -2, 1);
+	js_pushnumber(J, point.x);
+	js_setindex(J, -2, 0);
+	js_pushnumber(J, point.y);
+	js_setindex(J, -2, 1);
 }
 
 static fz_rect ffi_torect(js_State *J, int idx)
 {
 	fz_rect rect;
-	js_getindex(J, idx, 0); rect.x0 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 1); rect.y0 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 2); rect.x1 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 3); rect.y1 = js_tonumber(J, -1); js_pop(J, 1);
+	js_getindex(J, idx, 0);
+	rect.x0 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 1);
+	rect.y0 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 2);
+	rect.x1 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 3);
+	rect.y1 = js_tonumber(J, -1);
+	js_pop(J, 1);
 	return rect;
 }
 
 static void ffi_pushrect(js_State *J, fz_rect rect)
 {
 	js_newarray(J);
-	js_pushnumber(J, rect.x0); js_setindex(J, -2, 0);
-	js_pushnumber(J, rect.y0); js_setindex(J, -2, 1);
-	js_pushnumber(J, rect.x1); js_setindex(J, -2, 2);
-	js_pushnumber(J, rect.y1); js_setindex(J, -2, 3);
+	js_pushnumber(J, rect.x0);
+	js_setindex(J, -2, 0);
+	js_pushnumber(J, rect.y0);
+	js_setindex(J, -2, 1);
+	js_pushnumber(J, rect.x1);
+	js_setindex(J, -2, 2);
+	js_pushnumber(J, rect.y1);
+	js_setindex(J, -2, 3);
 }
 
 static fz_quad ffi_toquad(js_State *J, int idx)
 {
 	fz_quad quad;
-	js_getindex(J, idx, 0); quad.ul.x = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 1); quad.ul.y = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 2); quad.ur.x = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 3); quad.ur.y = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 4); quad.ll.x = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 5); quad.ll.y = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 6); quad.lr.x = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 7); quad.lr.y = js_tonumber(J, -1); js_pop(J, 1);
+	js_getindex(J, idx, 0);
+	quad.ul.x = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 1);
+	quad.ul.y = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 2);
+	quad.ur.x = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 3);
+	quad.ur.y = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 4);
+	quad.ll.x = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 5);
+	quad.ll.y = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 6);
+	quad.lr.x = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 7);
+	quad.lr.y = js_tonumber(J, -1);
+	js_pop(J, 1);
 	return quad;
 }
 
 static void ffi_pushquad(js_State *J, fz_quad quad)
 {
 	js_newarray(J);
-	js_pushnumber(J, quad.ul.x); js_setindex(J, -2, 0);
-	js_pushnumber(J, quad.ul.y); js_setindex(J, -2, 1);
-	js_pushnumber(J, quad.ur.x); js_setindex(J, -2, 2);
-	js_pushnumber(J, quad.ur.y); js_setindex(J, -2, 3);
-	js_pushnumber(J, quad.ll.x); js_setindex(J, -2, 4);
-	js_pushnumber(J, quad.ll.y); js_setindex(J, -2, 5);
-	js_pushnumber(J, quad.lr.x); js_setindex(J, -2, 6);
-	js_pushnumber(J, quad.lr.y); js_setindex(J, -2, 7);
+	js_pushnumber(J, quad.ul.x);
+	js_setindex(J, -2, 0);
+	js_pushnumber(J, quad.ul.y);
+	js_setindex(J, -2, 1);
+	js_pushnumber(J, quad.ur.x);
+	js_setindex(J, -2, 2);
+	js_pushnumber(J, quad.ur.y);
+	js_setindex(J, -2, 3);
+	js_pushnumber(J, quad.ll.x);
+	js_setindex(J, -2, 4);
+	js_pushnumber(J, quad.ll.y);
+	js_setindex(J, -2, 5);
+	js_pushnumber(J, quad.lr.x);
+	js_setindex(J, -2, 6);
+	js_pushnumber(J, quad.lr.y);
+	js_setindex(J, -2, 7);
 }
 
 static fz_irect ffi_toirect(js_State *J, int idx)
 {
 	fz_irect irect;
-	js_getindex(J, idx, 0); irect.x0 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 1); irect.y0 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 2); irect.x1 = js_tonumber(J, -1); js_pop(J, 1);
-	js_getindex(J, idx, 3); irect.y1 = js_tonumber(J, -1); js_pop(J, 1);
+	js_getindex(J, idx, 0);
+	irect.x0 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 1);
+	irect.y0 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 2);
+	irect.x1 = js_tonumber(J, -1);
+	js_pop(J, 1);
+	js_getindex(J, idx, 3);
+	irect.y1 = js_tonumber(J, -1);
+	js_pop(J, 1);
 	return irect;
 }
 
@@ -506,7 +592,8 @@
 {
 	int i;
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_pushnumber(J, v[i]);
 		js_setindex(J, -2, i);
 	}
@@ -523,7 +610,8 @@
 		js_getregistry(J, "DeviceGray");
 	else if (colorspace == fz_device_cmyk(ctx))
 		js_getregistry(J, "DeviceCMYK");
-	else {
+	else
+	{
 		js_getregistry(J, "fz_colorspace");
 		js_newuserdata(J, "fz_colorspace", fz_keep_colorspace(ctx, colorspace), ffi_gc_fz_colorspace);
 	}
@@ -532,10 +620,13 @@
 static void ffi_pushcolor(js_State *J, fz_colorspace *colorspace, const float *color, float alpha)
 {
 	fz_context *ctx = js_getcontext(J);
-	if (colorspace) {
+	if (colorspace)
+	{
 		ffi_pushcolorspace(J, colorspace);
 		ffi_pusharray(J, color, fz_colorspace_n(ctx, colorspace));
-	} else {
+	}
+	else
+	{
 		js_pushnull(J);
 		js_pushnull(J);
 	}
@@ -548,9 +639,11 @@
 	int n, i;
 	fz_context *ctx = js_getcontext(J);
 	c.colorspace = js_touserdata(J, idx, "fz_colorspace");
-	if (c.colorspace) {
+	if (c.colorspace)
+	{
 		n = fz_colorspace_n(ctx, c.colorspace);
-		for (i=0; i < n; ++i) {
+		for (i = 0; i < n; ++i)
+		{
 			js_getindex(J, idx + 1, i);
 			c.color[i] = js_tonumber(J, -1);
 			js_pop(J, 1);
@@ -574,39 +667,55 @@
 
 static const char *string_from_cap(fz_linecap cap)
 {
-	switch (cap) {
+	switch (cap)
+	{
 	default:
-	case FZ_LINECAP_BUTT: return "Butt";
-	case FZ_LINECAP_ROUND: return "Round";
-	case FZ_LINECAP_SQUARE: return "Square";
-	case FZ_LINECAP_TRIANGLE: return "Triangle";
+	case FZ_LINECAP_BUTT:
+		return "Butt";
+	case FZ_LINECAP_ROUND:
+		return "Round";
+	case FZ_LINECAP_SQUARE:
+		return "Square";
+	case FZ_LINECAP_TRIANGLE:
+		return "Triangle";
 	}
 }
 
 static const char *string_from_join(fz_linejoin join)
 {
-	switch (join) {
+	switch (join)
+	{
 	default:
-	case FZ_LINEJOIN_MITER: return "Miter";
-	case FZ_LINEJOIN_ROUND: return "Round";
-	case FZ_LINEJOIN_BEVEL: return "Bevel";
-	case FZ_LINEJOIN_MITER_XPS: return "MiterXPS";
+	case FZ_LINEJOIN_MITER:
+		return "Miter";
+	case FZ_LINEJOIN_ROUND:
+		return "Round";
+	case FZ_LINEJOIN_BEVEL:
+		return "Bevel";
+	case FZ_LINEJOIN_MITER_XPS:
+		return "MiterXPS";
 	}
 }
 
 static fz_linecap cap_from_string(const char *str)
 {
-	if (!strcmp(str, "Round")) return FZ_LINECAP_ROUND;
-	if (!strcmp(str, "Square")) return FZ_LINECAP_SQUARE;
-	if (!strcmp(str, "Triangle")) return FZ_LINECAP_TRIANGLE;
+	if (!strcmp(str, "Round"))
+		return FZ_LINECAP_ROUND;
+	if (!strcmp(str, "Square"))
+		return FZ_LINECAP_SQUARE;
+	if (!strcmp(str, "Triangle"))
+		return FZ_LINECAP_TRIANGLE;
 	return FZ_LINECAP_BUTT;
 }
 
 static fz_linejoin join_from_string(const char *str)
 {
-	if (!strcmp(str, "Round")) return FZ_LINEJOIN_ROUND;
-	if (!strcmp(str, "Bevel")) return FZ_LINEJOIN_BEVEL;
-	if (!strcmp(str, "MiterXPS")) return FZ_LINEJOIN_MITER_XPS;
+	if (!strcmp(str, "Round"))
+		return FZ_LINEJOIN_ROUND;
+	if (!strcmp(str, "Bevel"))
+		return FZ_LINEJOIN_BEVEL;
+	if (!strcmp(str, "MiterXPS"))
+		return FZ_LINEJOIN_MITER_XPS;
 	return FZ_LINEJOIN_MITER;
 }
 
@@ -634,45 +743,55 @@
 static fz_stroke_state ffi_tostroke(js_State *J, int idx)
 {
 	fz_stroke_state stroke = fz_default_stroke_state;
-	if (js_hasproperty(J, idx, "lineCap")) {
+	if (js_hasproperty(J, idx, "lineCap"))
+	{
 		stroke.start_cap = cap_from_string(js_tostring(J, -1));
 		stroke.dash_cap = stroke.start_cap;
 		stroke.end_cap = stroke.start_cap;
 	}
-	if (js_hasproperty(J, idx, "startCap")) {
+	if (js_hasproperty(J, idx, "startCap"))
+	{
 		stroke.start_cap = cap_from_string(js_tostring(J, -1));
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "dashCap")) {
+	if (js_hasproperty(J, idx, "dashCap"))
+	{
 		stroke.dash_cap = cap_from_string(js_tostring(J, -1));
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "endCap")) {
+	if (js_hasproperty(J, idx, "endCap"))
+	{
 		stroke.end_cap = cap_from_string(js_tostring(J, -1));
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "lineJoin")) {
+	if (js_hasproperty(J, idx, "lineJoin"))
+	{
 		stroke.linejoin = join_from_string(js_tostring(J, -1));
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "lineWidth")) {
+	if (js_hasproperty(J, idx, "lineWidth"))
+	{
 		stroke.linewidth = js_tonumber(J, -1);
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "miterLimit")) {
+	if (js_hasproperty(J, idx, "miterLimit"))
+	{
 		stroke.miterlimit = js_tonumber(J, -1);
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "dashPhase")) {
+	if (js_hasproperty(J, idx, "dashPhase"))
+	{
 		stroke.dash_phase = js_tonumber(J, -1);
 		js_pop(J, 1);
 	}
-	if (js_hasproperty(J, idx, "dashes")) {
+	if (js_hasproperty(J, idx, "dashes"))
+	{
 		int i, n = js_getlength(J, -1);
 		if (n > (int)nelem(stroke.dash_list))
 			n = nelem(stroke.dash_list);
 		stroke.dash_len = n;
-		for (i = 0; i < n; ++i) {
+		for (i = 0; i < n; ++i)
+		{
 			js_getindex(J, -1, i);
 			stroke.dash_list[i] = js_tonumber(J, -1);
 			js_pop(J, 1);
@@ -735,13 +854,15 @@
 	int idx;
 	unsigned char *data;
 	size_t len = fz_buffer_storage(js_getcontext(J), buf, &data);
-	if (is_number(key, &idx)) {
+	if (is_number(key, &idx))
+	{
 		if (idx < 0 || (size_t)idx >= len)
 			js_rangeerror(J, "index out of bounds");
 		js_pushnumber(J, data[idx]);
 		return 1;
 	}
-	if (!strcmp(key, "length")) {
+	if (!strcmp(key, "length"))
+	{
 		js_pushnumber(J, len);
 		return 1;
 	}
@@ -754,7 +875,8 @@
 	int idx;
 	unsigned char *data;
 	size_t len = fz_buffer_storage(js_getcontext(J), buf, &data);
-	if (is_number(key, &idx)) {
+	if (is_number(key, &idx))
+	{
 		if (idx < 0 || (size_t)idx >= len)
 			js_rangeerror(J, "index out of bounds");
 		data[idx] = js_tonumber(J, -1);
@@ -769,8 +891,8 @@
 {
 	js_getregistry(J, "fz_buffer");
 	js_newuserdatax(J, "fz_buffer", buf,
-			ffi_buffer_has, ffi_buffer_put, NULL,
-			ffi_gc_fz_buffer);
+					ffi_buffer_has, ffi_buffer_put, NULL,
+					ffi_gc_fz_buffer);
 }
 
 #if FZ_ENABLE_PDF
@@ -782,7 +904,8 @@
 
 	if (js_isuserdata(J, idx, "fz_buffer"))
 		buf = fz_keep_buffer(ctx, js_touserdata(J, idx, "fz_buffer"));
-	else {
+	else
+	{
 		const char *str = js_tostring(J, idx);
 		fz_try(ctx)
 			buf = fz_new_buffer_from_copied_data(ctx, (const unsigned char *)str, strlen(str));
@@ -805,12 +928,13 @@
 
 static void
 js_dev_fill_path(fz_context *ctx, fz_device *dev, const fz_path *path, int even_odd, fz_matrix ctm,
-	fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
+				 fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "fillPath")) {
+	if (js_hasproperty(J, -1, "fillPath"))
+	{
 		js_copy(J, -2);
 		ffi_pushpath(J, path);
 		js_pushboolean(J, even_odd);
@@ -825,12 +949,13 @@
 
 static void
 js_dev_clip_path(fz_context *ctx, fz_device *dev, const fz_path *path, int even_odd, fz_matrix ctm,
-	fz_rect scissor)
+				 fz_rect scissor)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "clipPath")) {
+	if (js_hasproperty(J, -1, "clipPath"))
+	{
 		js_copy(J, -2);
 		ffi_pushpath(J, path);
 		js_pushboolean(J, even_odd);
@@ -843,13 +968,14 @@
 
 static void
 js_dev_stroke_path(fz_context *ctx, fz_device *dev, const fz_path *path,
-	const fz_stroke_state *stroke, fz_matrix ctm,
-	fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
+				   const fz_stroke_state *stroke, fz_matrix ctm,
+				   fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "strokePath")) {
+	if (js_hasproperty(J, -1, "strokePath"))
+	{
 		js_copy(J, -2);
 		ffi_pushpath(J, path);
 		ffi_pushstroke(J, stroke);
@@ -864,12 +990,13 @@
 
 static void
 js_dev_clip_stroke_path(fz_context *ctx, fz_device *dev, const fz_path *path, const fz_stroke_state *stroke,
-	fz_matrix ctm, fz_rect scissor)
+						fz_matrix ctm, fz_rect scissor)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "clipStrokePath")) {
+	if (js_hasproperty(J, -1, "clipStrokePath"))
+	{
 		js_copy(J, -2);
 		ffi_pushpath(J, path);
 		ffi_pushstroke(J, stroke);
@@ -882,12 +1009,13 @@
 
 static void
 js_dev_fill_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm,
-	fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
+				 fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "fillText")) {
+	if (js_hasproperty(J, -1, "fillText"))
+	{
 		js_copy(J, -2);
 		ffi_pushtext(J, text);
 		ffi_pushmatrix(J, ctm);
@@ -901,12 +1029,13 @@
 
 static void
 js_dev_stroke_text(fz_context *ctx, fz_device *dev, const fz_text *text, const fz_stroke_state *stroke,
-	fz_matrix ctm, fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
+				   fz_matrix ctm, fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "strokeText")) {
+	if (js_hasproperty(J, -1, "strokeText"))
+	{
 		js_copy(J, -2);
 		ffi_pushtext(J, text);
 		ffi_pushstroke(J, stroke);
@@ -922,10 +1051,11 @@
 static void
 js_dev_clip_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm, fz_rect scissor)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "clipText")) {
+	if (js_hasproperty(J, -1, "clipText"))
+	{
 		js_copy(J, -2);
 		ffi_pushtext(J, text);
 		ffi_pushmatrix(J, ctm);
@@ -937,12 +1067,13 @@
 
 static void
 js_dev_clip_stroke_text(fz_context *ctx, fz_device *dev, const fz_text *text, const fz_stroke_state *stroke,
-	fz_matrix ctm, fz_rect scissor)
+						fz_matrix ctm, fz_rect scissor)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "clipStrokeText")) {
+	if (js_hasproperty(J, -1, "clipStrokeText"))
+	{
 		js_copy(J, -2);
 		ffi_pushtext(J, text);
 		ffi_pushstroke(J, stroke);
@@ -956,10 +1087,11 @@
 static void
 js_dev_ignore_text(fz_context *ctx, fz_device *dev, const fz_text *text, fz_matrix ctm)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "ignoreText")) {
+	if (js_hasproperty(J, -1, "ignoreText"))
+	{
 		js_copy(J, -2);
 		ffi_pushtext(J, text);
 		ffi_pushmatrix(J, ctm);
@@ -972,10 +1104,11 @@
 static void
 js_dev_fill_shade(fz_context *ctx, fz_device *dev, fz_shade *shade, fz_matrix ctm, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "fillShade")) {
+	if (js_hasproperty(J, -1, "fillShade"))
+	{
 		js_copy(J, -2);
 		ffi_pushshade(J, shade);
 		ffi_pushmatrix(J, ctm);
@@ -990,10 +1123,11 @@
 static void
 js_dev_fill_image(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "fillImage")) {
+	if (js_hasproperty(J, -1, "fillImage"))
+	{
 		js_copy(J, -2);
 		ffi_pushimage(J, image);
 		ffi_pushmatrix(J, ctm);
@@ -1007,12 +1141,13 @@
 
 static void
 js_dev_fill_image_mask(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm,
-	fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
+					   fz_colorspace *colorspace, const float *color, float alpha, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "fillImageMask")) {
+	if (js_hasproperty(J, -1, "fillImageMask"))
+	{
 		js_copy(J, -2);
 		ffi_pushimage(J, image);
 		ffi_pushmatrix(J, ctm);
@@ -1027,10 +1162,11 @@
 static void
 js_dev_clip_image_mask(fz_context *ctx, fz_device *dev, fz_image *image, fz_matrix ctm, fz_rect scissor)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "clipImageMask")) {
+	if (js_hasproperty(J, -1, "clipImageMask"))
+	{
 		js_copy(J, -2);
 		ffi_pushimage(J, image);
 		ffi_pushmatrix(J, ctm);
@@ -1043,10 +1179,11 @@
 static void
 js_dev_pop_clip(fz_context *ctx, fz_device *dev)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "popClip")) {
+	if (js_hasproperty(J, -1, "popClip"))
+	{
 		js_copy(J, -2);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -1056,12 +1193,13 @@
 
 static void
 js_dev_begin_mask(fz_context *ctx, fz_device *dev, fz_rect bbox, int luminosity,
-	fz_colorspace *colorspace, const float *color, fz_color_params color_params)
+				  fz_colorspace *colorspace, const float *color, fz_color_params color_params)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "beginMask")) {
+	if (js_hasproperty(J, -1, "beginMask"))
+	{
 		js_copy(J, -2);
 		ffi_pushrect(J, bbox);
 		js_pushboolean(J, luminosity);
@@ -1076,10 +1214,11 @@
 static void
 js_dev_end_mask(fz_context *ctx, fz_device *dev)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "endMask")) {
+	if (js_hasproperty(J, -1, "endMask"))
+	{
 		js_copy(J, -2);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -1089,12 +1228,13 @@
 
 static void
 js_dev_begin_group(fz_context *ctx, fz_device *dev, fz_rect bbox,
-	fz_colorspace *cs, int isolated, int knockout, int blendmode, float alpha)
+				   fz_colorspace *cs, int isolated, int knockout, int blendmode, float alpha)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "beginGroup")) {
+	if (js_hasproperty(J, -1, "beginGroup"))
+	{
 		js_copy(J, -2);
 		ffi_pushrect(J, bbox);
 		js_pushboolean(J, isolated);
@@ -1110,10 +1250,11 @@
 static void
 js_dev_end_group(fz_context *ctx, fz_device *dev)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "endGroup")) {
+	if (js_hasproperty(J, -1, "endGroup"))
+	{
 		js_copy(J, -2);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -1123,12 +1264,13 @@
 
 static int
 js_dev_begin_tile(fz_context *ctx, fz_device *dev, fz_rect area, fz_rect view,
-	float xstep, float ystep, fz_matrix ctm, int id)
+				  float xstep, float ystep, fz_matrix ctm, int id)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "beginTile")) {
+	if (js_hasproperty(J, -1, "beginTile"))
+	{
 		int n;
 		js_copy(J, -2);
 		ffi_pushrect(J, area);
@@ -1149,10 +1291,11 @@
 static void
 js_dev_end_tile(fz_context *ctx, fz_device *dev)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "endTile")) {
+	if (js_hasproperty(J, -1, "endTile"))
+	{
 		js_copy(J, -2);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -1163,10 +1306,11 @@
 static void
 js_dev_begin_layer(fz_context *ctx, fz_device *dev, const char *name)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "beginLayer")) {
+	if (js_hasproperty(J, -1, "beginLayer"))
+	{
 		js_copy(J, -2);
 		js_pushstring(J, name);
 		js_call(J, 1);
@@ -1178,10 +1322,11 @@
 static void
 js_dev_end_layer(fz_context *ctx, fz_device *dev)
 {
-	js_State *J = ((js_device*)dev)->J;
+	js_State *J = ((js_device *)dev)->J;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, -1, "endLayer")) {
+	if (js_hasproperty(J, -1, "endLayer"))
+	{
 		js_copy(J, -2);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -1223,7 +1368,7 @@
 	dev->super.end_layer = js_dev_end_layer;
 
 	dev->J = J;
-	return (fz_device*)dev;
+	return (fz_device *)dev;
 }
 
 /* device calling into c from js */
@@ -1541,10 +1686,12 @@
 	fz_context *ctx = js_getcontext(J);
 	const char *user_css = js_tostring(J, 1);
 	int use_doc_css = js_iscoercible(J, 2) ? js_toboolean(J, 2) : 1;
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		fz_set_user_css(ctx, user_css);
 		fz_set_use_document_css(ctx, use_doc_css);
-	} fz_catch(ctx)
+	}
+	fz_catch(ctx)
 		rethrow(J);
 }
 
@@ -1588,13 +1735,16 @@
 	fz_buffer *buf = js_touserdata(J, 0, "fz_buffer");
 	int i, n = js_gettop(J);
 
-	for (i = 1; i < n; ++i) {
+	for (i = 1; i < n; ++i)
+	{
 		const char *s = js_tostring(J, i);
-		fz_try(ctx) {
+		fz_try(ctx)
+		{
 			if (i > 1)
 				fz_append_byte(ctx, buf, ' ');
 			fz_append_string(ctx, buf, s);
-		} fz_catch(ctx)
+		}
+		fz_catch(ctx)
 			rethrow(J);
 	}
 }
@@ -1760,7 +1910,8 @@
 {
 	int i = 0;
 	js_newarray(J);
-	while (outline) {
+	while (outline)
+	{
 		js_newobject(J);
 
 		if (outline->title)
@@ -1781,7 +1932,8 @@
 			js_pushundefined(J);
 		js_setproperty(J, -2, "page");
 
-		if (outline->down) {
+		if (outline->down)
+		{
 			to_outline(J, outline->down);
 			js_setproperty(J, -2, "down");
 		}
@@ -1834,19 +1986,21 @@
 	fz_matrix ctm = ffi_tomatrix(J, 2);
 	int no_annots = js_isdefined(J, 3) ? js_toboolean(J, 3) : 0;
 
-	if (js_isuserdata(J, 1, "fz_device")) {
+	if (js_isuserdata(J, 1, "fz_device"))
+	{
 		device = js_touserdata(J, 1, "fz_device");
-		fz_try(ctx)
-			if (no_annots)
-				fz_run_page_contents(ctx, page, device, ctm, NULL);
-			else
-				fz_run_page(ctx, page, device, ctm, NULL);
+		fz_try(ctx) if (no_annots)
+			fz_run_page_contents(ctx, page, device, ctm, NULL);
+		else fz_run_page(ctx, page, device, ctm, NULL);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		device = new_js_device(ctx, J);
 		js_copy(J, 1); /* put the js device on the top so the callbacks know where to get it */
-		fz_try(ctx) {
+		fz_try(ctx)
+		{
 			if (no_annots)
 				fz_run_page_contents(ctx, page, device, ctm, NULL);
 			else
@@ -1867,11 +2021,9 @@
 	int no_annots = js_isdefined(J, 1) ? js_toboolean(J, 1) : 0;
 	fz_display_list *list = NULL;
 
-	fz_try(ctx)
-		if (no_annots)
-			list = fz_new_display_list_from_page_contents(ctx, page);
-		else
-			list = fz_new_display_list_from_page(ctx, page);
+	fz_try(ctx) if (no_annots)
+		list = fz_new_display_list_from_page_contents(ctx, page);
+	else list = fz_new_display_list_from_page(ctx, page);
 	fz_catch(ctx)
 		rethrow(J);
 
@@ -1889,11 +2041,9 @@
 	int no_annots = js_isdefined(J, 4) ? js_toboolean(J, 4) : 0;
 	fz_pixmap *pixmap = NULL;
 
-	fz_try(ctx)
-		if (no_annots)
-			pixmap = fz_new_pixmap_from_page_contents(ctx, page, ctm, colorspace, alpha);
-		else
-			pixmap = fz_new_pixmap_from_page(ctx, page, ctm, colorspace, alpha);
+	fz_try(ctx) if (no_annots)
+		pixmap = fz_new_pixmap_from_page_contents(ctx, page, ctm, colorspace, alpha);
+	else pixmap = fz_new_pixmap_from_page(ctx, page, ctm, colorspace, alpha);
 	fz_catch(ctx)
 		rethrow(J);
 
@@ -1909,7 +2059,8 @@
 	fz_stext_options so;
 	fz_stext_page *text = NULL;
 
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		fz_parse_stext_options(ctx, &so, options);
 		text = fz_new_stext_page_from_page(ctx, page, &so);
 	}
@@ -1934,7 +2085,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		ffi_pushquad(J, hits[i]);
 		js_setindex(J, -2, i);
 	}
@@ -1955,7 +2107,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (link = links; link; link = link->next) {
+	for (link = links; link; link = link->next)
+	{
 		js_newobject(J);
 
 		ffi_pushrect(J, link->rect);
@@ -2031,13 +2184,16 @@
 {
 	fz_context *ctx = js_getcontext(J);
 	fz_pixmap *pixmap = js_touserdata(J, 0, "fz_pixmap");
-	if (js_isdefined(J, 1)) {
+	if (js_isdefined(J, 1))
+	{
 		int value = js_tonumber(J, 1);
 		fz_try(ctx)
 			fz_clear_pixmap_with_value(ctx, pixmap, value);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		fz_try(ctx)
 			fz_clear_pixmap(ctx, pixmap);
 		fz_catch(ctx)
@@ -2093,9 +2249,12 @@
 	int x = js_tointeger(J, 1);
 	int y = js_tointeger(J, 2);
 	int k = js_tointeger(J, 3);
-	if (x < 0 || x >= pixmap->w) js_rangeerror(J, "X out of range");
-	if (y < 0 || y >= pixmap->h) js_rangeerror(J, "Y out of range");
-	if (k < 0 || k >= pixmap->n) js_rangeerror(J, "N out of range");
+	if (x < 0 || x >= pixmap->w)
+		js_rangeerror(J, "X out of range");
+	if (y < 0 || y >= pixmap->h)
+		js_rangeerror(J, "Y out of range");
+	if (k < 0 || k >= pixmap->n)
+		js_rangeerror(J, "N out of range");
 	js_pushnumber(J, pixmap->samples[(x + y * pixmap->w) * pixmap->n + k]);
 }
 
@@ -2122,13 +2281,16 @@
 	fz_context *ctx = js_getcontext(J);
 	fz_image *image = NULL;
 
-	if (js_isuserdata(J, 1, "fz_pixmap")) {
+	if (js_isuserdata(J, 1, "fz_pixmap"))
+	{
 		fz_pixmap *pixmap = js_touserdata(J, 1, "fz_pixmap");
 		fz_try(ctx)
 			image = fz_new_image_from_pixmap(ctx, pixmap, NULL);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		const char *name = js_tostring(J, 1);
 		fz_try(ctx)
 			image = fz_new_image_from_file(ctx, name);
@@ -2209,7 +2371,8 @@
 	fz_matrix matrix_, *matrix = NULL;
 	fz_pixmap *pixmap = NULL;
 
-	if (js_isnumber(J, 1) && js_isnumber(J, 2)) {
+	if (js_isnumber(J, 1) && js_isnumber(J, 2))
+	{
 		matrix_ = fz_scale(js_tonumber(J, 1), js_tonumber(J, 2));
 		matrix = &matrix_;
 	}
@@ -2247,7 +2410,8 @@
 	int size;
 	fz_font *font = NULL;
 
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		data = fz_lookup_base14_font(ctx, name, &size);
 		if (!data)
 			data = fz_lookup_cjk_font_by_language(ctx, name, &size, &index);
@@ -2320,14 +2484,16 @@
 	int i;
 
 	js_getproperty(J, 1, "showGlyph");
-	for (span = text->head; span; span = span->next) {
+	for (span = text->head; span; span = span->next)
+	{
 		ffi_pushfont(J, span->font);
 		trm = span->trm;
-		for (i = 0; i < span->len; ++i) {
+		for (i = 0; i < span->len; ++i)
+		{
 			trm.e = span->items[i].x;
 			trm.f = span->items[i].y;
 			js_copy(J, -2); /* showGlyph function */
-			js_copy(J, 1); /* object for this binding */
+			js_copy(J, 1);	/* object for this binding */
 			js_copy(J, -3); /* font */
 			ffi_pushmatrix(J, trm);
 			js_pushnumber(J, span->items[i].gid);
@@ -2398,7 +2564,8 @@
 	js_State *J = arg;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, 1, "moveTo")) {
+	if (js_hasproperty(J, 1, "moveTo"))
+	{
 		js_copy(J, 1);
 		js_pushnumber(J, x);
 		js_pushnumber(J, y);
@@ -2413,7 +2580,8 @@
 	js_State *J = arg;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, 1, "lineTo")) {
+	if (js_hasproperty(J, 1, "lineTo"))
+	{
 		js_copy(J, 1);
 		js_pushnumber(J, x);
 		js_pushnumber(J, y);
@@ -2424,12 +2592,13 @@
 }
 
 static void ffi_Path_walk_curveTo(fz_context *ctx, void *arg,
-		float x1, float y1, float x2, float y2, float x3, float y3)
+								  float x1, float y1, float x2, float y2, float x3, float y3)
 {
 	js_State *J = arg;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, 1, "curveTo")) {
+	if (js_hasproperty(J, 1, "curveTo"))
+	{
 		js_copy(J, 1);
 		js_pushnumber(J, x1);
 		js_pushnumber(J, y1);
@@ -2448,7 +2617,8 @@
 	js_State *J = arg;
 	if (js_try(J))
 		rethrow_as_fz(J);
-	if (js_hasproperty(J, 1, "closePath")) {
+	if (js_hasproperty(J, 1, "closePath"))
+	{
 		js_copy(J, 1);
 		js_call(J, 0);
 		js_pop(J, 1);
@@ -2622,16 +2792,20 @@
 	fz_device *device = NULL;
 	fz_matrix ctm = ffi_tomatrix(J, 2);
 
-	if (js_isuserdata(J, 1, "fz_device")) {
+	if (js_isuserdata(J, 1, "fz_device"))
+	{
 		device = js_touserdata(J, 1, "fz_device");
 		fz_try(ctx)
 			fz_run_display_list(ctx, list, device, ctm, fz_infinite_rect, NULL);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		device = new_js_device(ctx, J);
 		js_copy(J, 1);
-		fz_try(ctx) {
+		fz_try(ctx)
+		{
 			fz_run_display_list(ctx, list, device, ctm, fz_infinite_rect, NULL);
 			fz_close_device(ctx, device);
 		}
@@ -2668,7 +2842,8 @@
 	fz_stext_options so;
 	fz_stext_page *text = NULL;
 
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		fz_parse_stext_options(ctx, &so, options);
 		text = fz_new_stext_page_from_display_list(ctx, list, &so);
 	}
@@ -2693,7 +2868,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		ffi_pushquad(J, hits[i]);
 		js_setindex(J, -2, i);
 	}
@@ -2713,7 +2889,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		ffi_pushquad(J, hits[i]);
 		js_setindex(J, -2, i);
 	}
@@ -2734,7 +2911,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		ffi_pushquad(J, hits[i]);
 		js_setindex(J, -2, i);
 	}
@@ -2861,50 +3039,53 @@
 	if (js_isuserdata(J, idx, "pdf_obj"))
 		return pdf_keep_obj(ctx, js_touserdata(J, idx, "pdf_obj"));
 
-	if (js_isnumber(J, idx)) {
+	if (js_isnumber(J, idx))
+	{
 		float f = js_tonumber(J, idx);
-		fz_try(ctx)
-			if (f == (int)f)
-				obj = pdf_new_int(ctx, f);
-			else
-				obj = pdf_new_real(ctx, f);
+		fz_try(ctx) if (f == (int)f)
+			obj = pdf_new_int(ctx, f);
+		else obj = pdf_new_real(ctx, f);
 		fz_catch(ctx)
 			rethrow(J);
 		return obj;
 	}
 
-	if (js_isstring(J, idx)) {
+	if (js_isstring(J, idx))
+	{
 		const char *s = js_tostring(J, idx);
-		fz_try(ctx)
-			if (s[0] == '(' && s[1] != 0)
-				obj = pdf_new_string(ctx, s+1, strlen(s)-2);
-			else
-				obj = pdf_new_name(ctx, s);
+		fz_try(ctx) if (s[0] == '(' && s[1] != 0)
+			obj = pdf_new_string(ctx, s + 1, strlen(s) - 2);
+		else obj = pdf_new_name(ctx, s);
 		fz_catch(ctx)
 			rethrow(J);
 		return obj;
 	}
 
-	if (js_isboolean(J, idx)) {
+	if (js_isboolean(J, idx))
+	{
 		return js_toboolean(J, idx) ? PDF_TRUE : PDF_FALSE;
 	}
 
-	if (js_isnull(J, idx)) {
+	if (js_isnull(J, idx))
+	{
 		return PDF_NULL;
 	}
 
-	if (js_isarray(J, idx)) {
+	if (js_isarray(J, idx))
+	{
 		int i, n = js_getlength(J, idx);
 		pdf_obj *val;
 		fz_try(ctx)
 			obj = pdf_new_array(ctx, pdf, n);
 		fz_catch(ctx)
 			rethrow(J);
-		if (js_try(J)) {
+		if (js_try(J))
+		{
 			pdf_drop_obj(ctx, obj);
 			js_throw(J);
 		}
-		for (i = 0; i < n; ++i) {
+		for (i = 0; i < n; ++i)
+		{
 			js_getindex(J, idx, i);
 			val = ffi_toobj(J, pdf, -1);
 			fz_try(ctx)
@@ -2917,19 +3098,22 @@
 		return obj;
 	}
 
-	if (js_isobject(J, idx)) {
+	if (js_isobject(J, idx))
+	{
 		const char *key;
 		pdf_obj *val;
 		fz_try(ctx)
 			obj = pdf_new_dict(ctx, pdf, 0);
 		fz_catch(ctx)
 			rethrow(J);
-		if (js_try(J)) {
+		if (js_try(J))
+		{
 			pdf_drop_obj(ctx, obj);
 			js_throw(J);
 		}
 		js_pushiterator(J, idx, 1);
-		while ((key = js_nextiterator(J, -1))) {
+		while ((key = js_nextiterator(J, -1)))
+		{
 			js_getproperty(J, idx, key);
 			val = ffi_toobj(J, pdf, -1);
 			fz_try(ctx)
@@ -2954,7 +3138,8 @@
 	pdf_obj *val = NULL;
 	int idx, len = 0;
 
-	if (!strcmp(key, "length")) {
+	if (!strcmp(key, "length"))
+	{
 		fz_try(ctx)
 			len = pdf_array_len(ctx, obj);
 		fz_catch(ctx)
@@ -2963,18 +3148,22 @@
 		return 1;
 	}
 
-	if (is_number(key, &idx)) {
+	if (is_number(key, &idx))
+	{
 		fz_try(ctx)
 			val = pdf_array_get(ctx, obj, idx);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		fz_try(ctx)
 			val = pdf_dict_gets(ctx, obj, key);
 		fz_catch(ctx)
 			rethrow(J);
 	}
-	if (val) {
+	if (val)
+	{
 		ffi_pushobj(J, pdf_keep_obj(ctx, val));
 		return 1;
 	}
@@ -2995,14 +3184,17 @@
 
 	val = ffi_toobj(J, pdf, -1);
 
-	if (is_number(key, &idx)) {
+	if (is_number(key, &idx))
+	{
 		fz_try(ctx)
 			pdf_array_put(ctx, obj, idx, val);
 		fz_always(ctx)
 			pdf_drop_obj(ctx, val);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		fz_try(ctx)
 			pdf_dict_puts(ctx, obj, key, val);
 		fz_always(ctx)
@@ -3018,12 +3210,15 @@
 	fz_context *ctx = js_getcontext(J);
 	int idx;
 
-	if (is_number(key, &idx)) {
+	if (is_number(key, &idx))
+	{
 		fz_try(ctx)
 			pdf_array_delete(ctx, obj, idx);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		fz_try(ctx)
 			pdf_dict_dels(ctx, obj, key);
 		fz_catch(ctx)
@@ -3034,12 +3229,15 @@
 
 static void ffi_pushobj(js_State *J, pdf_obj *obj)
 {
-	if (obj) {
+	if (obj)
+	{
 		js_getregistry(J, "pdf_obj");
 		js_newuserdatax(J, "pdf_obj", obj,
-				ffi_pdf_obj_has, ffi_pdf_obj_put, ffi_pdf_obj_delete,
-				ffi_gc_pdf_obj);
-	} else {
+						ffi_pdf_obj_has, ffi_pdf_obj_put, ffi_pdf_obj_delete,
+						ffi_gc_pdf_obj);
+	}
+	else
+	{
 		js_pushnull(J);
 	}
 }
@@ -3050,11 +3248,9 @@
 	const char *filename = js_iscoercible(J, 1) ? js_tostring(J, 1) : NULL;
 	pdf_document *pdf = NULL;
 
-	fz_try(ctx)
-		if (filename)
-			pdf = pdf_open_document(ctx, filename);
-		else
-			pdf = pdf_create_document(ctx);
+	fz_try(ctx) if (filename)
+		pdf = pdf_open_document(ctx, filename);
+	else pdf = pdf_create_document(ctx);
 	fz_catch(ctx)
 		rethrow(J);
 
@@ -3142,10 +3338,12 @@
 
 	fz_try(ctx)
 		ind = pdf_add_stream(ctx, pdf, buf, obj, compressed);
-	fz_always(ctx) {
+	fz_always(ctx)
+	{
 		fz_drop_buffer(ctx, buf);
 		pdf_drop_obj(ctx, obj);
-	} fz_catch(ctx)
+	}
+	fz_catch(ctx)
 		rethrow(J);
 
 	ffi_pushobj(J, ind);
@@ -3270,10 +3468,12 @@
 
 	fz_try(ctx)
 		ind = pdf_add_page(ctx, pdf, mediabox, rotate, resources, contents);
-	fz_always(ctx) {
+	fz_always(ctx)
+	{
 		fz_drop_buffer(ctx, contents);
 		pdf_drop_obj(ctx, resources);
-	} fz_catch(ctx)
+	}
+	fz_catch(ctx)
 		rethrow(J);
 
 	ffi_pushobj(J, ind);
@@ -3343,10 +3543,12 @@
 	const char *options = js_iscoercible(J, 2) ? js_tostring(J, 2) : NULL;
 	pdf_write_options pwo;
 
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		pdf_parse_write_options(ctx, &pwo, options);
 		pdf_save_document(ctx, pdf, filename, &pwo);
-	} fz_catch(ctx)
+	}
+	fz_catch(ctx)
 		rethrow(J);
 }
 
@@ -3412,12 +3614,14 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	if (js_try(J)) {
+	if (js_try(J))
+	{
 		fz_free(ctx, buf);
 		js_throw(J);
 	}
 
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_getindex(J, 1, i);
 		buf[i] = js_tonumber(J, -1);
 		js_pop(J, 1);
@@ -3642,7 +3846,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	if (js_try(J)) {
+	if (js_try(J))
+	{
 		fz_free(ctx, s);
 		js_throw(J);
 	}
@@ -3774,11 +3979,9 @@
 	fz_context *ctx = js_getcontext(J);
 	pdf_obj *obj = js_touserdata(J, 0, "pdf_obj");
 	float num = 0;
-	fz_try(ctx)
-		if (pdf_is_int(ctx, obj))
-			num = pdf_to_int(ctx, obj);
-		else
-			num = pdf_to_real(ctx, obj);
+	fz_try(ctx) if (pdf_is_int(ctx, obj))
+		num = pdf_to_int(ctx, obj);
+	else num = pdf_to_real(ctx, obj);
 	fz_catch(ctx)
 		rethrow(J);
 	js_pushnumber(J, num);
@@ -3847,7 +4050,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < len; ++i) {
+	for (i = 0; i < len; ++i)
+	{
 		js_pushnumber(J, (unsigned char)buf[i]);
 		js_setindex(J, -2, (int)i);
 	}
@@ -3942,12 +4146,14 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	if (pdf_is_array(ctx, obj)) {
+	if (pdf_is_array(ctx, obj))
+	{
 		fz_try(ctx)
 			n = pdf_array_len(ctx, obj);
 		fz_catch(ctx)
 			rethrow(J);
-		for (i = 0; i < n; ++i) {
+		for (i = 0; i < n; ++i)
+		{
 			fz_try(ctx)
 				val = pdf_array_get(ctx, obj, i);
 			fz_catch(ctx)
@@ -3962,16 +4168,20 @@
 		return;
 	}
 
-	if (pdf_is_dict(ctx, obj)) {
+	if (pdf_is_dict(ctx, obj))
+	{
 		fz_try(ctx)
 			n = pdf_dict_len(ctx, obj);
 		fz_catch(ctx)
 			rethrow(J);
-		for (i = 0; i < n; ++i) {
-			fz_try(ctx) {
+		for (i = 0; i < n; ++i)
+		{
+			fz_try(ctx)
+			{
 				key = pdf_to_name(ctx, pdf_dict_get_key(ctx, obj, i));
 				val = pdf_dict_get_val(ctx, obj, i);
-			} fz_catch(ctx)
+			}
+			fz_catch(ctx)
 				rethrow(J);
 			js_copy(J, 1);
 			js_pushnull(J);
@@ -3998,7 +4208,8 @@
 
 	js_newarray(J);
 
-	while (widget) {
+	while (widget)
+	{
 		js_getregistry(J, "pdf_widget");
 		js_newuserdata(J, "pdf_widget", pdf_keep_widget(ctx, widget), ffi_gc_pdf_widget);
 		js_setindex(J, -2, i++);
@@ -4024,7 +4235,8 @@
 
 	js_newarray(J);
 
-	while (annot) {
+	while (annot)
+	{
 		js_getregistry(J, "pdf_annot");
 		js_newuserdata(J, "pdf_annot", pdf_keep_annot(ctx, annot), ffi_gc_pdf_annot);
 		js_setindex(J, -2, i++);
@@ -4084,8 +4296,12 @@
 	pdf_page *page = js_touserdata(J, 0, "pdf_page");
 	pdf_redact_options opts;
 	memset(&opts, 0, sizeof opts);
-	if (js_isdefined(J, 1)) opts.no_black_boxes = js_toboolean(J, 1);
-	if (js_isdefined(J, 2)) opts.keep_images = js_toboolean(J, 2);
+	/*
+	if (js_isdefined(J, 1))
+		opts.black_boxes = !js_toboolean(J, 1);
+	if (js_isdefined(J, 2))
+		opts.keep_images = js_toboolean(J, 2);
+	*/
 	fz_try(ctx)
 		pdf_redact_page(ctx, page->doc, page, &opts);
 	fz_catch(ctx)
@@ -4113,16 +4329,20 @@
 	fz_device *device = NULL;
 	fz_matrix ctm = ffi_tomatrix(J, 2);
 
-	if (js_isuserdata(J, 1, "fz_device")) {
+	if (js_isuserdata(J, 1, "fz_device"))
+	{
 		device = js_touserdata(J, 1, "fz_device");
 		fz_try(ctx)
 			pdf_run_annot(ctx, annot, device, ctm, NULL);
 		fz_catch(ctx)
 			rethrow(J);
-	} else {
+	}
+	else
+	{
 		device = new_js_device(ctx, J);
 		js_copy(J, 1); /* put the js device on the top so the callbacks know where to get it */
-		fz_try(ctx) {
+		fz_try(ctx)
+		{
 			pdf_run_annot(ctx, annot, device, ctm, NULL);
 			fz_close_device(ctx, device);
 		}
@@ -4287,7 +4507,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_pushnumber(J, color[i]);
 		js_setindex(J, -2, i);
 	}
@@ -4299,7 +4520,8 @@
 	pdf_annot *annot = js_touserdata(J, 0, "pdf_annot");
 	int i, n = js_getlength(J, 1);
 	float color[4];
-	for (i = 0; i < n && i < 4; ++i) {
+	for (i = 0; i < n && i < 4; ++i)
+	{
 		js_getindex(J, 1, i);
 		color[i] = js_tonumber(J, -1);
 		js_pop(J, 1);
@@ -4321,7 +4543,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_pushnumber(J, color[i]);
 		js_setindex(J, -2, i);
 	}
@@ -4333,7 +4556,8 @@
 	pdf_annot *annot = js_touserdata(J, 0, "pdf_annot");
 	int i, n = js_getlength(J, 1);
 	float color[4];
-	for (i = 0; i < n && i < 4; ++i) {
+	for (i = 0; i < n && i < 4; ++i)
+	{
 		js_getindex(J, 1, i);
 		color[i] = js_tonumber(J, -1);
 		js_pop(J, 1);
@@ -4357,7 +4581,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		fz_try(ctx)
 			q = pdf_annot_quad_point(ctx, annot, i);
 		fz_catch(ctx)
@@ -4381,7 +4606,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_getindex(J, 1, i);
 		qp[i] = ffi_toquad(J, -1);
 		js_pop(J, 1);
@@ -4431,7 +4657,8 @@
 		rethrow(J);
 
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		fz_try(ctx)
 			p = pdf_annot_vertex(ctx, annot, i);
 		fz_catch(ctx)
@@ -4455,7 +4682,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_getindex(J, 1, i);
 		p = ffi_topoint(J, -1);
 		js_pop(J, 1);
@@ -4504,14 +4732,16 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		fz_try(ctx)
 			m = pdf_annot_ink_list_stroke_count(ctx, annot, i);
 		fz_catch(ctx)
 			rethrow(J);
 
 		js_newarray(J);
-		for (k = 0; k < m; ++k) {
+		for (k = 0; k < m; ++k)
+		{
 			fz_try(ctx)
 				pt = pdf_annot_ink_list_stroke_vertex(ctx, annot, i, k);
 			fz_catch(ctx)
@@ -4538,34 +4768,41 @@
 
 	n = js_getlength(J, 1);
 	nv = 0;
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		js_getindex(J, 1, i);
 		nv += js_getlength(J, -1) / 2;
 		js_pop(J, 1);
 	}
 
-	fz_try(ctx) {
+	fz_try(ctx)
+	{
 		counts = fz_malloc(ctx, n * sizeof(int));
 		points = fz_malloc(ctx, nv * sizeof(fz_point));
-	} fz_catch(ctx) {
+	}
+	fz_catch(ctx)
+	{
 		fz_free(ctx, counts);
 		fz_free(ctx, points);
 		rethrow(J);
 	}
 
-	if (js_try(J)) {
+	if (js_try(J))
+	{
 		fz_free(ctx, counts);
 		fz_free(ctx, points);
 		js_throw(J);
 	}
-	for (i = v = 0; i < n; ++i) {
+	for (i = v = 0; i < n; ++i)
+	{
 		js_getindex(J, 1, i);
 		counts[i] = js_getlength(J, -1) / 2;
-		for (k = 0; k < counts[i]; ++k) {
-			js_getindex(J, -1, k*2);
+		for (k = 0; k < counts[i]; ++k)
+		{
+			js_getindex(J, -1, k * 2);
 			points[v].x = js_tonumber(J, -1);
 			js_pop(J, 1);
-			js_getindex(J, -1, k*2+1);
+			js_getindex(J, -1, k * 2 + 1);
 			points[v].y = js_tonumber(J, -1);
 			js_pop(J, 1);
 			++v;
@@ -4576,7 +4813,8 @@
 
 	fz_try(ctx)
 		pdf_set_annot_ink_list(ctx, annot, n, counts, points);
-	fz_always(ctx) {
+	fz_always(ctx)
+	{
 		fz_free(ctx, counts);
 		fz_free(ctx, points);
 	}
@@ -4608,12 +4846,13 @@
 	fz_catch(ctx)
 		rethrow(J);
 
-	for (i = 0; i < n; i += 2) {
+	for (i = 0; i < n; i += 2)
+	{
 		js_getindex(J, 1, i);
 		x = js_tonumber(J, -1);
 		js_pop(J, 1);
 
-		js_getindex(J, 1, i+1);
+		js_getindex(J, 1, i + 1);
 		y = js_tonumber(J, -1);
 		js_pop(J, 1);
 
@@ -4722,7 +4961,6 @@
 	js_pushboolean(J, changed);
 }
 
-
 static void ffi_PDFWidget_getFieldType(js_State *J)
 {
 	fz_context *ctx = js_getcontext(J);
@@ -4735,13 +4973,27 @@
 	switch (type)
 	{
 	default:
-	case PDF_WIDGET_TYPE_BUTTON: js_pushstring(J, "button"); break;
-	case PDF_WIDGET_TYPE_CHECKBOX: js_pushstring(J, "checkbox"); break;
-	case PDF_WIDGET_TYPE_COMBOBOX: js_pushstring(J, "combobox"); break;
-	case PDF_WIDGET_TYPE_LISTBOX: js_pushstring(J, "listbox"); break;
-	case PDF_WIDGET_TYPE_RADIOBUTTON: js_pushstring(J, "radiobutton"); break;
-	case PDF_WIDGET_TYPE_SIGNATURE: js_pushstring(J, "signature"); break;
-	case PDF_WIDGET_TYPE_TEXT: js_pushstring(J, "text"); break;
+	case PDF_WIDGET_TYPE_BUTTON:
+		js_pushstring(J, "button");
+		break;
+	case PDF_WIDGET_TYPE_CHECKBOX:
+		js_pushstring(J, "checkbox");
+		break;
+	case PDF_WIDGET_TYPE_COMBOBOX:
+		js_pushstring(J, "combobox");
+		break;
+	case PDF_WIDGET_TYPE_LISTBOX:
+		js_pushstring(J, "listbox");
+		break;
+	case PDF_WIDGET_TYPE_RADIOBUTTON:
+		js_pushstring(J, "radiobutton");
+		break;
+	case PDF_WIDGET_TYPE_SIGNATURE:
+		js_pushstring(J, "signature");
+		break;
+	case PDF_WIDGET_TYPE_TEXT:
+		js_pushstring(J, "text");
+		break;
 	}
 }
 
@@ -4850,7 +5102,8 @@
 	fz_catch(ctx)
 		rethrow(J);
 	js_newarray(J);
-	for (i = 0; i < n; ++i) {
+	for (i = 0; i < n; ++i)
+	{
 		fz_try(ctx)
 			opt = pdf_choice_field_option(ctx, widget->obj, export, i);
 		fz_catch(ctx)
@@ -5486,18 +5739,20 @@
 	js_dostring(J, "function Scale(sx,sy) { return [sx,0,0,sy,0,0]; }");
 	js_dostring(J, "function Translate(tx,ty) { return [1,0,0,1,tx,ty]; }");
 	js_dostring(J, "function Concat(a,b) { return ["
-			"a[0] * b[0] + a[1] * b[2],"
-			"a[0] * b[1] + a[1] * b[3],"
-			"a[2] * b[0] + a[3] * b[2],"
-			"a[2] * b[1] + a[3] * b[3],"
-			"a[4] * b[0] + a[5] * b[2] + b[4],"
-			"a[4] * b[1] + a[5] * b[3] + b[5]];}");
+				   "a[0] * b[0] + a[1] * b[2],"
+				   "a[0] * b[1] + a[1] * b[3],"
+				   "a[2] * b[0] + a[3] * b[2],"
+				   "a[2] * b[1] + a[3] * b[3],"
+				   "a[4] * b[0] + a[5] * b[2] + b[4],"
+				   "a[4] * b[1] + a[5] * b[3] + b[5]];}");
 
-	if (argc > 1) {
+	if (argc > 1)
+	{
 		js_pushstring(J, argv[1]);
 		js_setglobal(J, "scriptPath");
 		js_newarray(J);
-		for (i = 2; i < argc; ++i) {
+		for (i = 2; i < argc; ++i)
+		{
 			js_pushstring(J, argv[i]);
 			js_setindex(J, -2, i - 2);
 		}
@@ -5508,10 +5763,13 @@
 			fz_drop_context(ctx);
 			return 1;
 		}
-	} else {
+	}
+	else
+	{
 		char line[256];
 		fputs(PS1, stdout);
-		while (fgets(line, sizeof line, stdin)) {
+		while (fgets(line, sizeof line, stdin))
+		{
 			eval_print(J, line);
 			fputs(PS1, stdout);
 		}
