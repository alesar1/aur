From c5d326f551b0312ff581bf1df35b21d956e01523 Mon Sep 17 00:00:00 2001
From: =?utf8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Fri, 24 Jun 2016 00:58:17 +0300
Subject: [PATCH] Add an OpenH264 decoder wrapper
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

This is cherrypicked from libav, from commits
82b7525173f20702a8cbc26ebedbf4b69b8fecec and
d0b1e6049b06eeeeca146ece4d2f199c5dba1565.

Signed-off-by: Martin StorsjÃ¶ <martin@martin.st>
---
 Changelog                   |   1 +
 configure                   |   2 +
 doc/general.texi            |   9 +-
 libavcodec/Makefile         |   3 +-
 libavcodec/allcodecs.c      |   2 +-
 libavcodec/libopenh264.c    |  62 +++++++++++
 libavcodec/libopenh264.h    |  39 +++++++
 libavcodec/libopenh264dec.c | 243 ++++++++++++++++++++++++++++++++++++++++++++
 libavcodec/libopenh264enc.c |  48 ++-------
 libavcodec/version.h        |   2 +-
 10 files changed, 366 insertions(+), 45 deletions(-)
 create mode 100644 libavcodec/libopenh264.c
 create mode 100644 libavcodec/libopenh264.h
 create mode 100644 libavcodec/libopenh264dec.c

diff --git a/configure b/configure
index 1b41303..9f5b31f 100755
--- a/configure
+++ b/configure
@@ -2771,6 +2771,8 @@ libopencore_amrnb_decoder_deps="libopencore_amrnb"
 libopencore_amrnb_encoder_deps="libopencore_amrnb"
 libopencore_amrnb_encoder_select="audio_frame_queue"
 libopencore_amrwb_decoder_deps="libopencore_amrwb"
+libopenh264_decoder_deps="libopenh264"
+libopenh264_decoder_select="h264_mp4toannexb_bsf"
 libopenh264_encoder_deps="libopenh264"
 libopenjpeg_decoder_deps="libopenjpeg"
 libopenjpeg_encoder_deps="libopenjpeg"
diff --git a/doc/general.texi b/doc/general.texi
index 7823dc1..6b5975c 100644
--- a/doc/general.texi
+++ b/doc/general.texi
@@ -103,12 +103,19 @@ enable it.
 
 @section OpenH264
 
-FFmpeg can make use of the OpenH264 library for H.264 encoding.
+FFmpeg can make use of the OpenH264 library for H.264 encoding and decoding.
 
 Go to @url{http://www.openh264.org/} and follow the instructions for
 installing the library. Then pass @code{--enable-libopenh264} to configure to
 enable it.
 
+For decoding, this library is much more limited than the built-in decoder
+in libavcodec; currently, this library lacks support for decoding B-frames
+and some other main/high profile features. (It currently only supports
+constrained baseline profile and CABAC.) Using it is mostly useful for
+testing and for taking advantage of Cisco's patent portfolio license
+(@url{http://www.openh264.org/BINARY_LICENSE.txt}).
+
 @section x264
 
 FFmpeg can make use of the x264 library for H.264 encoding.
diff --git a/libavcodec/Makefile b/libavcodec/Makefile
index a548e02..3def3ad 100644
--- a/libavcodec/Makefile
+++ b/libavcodec/Makefile
@@ -868,7 +868,8 @@ OBJS-$(CONFIG_LIBMP3LAME_ENCODER)         += libmp3lame.o mpegaudiodata.o mpegau
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_DECODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRNB_ENCODER)  += libopencore-amr.o
 OBJS-$(CONFIG_LIBOPENCORE_AMRWB_DECODER)  += libopencore-amr.o
-OBJS-$(CONFIG_LIBOPENH264_ENCODER)        += libopenh264enc.o
+OBJS-$(CONFIG_LIBOPENH264_DECODER)        += libopenh264dec.o libopenh264.o
+OBJS-$(CONFIG_LIBOPENH264_ENCODER)        += libopenh264enc.o libopenh264.o
 OBJS-$(CONFIG_LIBOPENJPEG_DECODER)        += libopenjpegdec.o
 OBJS-$(CONFIG_LIBOPENJPEG_ENCODER)        += libopenjpegenc.o
 OBJS-$(CONFIG_LIBOPUS_DECODER)            += libopusdec.o libopus.o     \
diff --git a/libavcodec/allcodecs.c b/libavcodec/allcodecs.c
index 951e199..a1ae61f 100644
--- a/libavcodec/allcodecs.c
+++ b/libavcodec/allcodecs.c
@@ -623,7 +623,7 @@ void avcodec_register_all(void)
 
     /* external libraries, that shouldn't be used by default if one of the
      * above is available */
-    REGISTER_ENCODER(LIBOPENH264,       libopenh264);
+    REGISTER_ENCDEC (LIBOPENH264,       libopenh264);
     REGISTER_DECODER(H264_CUVID,        h264_cuvid);
     REGISTER_ENCODER(H264_NVENC,        h264_nvenc);
     REGISTER_ENCODER(H264_OMX,          h264_omx);
diff --git a/libavcodec/libopenh264.c b/libavcodec/libopenh264.c
new file mode 100644
index 0000000..59c61a3
--- /dev/null
+++ b/libavcodec/libopenh264.c
@@ -0,0 +1,62 @@
+/*
+ * OpenH264 shared utils
+ * Copyright (C) 2014 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <string.h>
+#include <wels/codec_api.h>
+#include <wels/codec_ver.h>
+
+#include "libavutil/log.h"
+
+#include "libopenh264.h"
+
+// Convert libopenh264 log level to equivalent ffmpeg log level.
+static int libopenh264_to_ffmpeg_log_level(int libopenh264_log_level)
+{
+    if      (libopenh264_log_level >= WELS_LOG_DETAIL)  return AV_LOG_TRACE;
+    else if (libopenh264_log_level >= WELS_LOG_DEBUG)   return AV_LOG_DEBUG;
+    else if (libopenh264_log_level >= WELS_LOG_INFO)    return AV_LOG_VERBOSE;
+    else if (libopenh264_log_level >= WELS_LOG_WARNING) return AV_LOG_WARNING;
+    else if (libopenh264_log_level >= WELS_LOG_ERROR)   return AV_LOG_ERROR;
+    else                                                return AV_LOG_QUIET;
+}
+
+void ff_libopenh264_trace_callback(void *ctx, int level, const char *msg)
+{
+    // The message will be logged only if the requested EQUIVALENT ffmpeg log level is
+    // less than or equal to the current ffmpeg log level.
+    int equiv_ffmpeg_log_level = libopenh264_to_ffmpeg_log_level(level);
+    av_log(ctx, equiv_ffmpeg_log_level, "%s\n", msg);
+}
+
+int ff_libopenh264_check_version(void *logctx)
+{
+    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion
+    // function (for functions returning larger structs), thus skip the check in those
+    // configurations.
+#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)
+    OpenH264Version libver = WelsGetCodecVersion();
+    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {
+        av_log(logctx, AV_LOG_ERROR, "Incorrect library version loaded\n");
+        return AVERROR(EINVAL);
+    }
+#endif
+    return 0;
+}
diff --git a/libavcodec/libopenh264.h b/libavcodec/libopenh264.h
new file mode 100644
index 0000000..dbb9c5d
--- /dev/null
+++ b/libavcodec/libopenh264.h
@@ -0,0 +1,39 @@
+/*
+ * OpenH264 shared utils
+ * Copyright (C) 2014 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#ifndef AVCODEC_LIBOPENH264_H
+#define AVCODEC_LIBOPENH264_H
+
+#define OPENH264_VER_AT_LEAST(maj, min) \
+    ((OPENH264_MAJOR  > (maj)) || \
+     (OPENH264_MAJOR == (maj) && OPENH264_MINOR >= (min)))
+
+// This function will be provided to the libopenh264 library.  The function will be called
+// when libopenh264 wants to log a message (error, warning, info, etc.).  The signature for
+// this function (defined in .../codec/api/svc/codec_api.h) is:
+//
+//        typedef void (*WelsTraceCallback) (void* ctx, int level, const char* string);
+
+void ff_libopenh264_trace_callback(void *ctx, int level, const char *msg);
+
+int ff_libopenh264_check_version(void *logctx);
+
+#endif /* AVCODEC_LIBOPENH264_H */
diff --git a/libavcodec/libopenh264dec.c b/libavcodec/libopenh264dec.c
new file mode 100644
index 0000000..f642082
--- /dev/null
+++ b/libavcodec/libopenh264dec.c
@@ -0,0 +1,243 @@
+/*
+ * OpenH264 video decoder
+ * Copyright (C) 2016 Martin Storsjo
+ *
+ * This file is part of FFmpeg.
+ *
+ * FFmpeg is free software; you can redistribute it and/or
+ * modify it under the terms of the GNU Lesser General Public
+ * License as published by the Free Software Foundation; either
+ * version 2.1 of the License, or (at your option) any later version.
+ *
+ * FFmpeg is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
+ * Lesser General Public License for more details.
+ *
+ * You should have received a copy of the GNU Lesser General Public
+ * License along with FFmpeg; if not, write to the Free Software
+ * Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA 02110-1301 USA
+ */
+
+#include <wels/codec_api.h>
+#include <wels/codec_ver.h>
+
+#include "libavutil/common.h"
+#include "libavutil/fifo.h"
+#include "libavutil/imgutils.h"
+#include "libavutil/intreadwrite.h"
+#include "libavutil/mathematics.h"
+#include "libavutil/opt.h"
+
+#include "avcodec.h"
+#include "internal.h"
+#include "libopenh264.h"
+
+typedef struct SVCContext {
+    ISVCDecoder *decoder;
+    AVBSFContext *bsf;
+    AVFifoBuffer *packet_fifo;
+    AVPacket pkt_filtered;
+} SVCContext;
+
+static av_cold int svc_decode_close(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    AVPacket pkt;
+
+    if (s->decoder)
+        WelsDestroyDecoder(s->decoder);
+
+    while (s->packet_fifo && av_fifo_size(s->packet_fifo) >= sizeof(pkt)) {
+        av_fifo_generic_read(s->packet_fifo, &pkt, sizeof(pkt), NULL);
+        av_packet_unref(&pkt);
+    }
+
+    av_bsf_free(&s->bsf);
+    av_packet_unref(&s->pkt_filtered);
+    av_fifo_free(s->packet_fifo);
+
+    return 0;
+}
+
+static av_cold int svc_decode_init(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    SDecodingParam param = { 0 };
+    int err;
+    int log_level;
+    WelsTraceCallback callback_function;
+
+    if ((err = ff_libopenh264_check_version(avctx)) < 0)
+        return err;
+
+    s->packet_fifo = av_fifo_alloc(sizeof(AVPacket));
+    if (!s->packet_fifo) {
+        err = AVERROR(ENOMEM);
+        goto fail;
+    }
+
+    if (WelsCreateDecoder(&s->decoder)) {
+        av_log(avctx, AV_LOG_ERROR, "Unable to create decoder\n");
+        err = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    // Pass all libopenh264 messages to our callback, to allow ourselves to filter them.
+    log_level = WELS_LOG_DETAIL;
+    callback_function = ff_libopenh264_trace_callback;
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_LEVEL, &log_level);
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);
+    (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);
+
+    param.eOutputColorFormat = videoFormatI420;
+    param.eEcActiveIdc       = ERROR_CON_DISABLE;
+    param.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;
+
+    if ((*s->decoder)->Initialize(s->decoder, &param) != cmResultSuccess) {
+        av_log(avctx, AV_LOG_ERROR, "Initialize failed\n");
+        err = AVERROR_UNKNOWN;
+        goto fail;
+    }
+
+    avctx->pix_fmt = AV_PIX_FMT_YUV420P;
+
+fail:
+    return err;
+}
+
+static int init_bsf(AVCodecContext *avctx)
+{
+    SVCContext *s = avctx->priv_data;
+    const AVBitStreamFilter *filter;
+    int ret;
+
+    if (s->bsf)
+        return 0;
+
+    // If the input stream already is annex b, this BSF only passes the
+    // packets through unchanged.
+    filter = av_bsf_get_by_name("h264_mp4toannexb");
+    if (!filter)
+        return AVERROR_BUG;
+
+    ret = av_bsf_alloc(filter, &s->bsf);
+    if (ret < 0)
+        return ret;
+
+    ret = avcodec_parameters_from_context(s->bsf->par_in, avctx);
+    if (ret < 0)
+        return ret;
+
+    s->bsf->time_base_in = avctx->time_base;
+
+    ret = av_bsf_init(s->bsf);
+    if (ret < 0)
+        return ret;
+
+    return ret;
+}
+
+static int svc_decode_frame(AVCodecContext *avctx, void *data,
+                            int *got_frame, AVPacket *avpkt)
+{
+    SVCContext *s = avctx->priv_data;
+    SBufferInfo info = { 0 };
+    uint8_t* ptrs[3];
+    int linesize[3];
+    AVFrame *avframe = data;
+    int ret;
+    DECODING_STATE state;
+
+    if ((ret = init_bsf(avctx)) < 0)
+        return ret;
+
+    if (avpkt->size) {
+        AVPacket input_ref = { 0 };
+        if (av_fifo_space(s->packet_fifo) < sizeof(input_ref)) {
+            ret = av_fifo_realloc2(s->packet_fifo,
+                                   av_fifo_size(s->packet_fifo) + sizeof(input_ref));
+            if (ret < 0)
+                return ret;
+        }
+
+        ret = av_packet_ref(&input_ref, avpkt);
+        if (ret < 0)
+            return ret;
+        av_fifo_generic_write(s->packet_fifo, &input_ref, sizeof(input_ref), NULL);
+    }
+
+    while (!*got_frame) {
+        /* prepare the input data -- convert to Annex B if needed */
+        if (s->pkt_filtered.size <= 0) {
+            AVPacket input_ref;
+
+            /* no more data */
+            if (av_fifo_size(s->packet_fifo) < sizeof(AVPacket))
+                return avpkt->size ? avpkt->size : 0;
+
+            av_packet_unref(&s->pkt_filtered);
+
+            av_fifo_generic_read(s->packet_fifo, &input_ref, sizeof(input_ref), NULL);
+            ret = av_bsf_send_packet(s->bsf, &input_ref);
+            if (ret < 0) {
+                av_packet_unref(&input_ref);
+                return ret;
+            }
+
+            ret = av_bsf_receive_packet(s->bsf, &s->pkt_filtered);
+            if (ret < 0)
+                av_packet_move_ref(&s->pkt_filtered, &input_ref);
+            else
+                av_packet_unref(&input_ref);
+        }
+
+        state = (*s->decoder)->DecodeFrame2(s->decoder, s->pkt_filtered.data, s->pkt_filtered.size, ptrs, &info);
+        s->pkt_filtered.size = 0;
+        if (state != dsErrorFree) {
+            av_log(avctx, AV_LOG_ERROR, "DecodeFrame2 failed\n");
+            return AVERROR_UNKNOWN;
+        }
+        if (info.iBufferStatus != 1) {
+            av_log(avctx, AV_LOG_DEBUG, "No frame produced\n");
+            continue;
+        }
+
+        ret = ff_set_dimensions(avctx, info.UsrData.sSystemBuffer.iWidth, info.UsrData.sSystemBuffer.iHeight);
+        if (ret < 0)
+            return ret;
+        // The decoder doesn't (currently) support decoding into a user
+        // provided buffer, so do a copy instead.
+        if (ff_get_buffer(avctx, avframe, 0) < 0) {
+            av_log(avctx, AV_LOG_ERROR, "Unable to allocate buffer\n");
+            return AVERROR(ENOMEM);
+        }
+
+        linesize[0] = info.UsrData.sSystemBuffer.iStride[0];
+        linesize[1] = linesize[2] = info.UsrData.sSystemBuffer.iStride[1];
+        av_image_copy(avframe->data, avframe->linesize, (const uint8_t **) ptrs, linesize, avctx->pix_fmt, avctx->width, avctx->height);
+
+        avframe->pts     = s->pkt_filtered.pts;
+        avframe->pkt_dts = s->pkt_filtered.dts;
+        avframe->pkt_pts = s->pkt_filtered.pts;
+
+        *got_frame = 1;
+    }
+    return avpkt->size;
+}
+
+AVCodec ff_libopenh264_decoder = {
+    .name           = "libopenh264",
+    .long_name      = NULL_IF_CONFIG_SMALL("OpenH264 H.264 / AVC / MPEG-4 AVC / MPEG-4 part 10"),
+    .type           = AVMEDIA_TYPE_VIDEO,
+    .id             = AV_CODEC_ID_H264,
+    .priv_data_size = sizeof(SVCContext),
+    .init           = svc_decode_init,
+    .decode         = svc_decode_frame,
+    .close          = svc_decode_close,
+    // The decoder doesn't currently support B-frames, and the decoder's API
+    // doesn't support reordering/delay, but the BSF could incur delay.
+    .capabilities   = AV_CODEC_CAP_DELAY | AV_CODEC_CAP_DR1,
+    .caps_internal  = FF_CODEC_CAP_SETS_PKT_DTS | FF_CODEC_CAP_INIT_THREADSAFE |
+                      FF_CODEC_CAP_INIT_CLEANUP,
+};
diff --git a/libavcodec/libopenh264enc.c b/libavcodec/libopenh264enc.c
index 24bc228..d27fc41 100644
--- a/libavcodec/libopenh264enc.c
+++ b/libavcodec/libopenh264enc.c
@@ -31,6 +31,7 @@
 
 #include "avcodec.h"
 #include "internal.h"
+#include "libopenh264.h"
 
 typedef struct SVCContext {
     const AVClass *av_class;
@@ -44,10 +45,6 @@ typedef struct SVCContext {
     int cabac;
 } SVCContext;
 
-#define OPENH264_VER_AT_LEAST(maj, min) \
-    ((OPENH264_MAJOR  > (maj)) || \
-     (OPENH264_MAJOR == (maj) && OPENH264_MINOR >= (min)))
-
 #define OFFSET(x) offsetof(SVCContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
@@ -68,31 +65,6 @@ static const AVClass class = {
     "libopenh264enc", av_default_item_name, options, LIBAVUTIL_VERSION_INT
 };
 
-// Convert libopenh264 log level to equivalent ffmpeg log level.
-static int libopenh264_to_ffmpeg_log_level(int libopenh264_log_level)
-{
-    if      (libopenh264_log_level >= WELS_LOG_DETAIL)  return AV_LOG_TRACE;
-    else if (libopenh264_log_level >= WELS_LOG_DEBUG)   return AV_LOG_DEBUG;
-    else if (libopenh264_log_level >= WELS_LOG_INFO)    return AV_LOG_VERBOSE;
-    else if (libopenh264_log_level >= WELS_LOG_WARNING) return AV_LOG_WARNING;
-    else if (libopenh264_log_level >= WELS_LOG_ERROR)   return AV_LOG_ERROR;
-    else                                                return AV_LOG_QUIET;
-}
-
-// This function will be provided to the libopenh264 library.  The function will be called
-// when libopenh264 wants to log a message (error, warning, info, etc.).  The signature for
-// this function (defined in .../codec/api/svc/codec_api.h) is:
-//
-//        typedef void (*WelsTraceCallback) (void* ctx, int level, const char* string);
-
-static void libopenh264_trace_callback(void *ctx, int level, const char *msg)
-{
-    // The message will be logged only if the requested EQUIVALENT ffmpeg log level is
-    // less than or equal to the current ffmpeg log level.
-    int equiv_ffmpeg_log_level = libopenh264_to_ffmpeg_log_level(level);
-    av_log(ctx, equiv_ffmpeg_log_level, "%s\n", msg);
-}
-
 static av_cold int svc_encode_close(AVCodecContext *avctx)
 {
     SVCContext *s = avctx->priv_data;
@@ -108,21 +80,15 @@ static av_cold int svc_encode_init(AVCodecContext *avctx)
 {
     SVCContext *s = avctx->priv_data;
     SEncParamExt param = { 0 };
-    int err = AVERROR_UNKNOWN;
+    int err;
     int log_level;
     WelsTraceCallback callback_function;
     AVCPBProperties *props;
 
-    // Mingw GCC < 4.7 on x86_32 uses an incorrect/buggy ABI for the WelsGetCodecVersion
-    // function (for functions returning larger structs), thus skip the check in those
-    // configurations.
-#if !defined(_WIN32) || !defined(__GNUC__) || !ARCH_X86_32 || AV_GCC_VERSION_AT_LEAST(4, 7)
-    OpenH264Version libver = WelsGetCodecVersion();
-    if (memcmp(&libver, &g_stCodecVersion, sizeof(libver))) {
-        av_log(avctx, AV_LOG_ERROR, "Incorrect library version loaded\n");
-        return AVERROR(EINVAL);
-    }
-#endif
+    if ((err = ff_libopenh264_check_version(avctx)) < 0)
+        return err;
+    // Use a default error for multiple error paths below
+    err = AVERROR_UNKNOWN;
 
     if (WelsCreateSVCEncoder(&s->encoder)) {
         av_log(avctx, AV_LOG_ERROR, "Unable to create encoder\n");
@@ -134,7 +100,7 @@ static av_cold int svc_encode_init(AVCodecContext *avctx)
     (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_LEVEL, &log_level);
 
     // Set the logging callback function to one that uses av_log() (see implementation above).
-    callback_function = (WelsTraceCallback) libopenh264_trace_callback;
+    callback_function = (WelsTraceCallback) ff_libopenh264_trace_callback;
     (*s->encoder)->SetOption(s->encoder, ENCODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);
 
     // Set the AVCodecContext as the libopenh264 callback context so that it can be passed to av_log().
-- 
2.1.4

