--- src/nccmp_data.c.org	2016-05-06 09:41:20.911219011 +0200
+++ src/nccmp_data.c	2016-05-06 09:42:58.114605626 +0200
@@ -32,14 +32,14 @@
 size_t nccmp_cmp_##NAME1##_##NAME2##_nanequal(TYPE1* in1, TYPE2* in2) {         \
     TYPE1 const *p1 = in1;                                                     \
     TYPE2 const *p2 = in2;                                                     \
-    for(; (*p1 == *p2) || (isnan(*p1) && isnan(*p2)); ++p1, ++p2) { };         \
+    for(; (*p1 == *p2) || (isnan((float)*p1) && isnan((float)*p2)); ++p1, ++p2) { };         \
     return p1 - in1;                                                           \
 }
 #define CMP_TYPES_MISSING_NANEQUAL(NAME1, TYPE1, NAME2, TYPE2)                 \
 size_t nccmp_cmp_##NAME1##_##NAME2##_missing_nanequal(TYPE1* in1, TYPE2* in2, TYPE1 m1, TYPE2 m2) { \
     TYPE1 const *p1 = in1;                                                     \
     TYPE2 const *p2 = in2;                                                     \
-    for(; (*p1 == *p2) || ((*p1 == m1) && (*p2 == m2)) || (isnan(*p1) && isnan(*p2)); ++p1, ++p2) { };       \
+    for(; (*p1 == *p2) || ((*p1 == m1) && (*p2 == m2)) || (isnan((float)*p1) && isnan((float)*p2)); ++p1, ++p2) { };       \
     return p1 - in1;                                                           \
 }
 #define CMP_TYPES_FIELD(NAME1, TYPE1, NAME2, TYPE2)                            \
@@ -71,7 +71,7 @@
     for(; i < nitems; ++i) {                                                   \
         item1 = *(TYPE1*)(p1 + size1*i + field_off1);                          \
         item2 = *(TYPE2*)(p2 + size2*i + field_off2);                          \
-        if ( (item1 != item2) && !isnan(item1) && !isnan(item2) ) {            \
+        if ( (item1 != item2) && !isnan((float)item1) && !isnan((float)item2) ) {            \
             break;                                                             \
         }                                                                      \
     };                                                                         \
@@ -105,7 +105,7 @@
     for(; i < nitems; ++i) {                                                   \
         item1 = *((TYPE1*)(p1 + field_off1) + i);                              \
         item2 = *((TYPE2*)(p2 + field_off2) + i);                              \
-        if ( (item1 != item2) && !isnan(item1) && !isnan(item2) ) {            \
+        if ( (item1 != item2) && !isnan((float)item1) && !isnan((float)item2) ) {            \
             break;                                                             \
         }                                                                      \
     };                                                                         \
@@ -1231,7 +1231,7 @@
         item2.m_##NAME2 = COMPOUND_FIELD_VALUE(items2, comp_type2->root_size,  \
         		field2->offset, TYPE2, i);             \
         if (NANEQUAL) {                                                        \
-            if ( isnan(item1.m_##NAME1) && isnan(item2.m_##NAME2) ) continue;  \
+            if ( isnan((float)item1.m_##NAME1) && isnan((float)item2.m_##NAME2) ) continue;  \
         }                                                                      \
         absdelta = fabs((double)(item1.m_##NAME1 - item2.m_##NAME2));          \
         if (state->opts.abstolerance ?                                         \
@@ -3373,7 +3373,7 @@
                         (v2->missing.m_##NAME2 == items2.p_##NAME2[i])) continue;        \
                 }                                                              \
                 if (NANEQUAL) {                                                \
-                    if ( isnan(items1.p_##NAME1[i]) && isnan(items2.p_##NAME2[i]) ) continue;      \
+                    if ( isnan((float)items1.p_##NAME1[i]) && isnan((float)items2.p_##NAME2[i]) ) continue;      \
                 }                                                              \
                 absdelta = fabs((double)(items1.p_##NAME1[i] - items2.p_##NAME2[i]));    \
                 if (state->opts.abstolerance ?                                 \
