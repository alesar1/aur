diff --git a/wingpanel/schemas/io.elementary.desktop.wingpanel.gschema.xml b/wingpanel-qq/schemas/io.elementary.desktop.wingpanel.gschema.xml
index c81abd5..890e277 100644
--- a/wingpanel/schemas/io.elementary.desktop.wingpanel.gschema.xml
+++ b/wingpanel-qq/schemas/io.elementary.desktop.wingpanel.gschema.xml
@@ -6,5 +6,23 @@
 			<summary>Sets if the panel uses transparency.</summary>
 			<description>Disable this to provide higher contrasts and make indicators better readable.</description>
 		</key>
+		<key type="s" name="autohide">
+			<choices>
+				<choice value='Autohide'/>
+				<choice value='Float'/>
+				<choice value='Dodge'/>
+				<choice value='Dodge-Float'/>
+				<choice value='Disabled'/>
+			</choices>
+			<default>'Disabled'</default>
+			<summary>Sets if and how the panel will autohide.</summary>
+			<description>Enable this to increase available desktop area and reduce clutter.</description>
+		</key>
+		<key type="i" name="delay">
+			<range min="0" max="1000"/>
+			<default>200</default>
+			<summary>Sets how long before the panel will autohide in milliseconds.</summary>
+			<description>Increase or decrease this value to your preference.</description>
+		</key>
 	</schema>
 </schemalist>
--- a/wingpanel/src/Services/Settings.vala
+++ b/wingpanel-qq/src/Services/Settings.vala
@@ -23,6 +23,10 @@ namespace Wingpanel.Services {
 
         public bool use_transparency { get; set; }
 
+        public string autohide { get; set; }
+
+        public int delay { get; set; }
+
         public PanelSettings () {
             base ("io.elementary.desktop.wingpanel");
         }
--- src/wingpanel/CMakeLists.txt~	2018-09-17 00:14:55.430071710 +0900
+++ src/wingpanel/CMakeLists.txt	2018-09-17 00:34:08.600075830 +0900
@@ -76,6 +76,7 @@
   gee-0.8
   gmodule-2.0
   gtk+-3.0
+  libwnck-3.0
 )
 
 set (LIB_PKG
@@ -84,11 +85,15 @@
   gee-0.8
   gmodule-2.0
   gtk+-3.0>=3.22
+  libwnck-3.0>=3.24
 )
 find_package(PkgConfig)
 
 pkg_check_modules (LIB REQUIRED ${LIB_PKG})
 
+add_definitions (-DWNCK_I_KNOW_THIS_IS_UNSTABLE ${WNCK_CFLAGS})
+link_libraries (${WNCK_LIBRARIES})
+
 set (GLOBAL_VALAC_OPTIONS
   --vapidir=${CMAKE_BINARY_DIR}/lib
   --vapidir=vapi
diff --git a/.travis.yml b/.travis.yml
index dddddf1..4efb6c0 100644
--- src/wingpanel/.travis.yml
+++ src/wingpanel/.travis.yml
@@ -4,7 +4,7 @@ services:
  - docker
 
 env:
- - DEPENDENCY_PACKAGES="cmake libgala-dev libgee-0.8-dev libgirepository1.0-dev libglib2.0-dev libgranite-dev libgtk-3-dev valac"
+ - DEPENDENCY_PACKAGES="cmake libgala-dev libgee-0.8-dev libgirepository1.0-dev libglib2.0-dev libgranite-dev libgtk-3-dev libwnck-3-dev valac"
 
 install:
  - docker pull elementary/docker:juno-unstable
--- src/wingpanel/src/PanelWindow.vala~	2018-09-18 22:59:21.301597018 +0900
+++ src/wingpanel/src/PanelWindow.vala	2018-09-18 23:08:18.654947952 +0900
@@ -30,6 +30,12 @@
     private bool expanded = false;
     private int panel_displacement;
     private uint shrink_timeout = 0;
+    private uint timeout;
+    private bool hiding = false;
+    private bool delay = false;
+    private string autohide = Services.PanelSettings.get_default ().autohide;
+    private int autohide_delay = Services.PanelSettings.get_default ().delay;
+    private Wnck.Screen wnck_screen = Wnck.Screen.get_default ();
 
     public PanelWindow (Gtk.Application application) {
         Object (
@@ -71,16 +77,65 @@
         application.add_accelerator ("<Control>Tab", "app.cycle", null);
         application.add_accelerator ("<Control><Shift>Tab", "app.cycle-back", null);
 
+        Services.PanelSettings.get_default ().notify["autohide"].connect (() => {
+            autohide = Services.PanelSettings.get_default ().autohide;
+            update_autohide_mode ();
+        });
+
+        Services.PanelSettings.get_default ().notify["delay"].connect (() => {
+            autohide_delay = Services.PanelSettings.get_default ().delay;
+        });
+
         add (panel);
     }
 
     private bool animation_step () {
-        if (panel_displacement <= panel_height * (-1)) {
-            return false;
+        if (hiding) {
+            if (popover_manager.current_indicator != null) {
+                timeout = 0;
+                return false;
+            }
+            if (panel_displacement >= -1) {
+                timeout = 0;
+                update_struts ();
+                this.enter_notify_event.connect (show_panel);
+                this.motion_notify_event.connect (show_panel);
+                delay = true;
+                return false;
+            }
+            panel_displacement++;
+        } else {
+            if (panel_displacement <= panel_height * (-1)) {
+                timeout = 0;
+                switch (autohide) {
+                    case "Autohide":
+                        update_struts ();
+                        this.leave_notify_event.connect (hide_panel);
+                        break;
+                    case "Float":
+                        this.leave_notify_event.connect (hide_panel);
+                        break;
+                    case "Dodge":
+                        update_struts ();
+                        if (should_hide_active_change (wnck_screen.get_active_window()))
+                            this.leave_notify_event.connect (hide_panel);
+
+                        break;
+                    case "Dodge-Float":
+                        if (should_hide_active_change (wnck_screen.get_active_window()))
+                            this.leave_notify_event.connect (hide_panel);
+
+                        break;
+                    default:
+                        this.leave_notify_event.disconnect (hide_panel);
+                        update_struts ();
+                        break;
+                }
+                return false;
+            }
+            panel_displacement--;
         }
 
-        panel_displacement--;
-
         update_panel_dimensions ();
 
         return true;
@@ -91,7 +144,126 @@
 
         Services.BackgroundManager.initialize (this.monitor_number, panel_height);
 
-        Timeout.add (300 / panel_height, animation_step);
+        update_autohide_mode ();
+    }
+
+    private void active_window_changed (Wnck.Window? prev_active_window) {
+        unowned Wnck.Window? active_window = wnck_screen.get_active_window();
+        update_visibility_active_change (active_window);
+
+        if (prev_active_window != null)
+            prev_active_window.state_changed.disconnect (active_window_state_changed);
+        if (active_window != null)
+            active_window.state_changed.connect (active_window_state_changed);
+    }
+
+    private void active_workspace_changed (Wnck.Workspace? prev_active_workspace) {
+        unowned Wnck.Window? active_window = wnck_screen.get_active_window();
+        update_visibility_active_change (active_window);
+    }
+
+    private void viewports_changed (Wnck.Screen? screen) {
+        unowned Wnck.Window? active_window = wnck_screen.get_active_window();
+        update_visibility_active_change (active_window);
+    }
+
+    private void active_window_state_changed (Wnck.Window? window,
+            Wnck.WindowState changed_mask, Wnck.WindowState new_state) {
+        update_visibility_active_change (window);
+    }
+
+    private void update_visibility_active_change (Wnck.Window? active_window) {
+        if (should_hide_active_change (active_window)) {
+            delay = false;
+            hide_panel ();
+        } else {
+            this.leave_notify_event.disconnect (hide_panel);
+            delay = false;
+            show_panel ();
+        }
+    }
+
+    private bool should_hide_active_change (Wnck.Window? active_window) {
+        unowned Wnck.Workspace active_workspace = wnck_screen.get_active_workspace ();
+
+        return ((active_window != null) && !active_window.is_minimized () && right_type (active_window)
+                && active_window.is_visible_on_workspace (active_workspace)
+                && active_window.is_in_viewport (active_workspace)
+                && is_maximized_at_all (active_window));
+    }
+
+    private bool right_type (Wnck.Window? active_window) {
+        unowned Wnck.WindowType type = active_window.get_window_type ();
+        return (type == Wnck.WindowType.NORMAL || type == Wnck.WindowType.DIALOG
+                || type == Wnck.WindowType.TOOLBAR || type == Wnck.WindowType.UTILITY);
+    }
+
+    private bool is_maximized_at_all (Wnck.Window window) {
+        return (window.is_maximized_horizontally ()
+                || window.is_maximized_vertically ()
+                || window.is_fullscreen ());
+    }
+
+    private bool hide_panel () {
+        if (timeout > 0) {
+            Source.remove (timeout);
+        }
+        hiding = true;
+        if (delay) {
+            Thread.usleep (autohide_delay * 1000);
+        }
+        timeout = Timeout.add (100 / panel_height, animation_step);
+        return true;
+    }
+
+    private bool show_panel () {
+        if (timeout > 0) {
+            Source.remove (timeout);
+        }
+        this.enter_notify_event.disconnect (show_panel);
+        this.motion_notify_event.disconnect (show_panel);
+        hiding = false;
+        if (autohide != "Disabled") {
+            if (delay) {
+                Thread.usleep (autohide_delay * 1000);
+            }
+            timeout = Timeout.add (100 / panel_height, animation_step);
+        } else {
+            timeout = Timeout.add (300 / panel_height, animation_step);
+        }
+        return true;
+    }
+
+    private void update_autohide_mode () {
+        switch (autohide) {
+            case "Autohide":
+            case "Float":
+                delay = true;
+                hide_panel ();
+                wnck_screen.active_window_changed.disconnect (active_window_changed);
+                wnck_screen.active_workspace_changed.disconnect (active_workspace_changed);
+                wnck_screen.viewports_changed.disconnect (viewports_changed);
+                break;
+            case "Dodge":
+            case "Dodge-Float":
+                delay = false;
+                if (!should_hide_active_change (wnck_screen.get_active_window())) {
+                    show_panel ();
+                    this.leave_notify_event.disconnect (hide_panel);
+                } else {
+                    hide_panel ();
+                }
+                wnck_screen.active_window_changed.connect (active_window_changed);
+                wnck_screen.active_workspace_changed.connect (active_workspace_changed);
+                wnck_screen.viewports_changed.connect (viewports_changed);
+                break;
+            default:
+                show_panel ();
+                wnck_screen.active_window_changed.disconnect (active_window_changed);
+                wnck_screen.active_workspace_changed.disconnect (active_workspace_changed);
+                wnck_screen.viewports_changed.disconnect (viewports_changed);
+                break;
+        }
     }
 
     private void update_panel_dimensions () {
@@ -111,7 +315,6 @@
 
         this.move (monitor_x, monitor_y - (panel_height + panel_displacement));
 
-        update_struts ();
     }
 
     private void update_visual () {
