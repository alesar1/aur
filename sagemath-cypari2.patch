diff --git a/src/sage/matrix/matrix_integer_dense.pxd b/src/sage/matrix/matrix_integer_dense.pxd
index bc3af7c..5dd2a8e 100644
--- a/src/sage/matrix/matrix_integer_dense.pxd
+++ b/src/sage/matrix/matrix_integer_dense.pxd
@@ -30,6 +30,5 @@ cdef class Matrix_integer_dense(Matrix_dense):
 
     cdef Matrix_integer_dense _new(self, Py_ssize_t nrows, Py_ssize_t ncols)
 
-    cdef extract_hnf_from_pari_matrix(self, GEN H, int flag, bint include_zero_rows)
 
 cpdef _lift_crt(Matrix_integer_dense M, residues, moduli=*)
diff --git a/src/sage/matrix/matrix_integer_dense.pyx b/src/sage/matrix/matrix_integer_dense.pyx
index effbb9e..ebc0519 100644
--- a/src/sage/matrix/matrix_integer_dense.pyx
+++ b/src/sage/matrix/matrix_integer_dense.pyx
@@ -87,11 +87,11 @@ from .args cimport SparseEntry, MatrixArgs_init
 #########################################################
 # PARI C library
 from cypari2.gen cimport Gen
+from cypari2.stack cimport clear_stack, new_gen
+from cypari2.paridecl cimport *
 from sage.libs.pari.convert_gmp cimport INT_to_mpz
 from sage.libs.pari.convert_flint cimport (_new_GEN_from_fmpz_mat_t,
            _new_GEN_from_fmpz_mat_t_rotate90, integer_matrix)
-from cypari2.stack cimport clear_stack
-from cypari2.paridecl cimport *
 #########################################################
 
 from sage.arith.multi_modular cimport MultiModularBasis
@@ -2016,10 +2016,7 @@ cdef class Matrix_integer_dense(Matrix_dense):
             raise ValueError("transformation matrix only available with p-adic algorithm")
         elif algorithm in ["pari", "pari0", "pari1", "pari4"]:
             flag = int(algorithm[-1]) if algorithm != "pari" else 1
-            if self.height().ndigits() > 10000 or n >= 50:
-                H_m = self._hnf_pari_big(flag, include_zero_rows=include_zero_rows)
-            else:
-                H_m = self._hnf_pari(flag, include_zero_rows=include_zero_rows)
+            H_m = self._hnf_pari(flag, include_zero_rows=include_zero_rows)
         elif algorithm == 'ntl':
             if nr != nc:
                 raise ValueError("ntl only computes HNF for square matrices of full rank.")
@@ -5676,6 +5673,7 @@ cdef class Matrix_integer_dense(Matrix_dense):
         matrices.
 
         EXAMPLES::
+
             sage: matrix(ZZ,3,[1..9])._rank_pari()
             2
         """
@@ -5686,16 +5684,12 @@ cdef class Matrix_integer_dense(Matrix_dense):
 
     def _hnf_pari(self, int flag=0, bint include_zero_rows=True):
         """
-        Hermite form of this matrix, computed using PARI.  The
-        computation is done entirely on the PARI stack, then the PARI
-        stack is cleared.  This function is only useful for small
-        matrices, and can crash on large matrices (e.g., if the PARI
-        stack overflows).
+        Hermite normal form of this matrix, computed using PARI.
 
         INPUT:
 
         - ``flag`` -- 0 (default), 1, 3 or 4 (see docstring for
-          gp.mathnf).
+          ``pari.mathnf``).
 
         - ``include_zero_rows`` -- boolean. if False, do not include
           any of the zero rows at the bottom of the matrix in the
@@ -5745,98 +5739,13 @@ cdef class Matrix_integer_dense(Matrix_dense):
             sage: pari('mathnf(Mat([0,1]), 4)')
             [Mat(1), [1, 0; 0, 1]]
         """
-        cdef GEN A
         sig_on()
         A = _new_GEN_from_fmpz_mat_t_rotate90(self._matrix)
-        cdef GEN H = mathnf0(A, flag)
-        B = self.extract_hnf_from_pari_matrix(H, flag, include_zero_rows)
-        clear_stack()  # This calls sig_off()
-        return B
-
-
-    def _hnf_pari_big(self, int flag=0, bint include_zero_rows=True):
-        """
-        Hermite form of this matrix, computed using PARI.
-
-        INPUT:
-
-        - ``flag`` -- 0 (default), 1, 3 or 4 (see docstring for
-          gp.mathnf).
-
-        - ``include_zero_rows`` -- boolean. if False, do not include
-          any of the zero rows at the bottom of the matrix in the
-          output.
-
-        .. NOTE::
-
-            In no cases is the transformation matrix returned by this
-            function.
-
-        EXAMPLES::
-
-            sage: a = matrix(ZZ,3,3,[1..9])
-            sage: a._hnf_pari_big(flag=0, include_zero_rows=True)
-            [1 2 3]
-            [0 3 6]
-            [0 0 0]
-            sage: a._hnf_pari_big(flag=1, include_zero_rows=True)
-            [1 2 3]
-            [0 3 6]
-            [0 0 0]
-            sage: a._hnf_pari_big(flag=3, include_zero_rows=True)
-            [1 2 3]
-            [0 3 6]
-            [0 0 0]
-            sage: a._hnf_pari_big(flag=4, include_zero_rows=True)
-            [1 2 3]
-            [0 3 6]
-            [0 0 0]
-
-        Check that ``include_zero_rows=False`` works correctly::
-
-            sage: matrix(ZZ,3,[1..9])._hnf_pari_big(0, include_zero_rows=False)
-            [1 2 3]
-            [0 3 6]
-            sage: matrix(ZZ,3,[1..9])._hnf_pari_big(1, include_zero_rows=False)
-            [1 2 3]
-            [0 3 6]
-            sage: matrix(ZZ,3,[1..9])._hnf_pari_big(3, include_zero_rows=False)
-            [1 2 3]
-            [0 3 6]
-            sage: matrix(ZZ,3,[1..9])._hnf_pari_big(4, include_zero_rows=False)
-            [1 2 3]
-            [0 3 6]
-        """
-        cdef Gen H = integer_matrix(self._matrix, 1)
-        H = H.mathnf(flag)
-        sig_on()
-        B = self.extract_hnf_from_pari_matrix(H.g, flag, include_zero_rows)
-        clear_stack()  # This calls sig_off()
-        return B
-
-    cdef extract_hnf_from_pari_matrix(self, GEN H, int flag, bint include_zero_rows):
-        # Throw away the transformation matrix (yes, we should later
-        # code this to keep track of it).
-        cdef mpz_t tmp
-        mpz_init(tmp)
-        if flag > 0:
-            H = gel(H,1)
-
-        # Figure out how many columns we got back.
-        cdef Py_ssize_t H_nc = glength(H)  # number of columns
-        # Now get the resulting Hermite form matrix back to Sage, suitably re-arranged.
-        cdef Matrix_integer_dense B
-        if include_zero_rows:
-            B = self.new_matrix()
-        else:
-            B = self.new_matrix(nrows=H_nc)
-        for i in range(self._ncols):
-            for j in range(H_nc):
-                INT_to_mpz(tmp, gcoeff(H, i+1, H_nc-j))
-                fmpz_set_mpz(fmpz_mat_entry(B._matrix,j,self._ncols-i-1),tmp)
-        mpz_clear(tmp)
-        return B
-
+        H = mathnf0(A, flag)
+        if typ(H) == t_VEC:
+            H = gel(H, 1)
+        GenH = new_gen(H)
+        return extract_hnf_from_pari_matrix(self, GenH, include_zero_rows)
 
     def p_minimal_polynomials(self, p, s_max=None):
         r"""
@@ -5978,7 +5887,27 @@ cdef inline GEN pari_GEN(Matrix_integer_dense B):
     return A
 
 
-    #####################################################################################
+cdef extract_hnf_from_pari_matrix(Matrix_integer_dense self, Gen H, bint include_zero_rows):
+    cdef mpz_t tmp
+    mpz_init(tmp)
+
+    # Figure out how many columns we got back.
+    cdef long H_nc = glength(H.g)  # number of columns
+    # Now get the resulting Hermite form matrix back to Sage, suitably re-arranged.
+    cdef Matrix_integer_dense B
+    if include_zero_rows:
+        B = self.new_matrix()
+    else:
+        B = self.new_matrix(nrows=H_nc)
+    cdef long i, j
+    for i in range(self._ncols):
+        for j in range(H_nc):
+            sig_check()
+            INT_to_mpz(tmp, gcoeff(H.g, i+1, H_nc-j))
+            fmpz_set_mpz(fmpz_mat_entry(B._matrix,j,self._ncols-i-1),tmp)
+    mpz_clear(tmp)
+    return B
+
 
 cdef _clear_columns(Matrix_integer_dense A, pivots, Py_ssize_t n):
     # Clear all columns
@@ -6002,11 +5931,6 @@ cdef _clear_columns(Matrix_integer_dense A, pivots, Py_ssize_t n):
     fmpz_clear(t)
     sig_off()
 
-###############################################################
-
-
-
-
 
 cpdef _lift_crt(Matrix_integer_dense M, residues, moduli=None):
     """
diff --git a/src/sage/rings/integer.pyx b/src/sage/rings/integer.pyx
index f5345c4..87f02c2 100644
--- a/src/sage/rings/integer.pyx
+++ b/src/sage/rings/integer.pyx
@@ -6815,6 +6815,7 @@ cdef class Integer(sage.structure.element.EuclideanDomainElement):
             ....:         (2^100).binomial(2^22, algorithm='pari')
             ....:     except AlarmInterrupt:
             ....:         pass
+            doctest:...: RuntimeWarning: cypari2 leaked ... bytes on the PARI stack...
         """
         cdef Integer x
         cdef Integer mm
diff --git a/src/sage/rings/number_field/maps.py b/src/sage/rings/number_field/maps.py
index 1727c13..5717227 100644
--- a/src/sage/rings/number_field/maps.py
+++ b/src/sage/rings/number_field/maps.py
@@ -358,7 +358,7 @@ class MapRelativeNumberFieldToRelativeVectorSpace(NumberFieldIsomorphism):
             g = g(beta).lift()
         # Convert the coefficients to elements of the base field.
         B, from_B, _ = K.absolute_base_field()
-        return self.codomain()([from_B(B(z.lift(), check=False)) for z in g.Vecrev(-K.relative_degree())])
+        return self.codomain()([from_B(B(z.lift(), check=False)) for z in g.Vecrev(K.relative_degree())])
 
 
 class NameChangeMap(NumberFieldIsomorphism):
diff --git a/src/sage/rings/polynomial/polynomial_element.pyx b/src/sage/rings/polynomial/polynomial_element.pyx
index f956927..ae42664 100644
--- a/src/sage/rings/polynomial/polynomial_element.pyx
+++ b/src/sage/rings/polynomial/polynomial_element.pyx
@@ -4372,8 +4372,7 @@ cdef class Polynomial(CommutativeAlgebraElement):
             sage: G.prod() == g
             True
         """
-        pols = G[0]
-        exps = G[1]
+        pols, exps = G
         R = self._parent
         F = [(R(f), int(e)) for f, e in zip(pols, exps)]
 
diff --git a/src/sage/rings/power_series_pari.pyx b/src/sage/rings/power_series_pari.pyx
index e37e0a3..2e03ade 100644
--- a/src/sage/rings/power_series_pari.pyx
+++ b/src/sage/rings/power_series_pari.pyx
@@ -678,7 +678,8 @@ cdef class PowerSeries_pari(PowerSeries):
             g = g.truncate()
         if typ(g.g) == t_POL and varn(g.g) == vn:
             # t_POL has 2 codewords.  Use new_ref instead of g[i] for speed.
-            return [R(g.new_ref(gel(g.g, i))) for i in range(2, lg(g.g))]
+            G = g.fixGEN()
+            return [R(g.new_ref(gel(G, i))) for i in range(2, lg(G))]
         else:
             return [R(g)]
 
@@ -729,6 +730,7 @@ cdef class PowerSeries_pari(PowerSeries):
             return []
 
         cdef pari_gen g = self.g
+        g.fixGEN()
         cdef long l, m
 
         R = self.base_ring()

