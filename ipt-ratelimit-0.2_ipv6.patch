diff -Naupr ipt-ratelimit-0.2/compat.h ipt-ratelimit/compat.h
--- ipt-ratelimit-0.2/compat.h	2018-08-07 19:41:05.850529224 +0700
+++ ipt-ratelimit/compat.h	2018-08-07 19:44:15.298790466 +0700
@@ -41,3 +41,10 @@ static inline struct inode *file_inode(c
 #if LINUX_VERSION_CODE < KERNEL_VERSION(3, 10, 0)
 # define PDE_DATA(inode) PDE(inode)->data
 #endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+static inline u_int8_t xt_family(const struct xt_action_param *par)
+{
+		return par->family;
+}
+#endif
diff -Naupr ipt-ratelimit-0.2/CREDITS ipt-ratelimit/CREDITS
--- ipt-ratelimit-0.2/CREDITS	2018-08-07 19:41:05.850529224 +0700
+++ ipt-ratelimit/CREDITS	2018-08-07 19:44:15.295457044 +0700
@@ -45,7 +45,7 @@ Sign-off rule is that of the Linux kerne
 
 Principal author and project maintainer:
 
-   ABC <abc@telekom.ru> [2015]
+   ABC <abc@telekom.ru> [2015-2017]
 
 
 xt_hashlimit and xt_recent implementation from Linux Kernel is used for
diff -Naupr ipt-ratelimit-0.2/libxt_ratelimit.c ipt-ratelimit/libxt_ratelimit.c
--- ipt-ratelimit-0.2/libxt_ratelimit.c	2018-08-07 19:40:57.380312457 +0700
+++ ipt-ratelimit/libxt_ratelimit.c	2018-08-07 19:44:15.298790466 +0700
@@ -1,6 +1,6 @@
 /*
  * An implementation of committed access rate for Linux iptables
- * (c) 2015 <abc@telekom.ru>
+ * (c) 2015-2017 <abc@telekom.ru>
  *
  *
  *   This program is free software: you can redistribute it and/or modify
@@ -132,6 +132,19 @@ static struct xtables_match ratelimit_mt
 		.size		= XT_ALIGN(sizeof(struct xt_ratelimit_mtinfo)),
 		.userspacesize	= offsetof(struct xt_ratelimit_mtinfo, ht),
 		.help		= ratelimit_help,
+		.init		= ratelimit_init,
+		.print		= ratelimit_print,
+		.save		= ratelimit_save,
+		.x6_options	= ratelimit_opts,
+		.x6_parse	= ratelimit_parse,
+	},
+	{
+		.name		= "ratelimit",
+		.version	= XTABLES_VERSION,
+		.family		= NFPROTO_IPV6,
+		.size		= XT_ALIGN(sizeof(struct xt_ratelimit_mtinfo)),
+		.userspacesize	= offsetof(struct xt_ratelimit_mtinfo, ht),
+		.help		= ratelimit_help,
 		.init		= ratelimit_init,
 		.print		= ratelimit_print,
 		.save		= ratelimit_save,
diff -Naupr ipt-ratelimit-0.2/Makefile ipt-ratelimit/Makefile
--- ipt-ratelimit-0.2/Makefile	2018-08-07 19:41:05.850529224 +0700
+++ ipt-ratelimit/Makefile	2018-08-07 19:44:15.295457044 +0700
@@ -32,7 +32,7 @@ version.h: xt_ratelimit.c xt_ratelimit.h
 	@./version.sh --define > version.h
 
 clean:
-	make -C $(KDIR) M=$(CURDIR) clean
+	-make -C $(KDIR) M=$(CURDIR) clean
 	-rm -f *.so *_sh.o *.o modules.order
 
 install: | minstall linstall
@@ -50,19 +50,20 @@ uninstall:
 load: all
 	-sync
 	-modprobe x_tables
-	-insmod xt_ratelimit.ko
-	-iptables -I INPUT  -m ratelimit --ratelimit-set src --ratelimit-mode src -j DROP
-	-iptables -I OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
+	-insmod ./xt_ratelimit.ko
+	-iptables  -I INPUT  -m ratelimit --ratelimit-set src --ratelimit-mode src -j DROP
+	-iptables  -I OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
+	-ip6tables -I OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
 	-echo +127.0.0.1 1000000 > /proc/net/ipt_ratelimit/src
 	-echo +127.0.0.1/24 1000000 > /proc/net/ipt_ratelimit/dst
-	-echo +127.0.0.1/16 1000000 > /proc/net/ipt_ratelimit/dst
+	-echo +127.2.0.1/16 1000000 > /proc/net/ipt_ratelimit/dst
 	-echo +127.0.0.1/8 1000000 > /proc/net/ipt_ratelimit/dst
-	-echo +127.0.0.1/0 1000000 > /proc/net/ipt_ratelimit/dst
-	-echo +127.0.0.1 1000000 > /proc/net/ipt_ratelimit/dst
+	-echo +::1 1000000 > /proc/net/ipt_ratelimit/dst
 unload:
 	-echo / > /proc/net/ipt_ratelimit/src
-	-iptables -D INPUT  -m ratelimit --ratelimit-set src --ratelimit-mode src -j DROP
-	-iptables -D OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
+	-iptables  -D INPUT  -m ratelimit --ratelimit-set src --ratelimit-mode src -j DROP
+	-iptables  -D OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
+	-ip6tables -D OUTPUT -m ratelimit --ratelimit-set dst --ratelimit-mode dst -j DROP
 	-rmmod xt_ratelimit.ko
 del:
 	-sync
diff -Naupr ipt-ratelimit-0.2/NEWS ipt-ratelimit/NEWS
--- ipt-ratelimit-0.2/NEWS	2015-11-13 18:37:51.000000000 +0600
+++ ipt-ratelimit/NEWS	2018-08-07 19:44:15.295457044 +0700
@@ -1,6 +1,17 @@
 ipt-ratelimit NEWS
 ==================
 
+0.3 (2017-05-10)
+
+    * Support for CIDR notation.
+    * Support for IPv6.
+
+0.2 (2015-11-13)
+
+    * Allow to hide warning messages.
+    * Allow updating of existing rules.
+    * Can specify behavior for 'not matched' packets.
+    * Code audit.
 
 0.1 (2015-09-20)
 
diff -Naupr ipt-ratelimit-0.2/README ipt-ratelimit/README
--- ipt-ratelimit-0.2/README	2018-08-07 19:41:05.850529224 +0700
+++ ipt-ratelimit/README	2018-08-07 19:44:15.295457044 +0700
@@ -1,8 +1,8 @@
-ipt-ratelimit linux kernel module by <abc@telekom.ru> -- (c) 2015.
+ipt-ratelimit linux kernel module by <abc@telekom.ru> -- (c) 2015-2017.
 
    An high-performance implementation of committed access rate, or simply rate
    limiting, or policing for Linux iptables. Suitable for a lot of users
-   (similar to ipset) and does not have qdisc limitations.
+   (similar to ipset) and does not have qdisc limitations. Supports IPv6.
 
 
 ============
@@ -17,6 +17,8 @@ ipt-ratelimit linux kernel module by <ab
   Module is compatible with recent linux distributions such as Debian 7, 8,
   Centos 7, and Linux kernel 3.x or above.
 
+  Does support IPv6, thus useful for dual-stack policing.
+
 
 ================
 = INSTALLATION =
@@ -82,7 +84,7 @@ ipt-ratelimit linux kernel module by <ab
 
     * To add IPs or CIDRs to the set write string in the following format:
 
-       +IPv4[,CIDR...] bitrate [normal_burst [extended_burst]]
+       +IPv4[,IPv6,CIDR...] bitrate [normal_burst [extended_burst]]
 
     Examples:
 
diff -Naupr ipt-ratelimit-0.2/xt_ratelimit.c ipt-ratelimit/xt_ratelimit.c
--- ipt-ratelimit-0.2/xt_ratelimit.c	2018-08-07 19:41:05.850529224 +0700
+++ ipt-ratelimit/xt_ratelimit.c	2018-08-07 19:44:15.298790466 +0700
@@ -1,6 +1,6 @@
 /*
  * An implementation of committed access rate for Linux iptables
- * (c) 2015 <abc@telekom.ru>
+ * (c) 2015-2017 <abc@telekom.ru>
  *
  * Based on xt_hashlimit and in lesser extent on xt_recent.
  *
@@ -34,6 +34,7 @@
 #include <linux/inet.h>
 #include <linux/in.h>
 #include <linux/ip.h>
+#include <linux/ipv6.h>
 #include <net/net_namespace.h>
 #include <net/netns/generic.h>
 #include <linux/netfilter/x_tables.h>
@@ -43,7 +44,7 @@
 #include "compat.h"
 #include "xt_ratelimit.h"
 
-#define XT_RATELIMIT_VERSION "0.2"
+#define XT_RATELIMIT_VERSION "0.3"
 #include "version.h"
 #ifdef GIT_VERSION
 # undef XT_RATELIMIT_VERSION
@@ -55,6 +56,7 @@ MODULE_DESCRIPTION("iptables ratelimit p
 MODULE_LICENSE("GPL");
 MODULE_VERSION(XT_RATELIMIT_VERSION);
 MODULE_ALIAS("ipt_ratelimit");
+MODULE_ALIAS("ip6t_ratelimit");
 
 #define RATE_ESTIMATOR			/* average rate estimator */
 
@@ -107,8 +109,9 @@ struct ratelimit_stat {
 /* hash bucket match entry */
 struct ratelimit_match {
 	struct hlist_node node;		/* hash bucket list */
-	__be32 addr;
+	u8 family;
 	u8 prefix;
+	union nf_inet_addr addr;
 	struct ratelimit_ent *ent;	/* owner struct, where they are stored in array */
 };
 
@@ -125,8 +128,12 @@ struct ratelimit_ent {
 	struct ratelimit_match matches[0];
 };
 
-#define MAX_PREFIX 32
-#define NUM_PREFIX (MAX_PREFIX + 1)
+#define MAX_PREFIX4 32
+#define NUM_PREFIX4 (MAX_PREFIX4 + 1)
+#define MAX_PREFIX6 128
+#define NUM_PREFIX6 (MAX_PREFIX6 + 1)
+#define MAX_PREFIX  MAX_PREFIX6
+#define NUM_PREFIX  NUM_PREFIX6
 
 /* per-net named hash table, locked with ratelimit_mutex */
 struct xt_ratelimit_htable {
@@ -172,8 +179,7 @@ unsigned long calc_rate_est(const struct
 	{
 		const unsigned int slot_delta_rtime = RATEST_JIFFIES - (now % RATEST_JIFFIES);
 #define SMOOTH_VAUE 10 /* smoothen integer arithmetics */
-		const unsigned int prev_ratio = (slot_delta_rtime)?
-			RATEST_JIFFIES * SMOOTH_VAUE / slot_delta_rtime : SMOOTH_VAUE;
+		const unsigned int prev_ratio = RATEST_JIFFIES * SMOOTH_VAUE / slot_delta_rtime;
 
 		bps = bps * SMOOTH_VAUE / prev_ratio;
 		bps += cur_bytes;
@@ -199,11 +205,15 @@ static int ratelimit_seq_ent_show(struct
 	for (i = 0; i < ent->mtcnt; i++) {
 		struct ratelimit_match *mti = &ent->matches[i];
 
-		seq_printf(s, "%s%pI4",
-		    i == 0? "" : ",",
-		    &mti->addr);
-		if (mti->prefix != 32)
-			seq_printf(s, "/%d", mti->prefix);
+		if (mti->family == AF_INET6) {
+			seq_printf(s, "%s%pI6c", i == 0? "" : ",", &mti->addr);
+			if (mti->prefix != 128)
+				seq_printf(s, "/%d", mti->prefix);
+		} else {
+			seq_printf(s, "%s%pI4", i == 0? "" : ",", &mti->addr);
+			if (mti->prefix != 32)
+				seq_printf(s, "/%d", mti->prefix);
+		}
 	}
 	seq_printf(s, " cir %u cbs %u ebs %u;",
 	    ent->car.cir * (HZ * BITS_PER_BYTE), ent->car.cbs, ent->car.ebs);
@@ -317,9 +327,41 @@ static inline u32 bits2mask(int bits) {
 static void ratelimit_table_flush(struct xt_ratelimit_htable *ht);
 static struct ratelimit_ent *ratelimit_ent_zalloc(int msize);
 static inline struct ratelimit_ent *ratelimit_match_find(const struct xt_ratelimit_htable *ht, const __be32 addr, const u8 prefix);
+static inline struct ratelimit_ent *ratelimit_match_find6(const struct xt_ratelimit_htable *ht, const union nf_inet_addr *addr, const u8 prefix);
 static void ratelimit_ent_add(struct xt_ratelimit_htable *ht, struct ratelimit_ent *ent);
 static void ratelimit_ent_del(struct xt_ratelimit_htable *ht, struct ratelimit_ent *ent);
 
+/* convert ipv4 or ipv6 address string into struct sockaddr */
+int in_pton(const char *src, int srclen, struct sockaddr_storage *dst, int delim, const char **end)
+{
+	if (in4_pton(src, srclen, (u8 *)&((struct sockaddr_in *)dst)->sin_addr, delim, end)) {
+		dst->ss_family = AF_INET;
+		return 1;
+	} else if (in6_pton(src, srclen, (u8 *)&((struct sockaddr_in6 *)dst)->sin6_addr, delim, end)) {
+		dst->ss_family = AF_INET6;
+		return 1;
+	} else
+		return 0;
+}
+
+static __be32 set_netmask(short prefix)
+{
+	if (prefix <= 0)
+		return 0;
+	else if (prefix >= 32)
+		return 0xffffffff;
+	else
+		return htonl(0xffffffff << (32 - prefix));
+}
+
+static void set_mask6(union nf_inet_addr *ip, u8 prefix)
+{
+	ip->ip6[0] = set_netmask((short)prefix);
+	ip->ip6[1] = set_netmask((short)prefix - 32);
+	ip->ip6[2] = set_netmask((short)prefix - 64);
+	ip->ip6[3] = set_netmask((short)prefix - 96);
+}
+
 static int parse_rule(struct xt_ratelimit_htable *ht, char *str, size_t size)
 {
 	char * const buf = str; /* for logging only */
@@ -327,7 +369,7 @@ static int parse_rule(struct xt_ratelimi
 	const char * const endp = str + size;
 	struct ratelimit_ent *ent;	/* new entry */
 	struct ratelimit_ent *ent_chk;	/* old entry */
-	__be32 addr;
+	struct sockaddr_storage addr;
 	int ent_size;
 	int add;
 	int i;
@@ -388,7 +430,7 @@ static int parse_rule(struct xt_ratelimi
 	/* determine address set size */
 	ent_size = 0;
 	for (p = str;
-	    p < endp && *p && (ptok = in4_pton(p, size - (p - str), (u8 *)&addr, -1, &p));
+	    p < endp && *p && (ptok = in_pton(p, size - (p - str), &addr, -1, &p));
 	    ++p) {
 		++ent_size;
 		if ((p + 1) < endp && *p == '/')
@@ -412,29 +454,45 @@ static int parse_rule(struct xt_ratelimi
 
 	spin_lock_init(&ent->lock_bh);
 	for (i = 0, p = str;
-	    p < endp && *p && in4_pton(p, size - (p - str), (u8 *)&addr, -1, &p);
+	    p < endp && *p && in_pton(p, size - (p - str), &addr, -1, &p);
 	    ++p, ++i) {
 		struct ratelimit_match *mt = &ent->matches[i];
 		int j;
-		unsigned int pfx = 32;
+		unsigned int prefix = -1;
 		const char *pref;
+		union nf_inet_addr mask;
 
 		BUG_ON(i >= ent_size);
 		if ((p + 1) < endp && *p == '/') {
 			for (++p, pref = p; p < endp && *p >= '0' && *p <= '9'; ++p);
-			pfx = simple_strtoul(pref, NULL, 10);
-			if (pfx > 32)
-				pfx = 32;
+			prefix = simple_strtoul(pref, NULL, 10);
+		}
+		mt->family = addr.ss_family;
+		if (mt->family == AF_INET6) {
+			if (prefix > 128)
+				prefix = 128;
+			memcpy(mt->addr.ip6, &((struct sockaddr_in6 *)&addr)->sin6_addr, sizeof(mt->addr.ip6));
+		} else {
+			if (prefix > 32)
+			       prefix = 32;
+			mt->addr.ip = ((struct sockaddr_in *)&addr)->sin_addr.s_addr;
 		}
-		mt->addr = addr & htonl(bits2mask(pfx));
-		mt->prefix = pfx;
+
+		/* following works both for ip and ip6, also cleaning stale bits,
+		 * and they assumed to be clean in the below memcmp */
+		set_mask6(&mask, prefix);
+		for (j = 0; j < ARRAY_SIZE(mt->addr.ip6); ++j)
+			mt->addr.ip6[j] &= mask.ip6[j];
+
+		mt->prefix = prefix;
 		mt->ent = ent;
 		++ent->mtcnt;
 		/* there should not be duplications,
 		 * this is also important for below test of mtcnt */
 		for (j = 0; j < i; ++j)
-			if (ent->matches[j].addr == addr) {
-				pr_err("Duplicated IP address %pI4 in list (cmd: %s)\n", &addr, buf);
+			if (ent->matches[j].family == mt->family &&
+			    !memcmp(ent->matches[j].addr.ip6, mt->addr.ip6, sizeof(mt->addr.ip6))) {
+				pr_err("Duplicated IP address %pISc in list (cmd: %s)\n", &addr, buf);
 				kvfree(ent);
 				return -EINVAL;
 			}
@@ -492,13 +550,20 @@ static int parse_rule(struct xt_ratelimi
 		struct ratelimit_match *mt = &ent->matches[i];
 		struct ratelimit_ent *tent;
 
-		tent = ratelimit_match_find(ht, mt->addr, mt->prefix);
+		if (mt->family == AF_INET6)
+			tent = ratelimit_match_find6(ht, &mt->addr, mt->prefix);
+		else
+			tent = ratelimit_match_find(ht, mt->addr.ip, mt->prefix);
 		if (!ent_chk)
 			ent_chk = tent;
 		if (tent != ent_chk) {
 			/* no operation should reference multiple entries */
-			pr_err("IP address %pI4 from multiple rules (cmd: %s)\n",
-			    &mt->addr,  buf);
+			if (mt->family == AF_INET6)
+				pr_err("IP address %pI6c from multiple rules (cmd: %s)\n",
+				    &mt->addr,  buf);
+			else
+				pr_err("IP address %pI4 from multiple rules (cmd: %s)\n",
+				    &mt->addr,  buf);
 			goto unlock_einval;
 		}
 	}
@@ -654,10 +719,15 @@ hash_addr(const struct xt_ratelimit_htab
 	return reciprocal_scale(jhash_1word(addr, 0), ht->size);
 }
 
+static inline u_int32_t
+hash_addr6(const struct xt_ratelimit_htable *ht, const __be32 addr[])
+{
+	return reciprocal_scale(jhash2(addr, 4, 0), ht->size);
+}
+
 /* get (car) entity by address */
 static inline struct ratelimit_ent *
-ratelimit_match_find(const struct xt_ratelimit_htable *ht,
-    const __be32 addr, const u8 prefix)
+ratelimit_match_find(const struct xt_ratelimit_htable *ht, const __be32 addr, const u8 prefix)
 {
 	const __be32 mask = htonl(bits2mask(prefix));
 	const __be32 addr_masked = addr & mask;
@@ -669,7 +739,37 @@ ratelimit_match_find(const struct xt_rat
 		struct hlist_node *pos;
 #endif
 		compat_hlist_for_each_entry_rcu(mt, pos, &ht->hash[hash], node) {
-			if (mt->addr == addr_masked && mt->prefix == prefix)
+			if (mt->family == AF_INET &&
+			    mt->prefix == prefix &&
+			    mt->addr.ip == addr_masked)
+				return mt->ent;
+		}
+	}
+	return NULL;
+}
+
+static inline struct ratelimit_ent *
+ratelimit_match_find6(const struct xt_ratelimit_htable *ht, const union nf_inet_addr *addr, const u8 prefix)
+{
+	union nf_inet_addr mask;
+	union nf_inet_addr addr_masked;
+	u_int32_t hash;
+	unsigned int i;
+
+	set_mask6(&mask, prefix);
+	for (i = 0; i < ARRAY_SIZE(addr->ip6); ++i)
+		addr_masked.ip6[i] = addr->ip6[i] & mask.ip6[i];
+	hash = hash_addr6(ht, addr_masked.ip6);
+
+	if (!hlist_empty(&ht->hash[hash])) {
+		struct ratelimit_match *mt;
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3,9,0)
+		struct hlist_node *pos;
+#endif
+		compat_hlist_for_each_entry_rcu(mt, pos, &ht->hash[hash], node) {
+			if (mt->family == AF_INET6 &&
+			    mt->prefix == prefix &&
+			    !memcmp(&mt->addr, &addr_masked, sizeof(addr->ip6)))
 				return mt->ent;
 		}
 	}
@@ -708,13 +808,14 @@ static void ratelimit_match_free(struct
 	/* under ht->lock */
 {
 	struct ratelimit_ent *ent = mt->ent;
+	const unsigned int max_prefix = (mt->family == AF_INET6)? MAX_PREFIX6 : MAX_PREFIX4;
 
 	hlist_del_rcu(&mt->node);
 	BUG_ON(ht->mt_count == 0);
 	--ht->mt_count;
 
 	if (--ht->prefix_count[mt->prefix] == 0)
-		clear_bit(MAX_PREFIX - mt->prefix, ht->prefix_bitmap);
+		clear_bit(max_prefix - mt->prefix, ht->prefix_bitmap);
 
 	BUG_ON(ent->mtcnt == 0);
 	if (--ent->mtcnt == 0) {
@@ -778,11 +879,16 @@ static void ratelimit_ent_add(struct xt_
 	/* add each match address into htable hash */
 	for (i = 0; i < ent->mtcnt; i++) {
 		struct ratelimit_match *mt = &ent->matches[i];
+		const u_int32_t hash = (mt->family == AF_INET6) ?
+			hash_addr6(ht, mt->addr.ip6) : hash_addr(ht, mt->addr.ip);
+		const unsigned int max_prefix = (mt->family == AF_INET6)? MAX_PREFIX6 : MAX_PREFIX4;
 
-		hlist_add_head_rcu(&mt->node, &ht->hash[hash_addr(ht, mt->addr)]);
+		hlist_add_head_rcu(&mt->node, &ht->hash[hash]);
 		ht->mt_count++;
+		/* mark bits in reverse order, becasue I need to search
+		 * from highest mask to lowest */
 		if (++ht->prefix_count[mt->prefix] == 1)
-			set_bit(MAX_PREFIX - mt->prefix, ht->prefix_bitmap);
+			set_bit(max_prefix - mt->prefix, ht->prefix_bitmap);
 	}
 	ht->ent_count++;
 }
@@ -867,20 +973,33 @@ ratelimit_mt(const struct sk_buff *skb,
 	struct xt_ratelimit_htable *ht = mtinfo->ht;
 	struct ratelimit_ent *ent = NULL;
 	const unsigned long now = jiffies;
-	__be32 addr;
+	union nf_inet_addr addr;
+	const u8 family = xt_family(par);
 	int invprefix;
 	int match = false; /* no match, no drop */
 
-	if (mtinfo->mode & XT_RATELIMIT_DST)
-		addr = ip_hdr(skb)->daddr;
-	else
-		addr = ip_hdr(skb)->saddr;
+	if (unlikely(family == NFPROTO_IPV6)) {
+		const struct ipv6hdr *iph = ipv6_hdr(skb);
+		memcpy(addr.ip6, (mtinfo->mode & XT_RATELIMIT_DST) ?
+		    &iph->daddr : &iph->saddr, sizeof(addr.ip6));
+	} else {
+		const struct iphdr *iph = ip_hdr(skb);
+		addr.ip = (mtinfo->mode & XT_RATELIMIT_DST) ?
+			iph->daddr : iph->saddr;
+	}
 
 	rcu_read_lock();
 	/* first match from longest prefix upwards */
-	for_each_set_bit(invprefix, ht->prefix_bitmap, NUM_PREFIX) {
-		if ((ent = ratelimit_match_find(ht, addr, MAX_PREFIX - invprefix)))
-			break;
+	if (unlikely(family == NFPROTO_IPV6)) {
+		for_each_set_bit(invprefix, ht->prefix_bitmap, NUM_PREFIX6) {
+			if ((ent = ratelimit_match_find6(ht, &addr, MAX_PREFIX6 - invprefix)))
+				break;
+		}
+	} else {
+		for_each_set_bit(invprefix, ht->prefix_bitmap, NUM_PREFIX4) {
+			if ((ent = ratelimit_match_find(ht, addr.ip, MAX_PREFIX4 - invprefix)))
+				break;
+		}
 	}
 	if (ent) {
 		struct ratelimit_car *car = &ent->car;
@@ -959,7 +1078,7 @@ static void ratelimit_mt_destroy(const s
 static struct xt_match ratelimit_mt_reg[] __read_mostly = {
 	{
 		.name		= "ratelimit",
-		.family		= NFPROTO_IPV4,
+		.family		= NFPROTO_UNSPEC,
 		.match		= ratelimit_mt,
 		.matchsize	= sizeof(struct xt_ratelimit_mtinfo),
 		.checkentry	= ratelimit_mt_check,
