--- a/lib/extras/codec_exr.cc
+++ b/lib/extras/codec_exr.cc
@@ -32,6 +32,12 @@ namespace {
 namespace OpenEXR = OPENEXR_IMF_NAMESPACE;
 namespace Imath = IMATH_NAMESPACE;
 
+// OpenEXR::Int64 is deprecated in favor of using uint64_t directly, but using
+// uint64_t as recommended causes build failures with previous OpenEXR versions
+// on macOS, where the definition for OpenEXR::Int64 was actually not equivalent
+// to uint64_t. This alternative should work in all cases.
+using ExrInt64 = decltype(std::declval<OpenEXR::IStream>().tellg());
+
 constexpr int kExrBitsPerSample = 16;
 constexpr int kExrAlphaBits = 16;
 
@@ -90,8 +96,8 @@ class InMemoryIStream : public OpenEXR::IStream {
     return pos_ < bytes_.size();
   }
 
-  OpenEXR::Int64 tellg() override { return pos_; }
-  void seekg(const OpenEXR::Int64 pos) override {
+  ExrInt64 tellg() override { return pos_; }
+  void seekg(const ExrInt64 pos) override {
     JXL_ASSERT(pos + 1 <= bytes_.size());
     pos_ = pos;
   }
@@ -115,8 +121,8 @@ class InMemoryOStream : public OpenEXR::OStream {
     pos_ += n;
   }
 
-  OpenEXR::Int64 tellp() override { return pos_; }
-  void seekp(const OpenEXR::Int64 pos) override {
+  ExrInt64 tellp() override { return pos_; }
+  void seekp(const ExrInt64 pos) override {
     if (bytes_.size() + 1 < pos) {
       bytes_.resize(pos - 1);
     }
