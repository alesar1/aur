diff --git b/_studio/mfx_lib/plugin/include/plugin_version_linux.h a/_studio/mfx_lib/plugin/include/plugin_version_linux.h
index 9044967..731feae 100644
--- b/_studio/mfx_lib/plugin/include/plugin_version_linux.h
+++ a/_studio/mfx_lib/plugin/include/plugin_version_linux.h
@@ -39,7 +39,7 @@
 
 
 const char* g_MfxProductName = "mediasdk_product_name: " MFX_PLUGIN_PRODUCT_NAME;
-const char* g_MfxCopyright = "mediasdk_copyright: Copyright(c) 2007-2018 Intel Corporation";
+const char* g_MfxCopyright = "mediasdk_copyright: Copyright(c) 2007-2017 Intel Corporation";
 
 #if defined(HEVCD_EVALUATION) || defined(HEVCE_EVALUATION)
 const char* g_MfxProductVersion = "mediasdk_product_version: " MFX_PLUGIN_PRODUCT_VERSION " Evaluation version";
diff --git b/_studio/mfx_lib/shared/src/libmfxsw.cpp a/_studio/mfx_lib/shared/src/libmfxsw.cpp
index b0743c5..01d13bb 100644
--- b/_studio/mfx_lib/shared/src/libmfxsw.cpp
+++ a/_studio/mfx_lib/shared/src/libmfxsw.cpp
@@ -51,7 +51,7 @@ void* g_hModule = NULL; // DLL handle received in DllMain
 
 #if defined(LINUX_TARGET_PLATFORM_BDW)
 const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media SDK";
-#elif defined(LINUX_TARGET_PLATFORM_BXT)
+#elif defined(LINUX_TARGET_PLATFORM_BXT) || defined (LINUX_TARGET_PLATFORM_BXTMIN)
 const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media SDK 2017 for Embedded Linux";
 #else
 const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media Server Studio - SDK for Linux*";
@@ -64,14 +64,14 @@ const char* g_MfxProductVersion = "mediasdk_product_version: " MFX_PRODUCT_VERSI
 #endif // mfxhwXX_EXPORTS
 #if defined(mfxaudiosw64_EXPORTS) || defined(mfxaudiosw32_EXPORTS)
 #if defined(LINUX_TARGET_PLATFORM_BDW)
-const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media Server Studio 2018 - Audio for Linux*";
-#elif defined(LINUX_TARGET_PLATFORM_BXT)
+const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media Server Studio 2017 - Audio for Linux*";
+#elif defined(LINUX_TARGET_PLATFORM_BXT) || defined (LINUX_TARGET_PLATFORM_BXTMIN)
 const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media SDK 2017 for Embedded Linux";
 #else
 const char* g_MfxProductName = "mediasdk_product_name: Intel(R) Media Server Studio - Audio for Linux*";
 #endif
 
-const char* g_MfxCopyright = "mediasdk_copyright: Copyright(c) 2014-2018 Intel Corporation";
+const char* g_MfxCopyright = "mediasdk_copyright: Copyright(c) 2014-2017 Intel Corporation";
 const char* g_MfxFileVersion = "mediasdk_file_version: " MFX_FILE_VERSION;
 const char* g_MfxProductVersion = "mediasdk_product_version: " MFX_PRODUCT_VERSION;
 
diff --git b/_studio/mfx_lib/shared/src/mfx_h264_encode_vaapi.cpp a/_studio/mfx_lib/shared/src/mfx_h264_encode_vaapi.cpp
index 7d655bb..9d60f06 100644
--- b/_studio/mfx_lib/shared/src/mfx_h264_encode_vaapi.cpp
+++ a/_studio/mfx_lib/shared/src/mfx_h264_encode_vaapi.cpp
@@ -1400,7 +1400,7 @@ mfxStatus VAAPIEncoder::CreateAuxilliaryDevice(
         m_caps.MaxNum_Reference1 = 1;
     }
 
-#if defined(LINUX_TARGET_PLATFORM_BXT)
+#if defined(LINUX_TARGET_PLATFORM_BXTMIN) || defined(LINUX_TARGET_PLATFORM_BXT) || defined (LINUX_TARGET_PLATFORM_CFL)
     // Officially only APL and CFL supports ROI.
 
     if (attrs[idx_map[VAConfigAttribEncROI]].value != VA_ATTRIB_NOT_SUPPORTED)
@@ -2102,6 +2102,7 @@ mfxStatus VAAPIEncoder::Execute(
         if (frameCtrl->PerMBQp && mbqp != NULL)
         {
             MFX_AUTO_LTRACE(MFX_TRACE_LEVEL_EXTCALL, "vaCreateBuffer (MBqp)");
+#if MFX_VERSION >= 1023
             vaSts = vaCreateBuffer(m_vaDisplay,
                     m_vaContextEncode,
                     (VABufferType)VAEncQPBufferType,
@@ -2109,6 +2110,15 @@ mfxStatus VAAPIEncoder::Execute(
                     1, //limitation from driver, num elements should be 1
                     mbqp->MB,
                     &vaFeiMBQPId);
+#else
+            vaSts = vaCreateBuffer(m_vaDisplay,
+                    m_vaContextEncode,
+                    (VABufferType)VAEncQPBufferType,
+                    sizeof (VAEncQPBufferH264)*mbqp->NumQPAlloc,
+                    1, //limitation from driver, num elements should be 1
+                    mbqp->QP,
+                    &vaFeiMBQPId);
+#endif
             MFX_CHECK_WITH_ASSERT(VA_STATUS_SUCCESS == vaSts, MFX_ERR_DEVICE_FAILED);
         }
 
@@ -2347,7 +2357,7 @@ mfxStatus VAAPIEncoder::Execute(
         // SEI
         if (sei.Size() > 0)
         {
-            packed_header_param_buffer.type = VAEncPackedHeaderH264_SEI;
+            packed_header_param_buffer.type = VAEncPackedHeaderRawData;
             packed_header_param_buffer.has_emulation_bytes = 1;
             packed_header_param_buffer.bit_length = sei.Size()*8;
 
@@ -2478,7 +2488,7 @@ mfxStatus VAAPIEncoder::Execute(
         // SEI
         if (sei.Size() > 0)
         {
-            packed_header_param_buffer.type = VAEncPackedHeaderH264_SEI;
+            packed_header_param_buffer.type = VAEncPackedHeaderRawData;
             packed_header_param_buffer.has_emulation_bytes = 1;
             packed_header_param_buffer.bit_length = sei.Size()*8;
 
@@ -2625,7 +2635,7 @@ mfxStatus VAAPIEncoder::Execute(
                                                           m_vaContextEncode, m_maxFrameSizeId), MFX_ERR_DEVICE_FAILED);
     configBuffers[buffersCount++] = m_maxFrameSizeId;
 
-#if !defined(MFX_VA_ANDROID)
+#if !defined(ANDROID)
 /*
  *  By default (0) - driver will decide.
  *  1 - disable trellis quantization
diff --git b/_studio/mfx_lib/shared/src/mfx_h264_fei_vaapi.cpp a/_studio/mfx_lib/shared/src/mfx_h264_fei_vaapi.cpp
index 8d891b5..8e0a020 100644
--- b/_studio/mfx_lib/shared/src/mfx_h264_fei_vaapi.cpp
+++ a/_studio/mfx_lib/shared/src/mfx_h264_fei_vaapi.cpp
@@ -6,10 +6,10 @@
 // to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 // copies of the Software, and to permit persons to whom the Software is
 // furnished to do so, subject to the following conditions:
-// 
+//
 // The above copyright notice and this permission notice shall be included in all
 // copies or substantial portions of the Software.
-// 
+//
 // THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 // IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 // FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
@@ -328,7 +328,7 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
 
     mfxStatus mfxSts = MFX_ERR_NONE;
     VAStatus  vaSts;
-    VAPictureFEI past_ref, future_ref;
+    VAPictureStats past_ref, future_ref;
     VASurfaceID *inputSurface = (VASurfaceID*) surface;
 
     std::vector<VABufferID> configBuffers(MAX_CONFIG_BUFFERS_COUNT + m_slice.size() * 2);
@@ -403,6 +403,7 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
     }
     statParams.stats_params.mv_predictor = mvPredid;
 
+#if MFX_VERSION >= 1023
     if ((statParams.mb_qp) && (feiQP != NULL) && (feiQP->MB != NULL))
     {
         vaSts = vaCreateBuffer(m_vaDisplay,
@@ -417,6 +418,22 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
         mdprintf(stderr, "Qp bufId=%d\n", qpid);
     }
     statParams.stats_params.qp = qpid;
+#else
+    if ((statParams.mb_qp) && (feiQP != NULL) && (feiQP->QP != NULL))
+    {
+        vaSts = vaCreateBuffer(m_vaDisplay,
+                                m_vaContextEncode,
+                                (VABufferType)VAEncQPBufferType,
+                                sizeof (VAEncQPBufferH264)*feiQP->NumQPAlloc,
+                                1, //limitation from driver, num elements should be 1
+                                feiQP->QP,
+                                &qpid);
+        MFX_CHECK_WITH_ASSERT(VA_STATUS_SUCCESS == vaSts, MFX_ERR_DEVICE_FAILED);
+
+        mdprintf(stderr, "Qp bufId=%d\n", qpid);
+    }
+    statParams.stats_params.qp = qpid;
+#endif
 
     /* PreEnc support only 1 forward and 1 backward reference */
 
@@ -433,24 +450,24 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
         mfxSts = m_core->GetExternalFrameHDL(feiCtrl->RefFrame[0]->Data.MemId, &handle);
         MFX_CHECK_STS(mfxSts);
 
-        VAPictureFEI* l0surfs = &past_ref;
+        VAPictureStats* l0surfs = &past_ref;
         l0surfs->picture_id = *(VASurfaceID*)handle;
 
         switch (feiCtrl->RefPictureType[0])
         {
         case MFX_PICTYPE_TOPFIELD:
-            l0surfs->flags = VA_PICTURE_FEI_TOP_FIELD;
+            l0surfs->flags = VA_PICTURE_STATS_TOP_FIELD;
             break;
         case MFX_PICTYPE_BOTTOMFIELD:
-            l0surfs->flags = VA_PICTURE_FEI_BOTTOM_FIELD;
+            l0surfs->flags = VA_PICTURE_STATS_BOTTOM_FIELD;
             break;
         case MFX_PICTYPE_FRAME:
-            l0surfs->flags = VA_PICTURE_FEI_PROGRESSIVE;
+            l0surfs->flags = VA_PICTURE_STATS_PROGRESSIVE;
             break;
         }
 
         if (IsOn(feiCtrl->DownsampleReference[0]))
-            l0surfs->flags |= VA_PICTURE_FEI_CONTENT_UPDATED;
+            l0surfs->flags |= VA_PICTURE_STATS_CONTENT_UPDATED;
 
         statParams.stats_params.past_references = l0surfs;
         // statParams.stats_params.past_ref_stat_buf = IsOn(feiCtrl->DownsampleReference[0]) ? &m_statOutId[surfPastIndexInList] : NULL;
@@ -468,24 +485,24 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
         mfxSts = m_core->GetExternalFrameHDL(feiCtrl->RefFrame[1]->Data.MemId, &handle);
         MFX_CHECK_STS(mfxSts);
 
-        VAPictureFEI* l1surfs = &future_ref;
+        VAPictureStats* l1surfs = &future_ref;
         l1surfs->picture_id = *(VASurfaceID*)handle;
 
         switch (feiCtrl->RefPictureType[1])
         {
         case MFX_PICTYPE_TOPFIELD:
-            l1surfs->flags = VA_PICTURE_FEI_TOP_FIELD;
+            l1surfs->flags = VA_PICTURE_STATS_TOP_FIELD;
             break;
         case MFX_PICTYPE_BOTTOMFIELD:
-            l1surfs->flags = VA_PICTURE_FEI_BOTTOM_FIELD;
+            l1surfs->flags = VA_PICTURE_STATS_BOTTOM_FIELD;
             break;
         case MFX_PICTYPE_FRAME:
-            l1surfs->flags = VA_PICTURE_FEI_PROGRESSIVE;
+            l1surfs->flags = VA_PICTURE_STATS_PROGRESSIVE;
             break;
         }
 
         if (IsOn(feiCtrl->DownsampleReference[1]))
-            l1surfs->flags |= VA_PICTURE_FEI_CONTENT_UPDATED;
+            l1surfs->flags |= VA_PICTURE_STATS_CONTENT_UPDATED;
 
         statParams.stats_params.future_references = l1surfs;
         // statParams.stats_params.future_ref_stat_buf = IsOn(feiCtrl->DownsampleReference[1]) ? &m_statOutId[surfFutureIndexInList] : NULL;
@@ -535,20 +552,20 @@ mfxStatus VAAPIFEIPREENCEncoder::Execute(
     switch (feiCtrl->PictureType)
     {
     case MFX_PICTYPE_TOPFIELD:
-        statParams.stats_params.input.flags = VA_PICTURE_FEI_TOP_FIELD;
+        statParams.stats_params.input.flags = VA_PICTURE_STATS_TOP_FIELD;
         break;
 
     case MFX_PICTYPE_BOTTOMFIELD:
-        statParams.stats_params.input.flags = VA_PICTURE_FEI_BOTTOM_FIELD;
+        statParams.stats_params.input.flags = VA_PICTURE_STATS_BOTTOM_FIELD;
         break;
 
     case MFX_PICTYPE_FRAME:
-        statParams.stats_params.input.flags = VA_PICTURE_FEI_PROGRESSIVE;
+        statParams.stats_params.input.flags = VA_PICTURE_STATS_PROGRESSIVE;
         break;
     }
 
     if (!IsOff(feiCtrl->DownsampleInput) && (0 == feiFieldId))
-        statParams.stats_params.input.flags |= VA_PICTURE_FEI_CONTENT_UPDATED;
+        statParams.stats_params.input.flags |= VA_PICTURE_STATS_CONTENT_UPDATED;
 
     /* Link output VA buffers */
     statParams.stats_params.outputs = &outBuffers[0]; //bufIDs for outputs
@@ -1164,6 +1181,7 @@ mfxStatus VAAPIFEIENCEncoder::Execute(
     if (frameCtrl != NULL && frameCtrl->PerMBQp && mbqp != NULL)
     {
         MFX_AUTO_LTRACE(MFX_TRACE_LEVEL_EXTCALL, "vaCreateBuffer (MBqp)");
+#if MFX_VERSION >= 1023
         vaSts = vaCreateBuffer(m_vaDisplay,
                                 m_vaContextEncode,
                                 (VABufferType)VAEncQPBufferType,
@@ -1171,6 +1189,15 @@ mfxStatus VAAPIFEIENCEncoder::Execute(
                                 1, //limitation from driver, num elements should be 1
                                 mbqp->MB,
                                 &vaFeiMBQPId);
+#else
+        vaSts = vaCreateBuffer(m_vaDisplay,
+                                m_vaContextEncode,
+                                (VABufferType)VAEncQPBufferType,
+                                sizeof (VAEncQPBufferH264)*mbqp->NumQPAlloc,
+                                1, //limitation from driver, num elements should be 1
+                                mbqp->QP,
+                                &vaFeiMBQPId);
+#endif
         MFX_CHECK_WITH_ASSERT(VA_STATUS_SUCCESS == vaSts, MFX_ERR_DEVICE_FAILED);
         configBuffers[buffersCount++] = vaFeiMBQPId;
         mdprintf(stderr, "vaFeiMBQPId=%d\n", vaFeiMBQPId);
@@ -1990,7 +2017,11 @@ mfxStatus VAAPIFEIPAKEncoder::Execute(
     mfxU32 idxToPickBuffer = task.m_singleFieldMode ? 0 : feiFieldId;
 
     // Extension buffers
+#if MFX_VERSION >= 1023
     mfxExtFeiSliceHeader  * pDataSliceHeader = GetExtBufferFEI(in, idxToPickBuffer);
+#else
+    mfxExtFeiSliceHeader  * pDataSliceHeader = GetExtBufferFEI(out, idxToPickBuffer);
+#endif // MFX_VERSION >= 1023
     mfxExtFeiEncMV        * mvout            = GetExtBufferFEI(in, idxToPickBuffer);
     mfxExtFeiPakMBCtrl    * mbcodeout        = GetExtBufferFEI(in, idxToPickBuffer);
 
@@ -2207,8 +2238,10 @@ mfxStatus VAAPIFEIPAKEncoder::Execute(
         int height32 = ((m_videoParam.mfx.FrameInfo.Height + 31) >> 5) << 5;
         int codedbuf_size = static_cast<int>((width32 * height32) * 400LL / (16 * 16));
 
-        // to workaround an issue with VA coded bufer overflow due to IPCM violation
+        // To workaround an issue with VA coded bufer overflow due to IPCM violation.
+        // TODO: consider removing it once IPCM issue is fixed.
         codedbuf_size = 2 * codedbuf_size;
+
         vaSts = vaCreateBuffer(m_vaDisplay,
                                 m_vaContextEncode,
                                 VAEncCodedBufferType,
@@ -2271,7 +2304,7 @@ mfxStatus VAAPIFEIPAKEncoder::Execute(
      //SEI
     if (sei.Size() > 0)
     {
-        packed_header_param_buffer.type                = VAEncPackedHeaderH264_SEI;
+        packed_header_param_buffer.type                = VAEncPackedHeaderRawData;
         packed_header_param_buffer.has_emulation_bytes = 1;
         packed_header_param_buffer.bit_length          = sei.Size() * 8;
 
diff --git b/_studio/shared/include/vaapi_ext_interface.h a/_studio/shared/include/vaapi_ext_interface.h
index 89c119a..a89f4b3 100644
--- b/_studio/shared/include/vaapi_ext_interface.h
+++ a/_studio/shared/include/vaapi_ext_interface.h
@@ -29,63 +29,4 @@
 
 
 
-
-/*======================= FEI ==================================*/
-
-#define VA_ENC_FUNCTION_DEFAULT_INTEL 0x00000000
-#define VA_ENC_FUNCTION_ENC_INTEL     0x00000001
-#define VA_ENC_FUNCTION_PAK_INTEL     0x00000002
-#define VA_ENC_FUNCTION_ENC_PAK_INTEL 0x00000004
-
-#define VAEntrypointEncFEIIntel     1001
-#define VAEntrypointStatisticsIntel 1002
-
-#define VAEncMiscParameterTypeFEIFrameControlIntel 1001
-
-#define VAEncFEIMVBufferTypeIntel                   1001
-#define VAEncFEIModeBufferTypeIntel                 1002
-#define VAEncFEIDistortionBufferTypeIntel           1003
-#define VAEncFEIMBControlBufferTypeIntel            1004
-#define VAEncFEIMVPredictorBufferTypeIntel          1005
-#define VAStatsStatisticsParameterBufferTypeIntel   1006
-#define VAStatsStatisticsBufferTypeIntel            1007
-#define VAStatsMotionVectorBufferTypeIntel          1008
-#define VAStatsMVPredictorBufferTypeIntel           1009
-
-typedef struct _VAMotionVectorIntel {
-    short  mv0[2];
-    short  mv1[2];
-} VAMotionVectorIntel;
-
-
-typedef VAGenericID VAMFEContextID;
-
-#define VPG_EXT_VA_CREATE_MFECONTEXT  "DdiMedia_CreateMfeContext"
-typedef VAStatus (*vaExtCreateMfeContext)(
-    VADisplay           dpy,
-    VAMFEContextID      *mfe_context
-);
-
-#define VPG_EXT_VA_ADD_CONTEXT  "DdiMedia_AddContext"
-typedef VAStatus (*vaExtAddContext)(
-    VADisplay           dpy,
-    VAContextID         context,
-    VAMFEContextID      mfe_context
-);
-
-#define VPG_EXT_VA_RELEASE_CONTEXT  "DdiMedia_ReleaseContext"
-typedef VAStatus (*vaExtReleaseContext)(
-    VADisplay           dpy,
-    VAContextID         context,
-    VAMFEContextID      mfe_context
-);
-
-#define VPG_EXT_VA_MFE_SUBMIT  "DdiMedia_MfeSubmit"
-typedef VAStatus (*vaExtMfeSubmit)(
-    VADisplay           dpy,
-    VAMFEContextID      mfe_context,
-    VAContextID         *contexts,
-    int                 num_contexts
-);
-
 #endif // __VAAPI_EXT_INTERFACE_H__
diff --git b/_studio/shared/src/mfx_vpp_vaapi.cpp a/_studio/shared/src/mfx_vpp_vaapi.cpp
index 2beecbf..d713cc9 100755
--- b/_studio/shared/src/mfx_vpp_vaapi.cpp
+++ a/_studio/shared/src/mfx_vpp_vaapi.cpp
@@ -429,7 +429,7 @@ mfxStatus VAAPIVideoProcessing::QueryCapabilities(mfxVppCaps& caps)
 #endif
 
     /* NB! The code below should to be replaced with querying caps from driver*/
-#if defined(LINUX_TARGET_PLATFORM_BXT)
+#if defined(LINUX_TARGET_PLATFORM_BXTMIN) || defined(LINUX_TARGET_PLATFORM_BXT)
     caps.uMaxWidth  = 8192;
     caps.uMaxHeight = 8192;
 #else
@@ -460,6 +460,9 @@ mfxStatus VAAPIVideoProcessing::QueryCapabilities(mfxVppCaps& caps)
             caps.mFormatSupport[g_TABLE_SUPPORTED_FOURCC[indx]] |= MFX_FORMAT_SUPPORT_OUTPUT;
     }
 
+    caps.uMirroring = 1;
+    caps.uScaling = 1;
+
     return MFX_ERR_NONE;
 
 } // mfxStatus VAAPIVideoProcessing::QueryCapabilities(mfxVppCaps& caps)
@@ -486,6 +489,9 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
     bool bUseReference = false;
     VAStatus vaSts = VA_STATUS_SUCCESS;
 
+    VAAPIVideoCORE* hwCore = dynamic_cast<VAAPIVideoCORE*>(m_core);
+    eMFXHWType hwType = hwCore->GetHWType();
+
     // NOTE the following variables should be visible till vaRenderPicture/vaEndPicture,
     // not till vaCreateBuffer as the data they hold are passed to the driver via a pointer
     // to the memory and driver simply copies the pointer till further dereference in the
@@ -568,7 +574,7 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
                 else /* For BFF, second field is Top */
                     deint.flags = VA_DEINTERLACING_BOTTOM_FIELD_FIRST;
 
-                #if defined(LINUX_TARGET_PLATFORM_BXT)
+                #if defined(LINUX_TARGET_PLATFORM_BXT) || defined(LINUX_TARGET_PLATFORM_BXTMIN)
                 if (MFX_PICSTRUCT_FIELD_TFF & pCurSurf_frameInfo->frameInfo.PicStruct)
                     deint.flags = VA_DEINTERLACING_ONE_FIELD;
                 else /* For BFF case required to set all bits  */
@@ -1031,18 +1037,17 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
 #define ENABLE_VPP_VIDEO_SIGNAL(X)
 #endif
 
-
     mfxU32  refFourcc = pRefSurf->frameInfo.FourCC;
     switch (refFourcc)
     {
     case MFX_FOURCC_RGB4:
         m_pipelineParam[0].surface_color_standard = VAProcColorStandardNone;
-        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].input_surface_flag     = VA_SOURCE_RANGE_FULL);
+        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].input_color_properties.color_range = VA_SOURCE_RANGE_FULL);
         break;
     case MFX_FOURCC_NV12:
     default:
         m_pipelineParam[0].surface_color_standard = VAProcColorStandardBT601;
-        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].input_surface_flag     = VA_SOURCE_RANGE_REDUCED);
+        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].input_color_properties.color_range = VA_SOURCE_RANGE_REDUCED);
         break;
     }
 
@@ -1051,15 +1056,18 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
     {
     case MFX_FOURCC_RGB4:
         m_pipelineParam[0].output_color_standard = VAProcColorStandardNone;
-        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].output_surface_flag   = VA_SOURCE_RANGE_FULL);
+        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].output_color_properties.color_range = VA_SOURCE_RANGE_FULL);
         break;
     case MFX_FOURCC_NV12:
     default:
         m_pipelineParam[0].output_color_standard = VAProcColorStandardBT601;
-        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].output_surface_flag   = VA_SOURCE_RANGE_REDUCED);
+        ENABLE_VPP_VIDEO_SIGNAL(m_pipelineParam[0].output_color_properties.color_range = VA_SOURCE_RANGE_REDUCED);
         break;
     }
 
+    m_pipelineParam[0].input_color_properties.chroma_sample_location  = VA_CHROMA_SITING_UNKNOWN;
+    m_pipelineParam[0].output_color_properties.chroma_sample_location = VA_CHROMA_SITING_UNKNOWN;
+
     /* It needs interlaced flag passed only for
         * deinterlacing and scaling. All other filters must
         * use progressive even for interlaced content.
@@ -1113,7 +1121,7 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
 
         if(pParams->VideoSignalInfo[index].NominalRange != MFX_NOMINALRANGE_UNKNOWN)
         {
-            m_pipelineParam[0].input_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[index].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+            m_pipelineParam[0].input_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[index].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
         }
     }
 
@@ -1126,20 +1134,23 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
 
         if(pParams->VideoSignalInfoOut.NominalRange != MFX_NOMINALRANGE_UNKNOWN)
         {
-            m_pipelineParam[0].output_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+            m_pipelineParam[0].output_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
         }
 #else
         return MFX_ERR_UNSUPPORTED;
 #endif // #ifdef MFX_ENABLE_VPP_VIDEO_SIGNAL
     }
 
+    m_pipelineParam[0].input_color_properties.chroma_sample_location  = VA_CHROMA_SITING_UNKNOWN;
+    m_pipelineParam[0].output_color_properties.chroma_sample_location = VA_CHROMA_SITING_UNKNOWN;
+
     /* Scaling params */
     switch (pParams->scalingMode)
     {
     case MFX_SCALING_MODE_LOWPOWER:
         /* VA_FILTER_SCALING_DEFAULT means the following:
-            *  First priority is SFC. If SFC can't work, revert to AVS
-            *  If scaling ratio between 1/8...8 -> SFC
+            *  First priority is HW fixed function scaling engine. If it can't work, revert to AVS
+            *  If scaling ratio between 1/8...8 -> HW fixed function
             *  If scaling ratio between 1/16...1/8 or larger than 8 -> AVS
             *  If scaling ratio is less than 1/16 -> bilinear
             */
@@ -1154,13 +1165,16 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
         break;
     case MFX_SCALING_MODE_DEFAULT:
     default:
-#if defined(LINUX_TARGET_PLATFORM_BXT)
-        /* Use SFC by default on BXT platforms due to power consumption considerations */
-        m_pipelineParam[0].filter_flags |= VA_FILTER_SCALING_DEFAULT;
-#else
-        /* Force AVS by default for all platforms except BXT */
-        m_pipelineParam[0].filter_flags |= VA_FILTER_SCALING_HQ;
-#endif
+        if(MFX_HW_APL == hwType)
+        {
+            /* Use HW fixed function scaling engine by default on APL due to power consumption considerations */
+            m_pipelineParam[0].filter_flags |= VA_FILTER_SCALING_DEFAULT;
+        }
+        else
+        {
+            /* Force AVS by default for all platforms except BXT */
+            m_pipelineParam[0].filter_flags |= VA_FILTER_SCALING_HQ;
+        }
         break;
     }
 
@@ -1181,7 +1195,7 @@ mfxStatus VAAPIVideoProcessing::Execute(mfxExecuteParams *pParams)
     if((pParams->bEOS) && (pParams->bDeinterlace30i60p == true))
         m_deintFrameCount = 0;
 
-#if defined(LINUX_TARGET_PLATFORM_BXT)
+#if defined(LINUX_TARGET_PLATFORM_BXTMIN) || defined(LINUX_TARGET_PLATFORM_BXT)
 // It looks like only BXT supports this at the moment
 #define VPP_NO_COLORFILL
 #endif
@@ -1588,7 +1602,7 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition_TiledVideoWall(mfxExecutePar
 
         m_pipelineParam[i].pipeline_flags |= VA_PROC_PIPELINE_SUBPICTURES;
 
-#if defined(LINUX_TARGET_PLATFORM_BXT)
+#if defined(LINUX_TARGET_PLATFORM_BXT) || defined(LINUX_TARGET_PLATFORM_BXTMIN)
         m_pipelineParam[i].pipeline_flags |= VA_PROC_PIPELINE_SUBPICTURES;
         m_pipelineParam[i].filter_flags   |= VA_FILTER_SCALING_HQ;
 #else
@@ -1897,7 +1911,7 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition(mfxExecuteParams *pParams)
 
             if(pParams->VideoSignalInfo[refIdx-1].NominalRange != MFX_NOMINALRANGE_UNKNOWN)
             {
-                m_pipelineParam[refIdx].input_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[refIdx-1].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+                m_pipelineParam[refIdx].input_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[refIdx-1].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
             }
         }
 
@@ -1910,9 +1924,11 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition(mfxExecuteParams *pParams)
 
             if(pParams->VideoSignalInfoOut.NominalRange != MFX_NOMINALRANGE_UNKNOWN)
             {
-                m_pipelineParam[refIdx].output_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+                m_pipelineParam[refIdx].output_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
             }
         }
+    m_pipelineParam[refIdx].input_color_properties.chroma_sample_location  = VA_CHROMA_SITING_UNKNOWN;
+    m_pipelineParam[refIdx].output_color_properties.chroma_sample_location = VA_CHROMA_SITING_UNKNOWN;
 
         switch (pRefSurf->frameInfo.PicStruct)
         {
@@ -1930,7 +1946,7 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition(mfxExecuteParams *pParams)
         if (pParams->bComposite)
         {
             m_pipelineParam[refIdx].num_filters  = 0;
-#if defined(LINUX_TARGET_PLATFORM_BXT)
+#if defined(LINUX_TARGET_PLATFORM_BXT) || defined(LINUX_TARGET_PLATFORM_BXTMIN)
             m_pipelineParam[refIdx].pipeline_flags |= VA_PROC_PIPELINE_SUBPICTURES;
             m_pipelineParam[refIdx].filter_flags   |= VA_FILTER_SCALING_HQ;
 #else
@@ -2063,7 +2079,7 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition(mfxExecuteParams *pParams)
 
             if(pParams->VideoSignalInfo[refIdx-1].NominalRange != MFX_NOMINALRANGE_UNKNOWN)
             {
-                m_pipelineParam[refIdx].input_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[refIdx-1].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+                m_pipelineParam[refIdx].input_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfo[refIdx-1].NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
             }
         }
 
@@ -2076,9 +2092,11 @@ mfxStatus VAAPIVideoProcessing::Execute_Composition(mfxExecuteParams *pParams)
 
             if(pParams->VideoSignalInfoOut.NominalRange != MFX_NOMINALRANGE_UNKNOWN)
             {
-                m_pipelineParam[refIdx].output_surface_flag = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
+                m_pipelineParam[refIdx].output_color_properties.color_range = (MFX_NOMINALRANGE_0_255 == pParams->VideoSignalInfoOut.NominalRange) ? VA_SOURCE_RANGE_FULL : VA_SOURCE_RANGE_REDUCED;
             }
         }
+        m_pipelineParam[refIdx].input_color_properties.chroma_sample_location  = VA_CHROMA_SITING_UNKNOWN;
+        m_pipelineParam[refIdx].output_color_properties.chroma_sample_location = VA_CHROMA_SITING_UNKNOWN;
 
         /* to process input parameters of sub stream:
          * crop info and original size*/
@@ -2235,6 +2253,7 @@ mfxStatus VAAPIVideoProcessing::QueryTaskStatus(mfxU32 taskIndex)
         m_feedbackCache.erase(m_feedbackCache.begin() + indxSurf);
     }
 
+#if !defined(ANDROID)
     {
         MFX_AUTO_LTRACE(MFX_TRACE_LEVEL_EXTCALL, "vaSyncSurface");
         vaSts = vaSyncSurface(m_vaDisplay, waitSurface);
@@ -2243,6 +2262,7 @@ mfxStatus VAAPIVideoProcessing::QueryTaskStatus(mfxU32 taskIndex)
         else
             MFX_CHECK_WITH_ASSERT(VA_STATUS_SUCCESS == vaSts, MFX_ERR_DEVICE_FAILED);
     }
+#endif
 
     return MFX_TASK_DONE;
 } // mfxStatus VAAPIVideoProcessing::QueryTaskStatus(mfxU32 taskIndex)
diff --git b/samples/sample_multi_transcode/include/pipeline_transcode.h a/samples/sample_multi_transcode/include/pipeline_transcode.h
index 2991e96..811aaaf 100644
--- b/samples/sample_multi_transcode/include/pipeline_transcode.h
+++ a/samples/sample_multi_transcode/include/pipeline_transcode.h
@@ -1,5 +1,5 @@
 /******************************************************************************\
-Copyright (c) 2005-2018, Intel Corporation
+Copyright (c) 2005-2017, Intel Corporation
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -435,15 +435,6 @@ namespace TranscodingSample
             }
             return;
         }
-        void FlushAll()
-        {
-            for (mfxU32 i = 0; i < m_pExtBS.size(); i++)
-            {
-                m_pExtBS[i].Bitstream.DataLength = 0;
-                m_pExtBS[i].Bitstream.DataOffset = 0;
-            }
-            return;
-        }
     protected:
         std::vector<ExtendedBS> m_pExtBS;
 
diff --git b/samples/sample_multi_transcode/src/pipeline_transcode.cpp a/samples/sample_multi_transcode/src/pipeline_transcode.cpp
index bdae2af..b84b9e6 100644
--- b/samples/sample_multi_transcode/src/pipeline_transcode.cpp
+++ a/samples/sample_multi_transcode/src/pipeline_transcode.cpp
@@ -1,5 +1,5 @@
 /******************************************************************************\
-Copyright (c) 2005-2018, Intel Corporation
+Copyright (c) 2005-2017, Intel Corporation
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -2197,12 +2197,6 @@ mfxStatus CTranscodingPipeline::InitDecMfxParams(sInputParams *pInParams)
             m_mfxDecParams.mfx.FrameInfo.Height = MSDK_ALIGN16(m_mfxDecParams.mfx.FrameInfo.CropH);
             m_mfxDecParams.mfx.FrameInfo.PicStruct = m_pmfxBS->PicStruct;
         }
-        // OpenCL demands aligned to 32 surfaces
-        if (pInParams->bOpenCL)
-        {
-            m_mfxDecParams.mfx.FrameInfo.Width = MSDK_ALIGN32(m_mfxDecParams.mfx.FrameInfo.CropW);
-            m_mfxDecParams.mfx.FrameInfo.Height = MSDK_ALIGN32(m_mfxDecParams.mfx.FrameInfo.CropH);
-        }
     }
     else
     {
@@ -2546,13 +2540,6 @@ MFX_IOPATTERN_IN_VIDEO_MEMORY : MFX_IOPATTERN_IN_SYSTEM_MEMORY);
         m_mfxEncParams.mfx.InitialDelayInKB = pInParams->InitialDelayInKB;
     }
 
-    // OpenCL demands aligned to 32 surfaces
-    if (pInParams->bOpenCL)
-    {
-        m_mfxEncParams.mfx.FrameInfo.Width = MSDK_ALIGN32(m_mfxEncParams.mfx.FrameInfo.CropW);
-        m_mfxEncParams.mfx.FrameInfo.Height = MSDK_ALIGN32(m_mfxEncParams.mfx.FrameInfo.CropH);
-    }
-
     return MFX_ERR_NONE;
 }// mfxStatus CTranscodingPipeline::InitEncMfxParams(sInputParams *pInParams)
 
@@ -2873,15 +2860,6 @@ mfxStatus CTranscodingPipeline::AddLaStreams(mfxU16 width, mfxU16 height)
         m_VppExtParamsStorage.ExtBuffers.push_back((mfxExtBuffer *)&m_VppCompParams);
     } // if ( ((pInParams->eModeExt == VppComp) || (pInParams->eModeExt == VppCompOnly)) &&
 
-    // OpenCL demands align to 32 bit surfaces
-    if (pInParams->bOpenCL)
-    {
-        m_mfxVppParams.vpp.Out.CropW = m_mfxVppParams.vpp.Out.Width;
-        m_mfxVppParams.vpp.Out.CropH = m_mfxVppParams.vpp.Out.Height;
-        m_mfxVppParams.vpp.Out.Width = MSDK_ALIGN32(m_mfxVppParams.vpp.Out.CropW);
-        m_mfxVppParams.vpp.Out.Height = MSDK_ALIGN32(m_mfxVppParams.vpp.Out.CropH);
-    }
-
     if (m_bUseOpaqueMemory)
         m_VppExtParamsStorage.ExtBuffers.push_back((mfxExtBuffer *)&m_VppOpaqueAlloc);
     if (pInParams->bIsMVC)
@@ -4033,7 +4011,6 @@ mfxStatus CTranscodingPipeline::Reset()
     // Release output bitstram pools
     m_BSPool.clear();
     m_pBSStore->ReleaseAll();
-    m_pBSStore->FlushAll();
 
     // Load external decoder plugin
     if (isDecoderPlugin)
@@ -4192,7 +4169,6 @@ mfxStatus CTranscodingPipeline::AllocateSufficientBuffer(mfxBitstream* pBS)
     MSDK_CHECK_STATUS(sts, "m_pmfxENC->GetVideoParam failed");
 
     mfxU32 new_size = 0;
-
     // if encoder provided us information about buffer size
     if (0 != par.mfx.BufferSizeInKB)
     {
diff --git b/samples/sample_multi_transcode/src/sample_multi_transcode.cpp a/samples/sample_multi_transcode/src/sample_multi_transcode.cpp
index f845f3a..8fb76e1 100644
--- b/samples/sample_multi_transcode/src/sample_multi_transcode.cpp
+++ a/samples/sample_multi_transcode/src/sample_multi_transcode.cpp
@@ -1,5 +1,5 @@
 /******************************************************************************\
-Copyright (c) 2005-2018, Intel Corporation
+Copyright (c) 2005-2017, Intel Corporation
 All rights reserved.
 
 Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met:
@@ -431,7 +431,6 @@ void Launcher::DoTranscoding()
             }
         }
     }
-    m_HDLArray.clear();
 }
 
 void Launcher::DoRobustTranscoding()
