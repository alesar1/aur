--- 15.9/common/lib/modules/fglrx/build_mod/firegl_public.c	2015-09-27 10:59:10.121499353 +0200
+++ 15.9b/common/lib/modules/fglrx/build_mod/firegl_public.c	2015-09-27 10:59:31.869133789 +0200
@@ -6446,6 +6446,48 @@
     return i;
 }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,2,0)
+/*
+ * Save processor xstate to xsave area.
+ */
+static void _copy_xregs_to_kernel(struct xregs_state *xstate)
+{
+        u64 mask = -1;
+        u32 lmask = mask;
+        u32 hmask = mask >> 32;
+        int err = 0;
+
+        /*WARN_ON(!alternatives_patched);*/
+
+        /*
+         * If xsaves is enabled, xsaves replaces xsaveopt because
+         * it supports compact format and supervisor states in addition to
+         * modified optimization in xsaveopt.
+         *
+         * Otherwise, if xsaveopt is enabled, xsaveopt replaces xsave
+         * because xsaveopt supports modified optimization which is not
+         * supported by xsave.
+         *
+         * If none of xsaves and xsaveopt is enabled, use xsave.
+         */
+        alternative_input_2(
+                "1:"XSAVE,
+                XSAVEOPT,
+                X86_FEATURE_XSAVEOPT,
+                XSAVES,
+                X86_FEATURE_XSAVES,
+                [xstate] "D" (xstate), "a" (lmask), "d" (hmask) :
+                "memory");
+        asm volatile("2:\n\t"
+                     xstate_fault(err)
+                     : "0" (err)
+                     : "memory");
+
+        /* We should never fault when copying to a kernel buffer: */
+        WARN_ON_FPU(err);
+}
+#endif
+
 /** \brief Generate UUID
  *  \param buf pointer to the generated UUID
  *  \return None
@@ -6465,7 +6507,7 @@
       fpu_xsave(fpu);
       if (!(fpu->state->xsave.xsave_hdr.xstate_bv & XSTATE_FP))
 #else
-      copy_xregs_to_kernel(&fpu->state.xsave);
+      _copy_xregs_to_kernel(&fpu->state.xsave);
       if (!(fpu->state.xsave.header.xfeatures & XSTATE_FP))
 #endif
 	 return 1;
