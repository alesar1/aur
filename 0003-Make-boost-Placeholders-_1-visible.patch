From 1980b5602202a91cbff12e2aaa756e54301f43f1 Mon Sep 17 00:00:00 2001
From: Jonathan Wakely <jwakely@redhat.com>
Date: Wed, 3 Jun 2020 01:05:39 +0200
Subject: [PATCH 3/3] Make boost::Placeholders::_1 visible

Fixes https://github.com/slic3r/Slic3r/issues/4967
---
 xs/src/libslic3r/GCodeSender.hpp        |   5 +-
 xs/src/libslic3r/GCodeTimeEstimator.cpp |   5 +-
 xs/src/libslic3r/PrintObject.cpp        | 161 ++++++++++++------------
 xs/src/libslic3r/SLAPrint.cpp           |   3 +
 xs/src/libslic3r/TriangleMesh.cpp       |   3 +
 5 files changed, 96 insertions(+), 81 deletions(-)

diff --git a/xs/src/libslic3r/GCodeSender.hpp b/xs/src/libslic3r/GCodeSender.hpp
index cc0b29832..237bc1cc4 100644
--- a/xs/src/libslic3r/GCodeSender.hpp
+++ b/xs/src/libslic3r/GCodeSender.hpp
@@ -7,13 +7,16 @@
 #include <string>
 #include <vector>
 #include <boost/asio.hpp>
-#include <boost/bind.hpp>
+#include <boost/bind/bind.hpp>
 #include <boost/thread.hpp>
 
 namespace Slic3r {
 
 namespace asio = boost::asio;
 
+using boost::placeholders::_1;
+using boost::placeholders::_2;
+
 class GCodeSender : private boost::noncopyable {
     public:
     GCodeSender();
diff --git a/xs/src/libslic3r/GCodeTimeEstimator.cpp b/xs/src/libslic3r/GCodeTimeEstimator.cpp
index 818896bc1..b705032c8 100644
--- a/xs/src/libslic3r/GCodeTimeEstimator.cpp
+++ b/xs/src/libslic3r/GCodeTimeEstimator.cpp
@@ -1,9 +1,12 @@
 #include "GCodeTimeEstimator.hpp"
-#include <boost/bind.hpp>
+#include <boost/bind/bind.hpp>
 #include <cmath>
 
 namespace Slic3r {
 
+using boost::placeholders::_1;
+using boost::placeholders::_2;
+
 void
 GCodeTimeEstimator::parse(const std::string &gcode)
 {
diff --git a/xs/src/libslic3r/PrintObject.cpp b/xs/src/libslic3r/PrintObject.cpp
index 6d60f3c6f..080d975ff 100644
--- a/xs/src/libslic3r/PrintObject.cpp
+++ b/xs/src/libslic3r/PrintObject.cpp
@@ -2,11 +2,14 @@
 #include "BoundingBox.hpp"
 #include "ClipperUtils.hpp"
 #include "Geometry.hpp"
+#include <boost/bind/bind.hpp>
 #include <algorithm>
 #include <vector>
 
 namespace Slic3r {
 
+using boost::placeholders::_1;
+
 PrintObject::PrintObject(Print* print, ModelObject* model_object, const BoundingBoxf3 &modobj_bbox)
 :   layer_height_spline(model_object->layer_height_spline),
     typed_slices(false),
@@ -28,7 +31,7 @@ PrintObject::PrintObject(Print* print, ModelObject* model_object, const Bounding
         Pointf3 size = modobj_bbox.size();
         this->size = Point3(scale_(size.x), scale_(size.y), scale_(size.z));
     }
-    
+
     this->reload_model_instances();
     this->layer_height_ranges = model_object->layer_height_ranges;
 }
@@ -76,21 +79,21 @@ bool
 PrintObject::set_copies(const Points &points)
 {
     this->_copies = points;
-    
+
     // order copies with a nearest neighbor search and translate them by _copies_shift
     this->_shifted_copies.clear();
     this->_shifted_copies.reserve(points.size());
-    
+
     // order copies with a nearest-neighbor search
     std::vector<Points::size_type> ordered_copies;
     Slic3r::Geometry::chained_path(points, ordered_copies);
-    
+
     for (std::vector<Points::size_type>::const_iterator it = ordered_copies.begin(); it != ordered_copies.end(); ++it) {
         Point copy = points[*it];
         copy.translate(this->_copies_shift);
         this->_shifted_copies.push_back(copy);
     }
-    
+
     bool invalidated = false;
     if (this->_print->invalidate_step(psSkirt)) invalidated = true;
     if (this->_print->invalidate_step(psBrim)) invalidated = true;
@@ -216,10 +219,10 @@ bool
 PrintObject::invalidate_state_by_config(const PrintConfigBase &config)
 {
     const t_config_option_keys diff = this->config.diff(config);
-    
+
     std::set<PrintObjectStep> steps;
     bool all = false;
-    
+
     // this method only accepts PrintObjectConfig and PrintRegionConfig option keys
     for (const t_config_option_key &opt_key : diff) {
         if (opt_key == "layer_height"
@@ -265,10 +268,10 @@ PrintObject::invalidate_state_by_config(const PrintConfigBase &config)
             break;
         }
     }
-    
+
     if (!diff.empty())
         this->config.apply(config, true);
-    
+
     bool invalidated = false;
     if (all) {
         invalidated = this->invalidate_all_steps();
@@ -277,7 +280,7 @@ PrintObject::invalidate_state_by_config(const PrintConfigBase &config)
             if (this->invalidate_step(step))
                 invalidated = true;
     }
-    
+
     return invalidated;
 }
 
@@ -285,7 +288,7 @@ bool
 PrintObject::invalidate_step(PrintObjectStep step)
 {
     bool invalidated = this->state.invalidate(step);
-    
+
     // propagate to dependent steps
     if (step == posPerimeters) {
         invalidated |= this->invalidate_step(posPrepareInfill);
@@ -308,7 +311,7 @@ PrintObject::invalidate_step(PrintObjectStep step)
         invalidated |= this->_print->invalidate_step(psSkirt);
         invalidated |= this->_print->invalidate_step(psBrim);
     }
-    
+
     return invalidated;
 }
 
@@ -317,7 +320,7 @@ PrintObject::invalidate_all_steps()
 {
     // make a copy because when invalidating steps the iterators are not working anymore
     std::set<PrintObjectStep> steps = this->state.started;
-    
+
     bool invalidated = false;
     for (std::set<PrintObjectStep>::const_iterator step = steps.begin(); step != steps.end(); ++step) {
         if (this->invalidate_step(*step)) invalidated = true;
@@ -338,16 +341,16 @@ PrintObject::detect_surfaces_type()
 {
     // prerequisites
     // this->slice();
-    
+
     if (this->state.is_done(posDetectSurfaces)) return;
     this->state.set_started(posDetectSurfaces);
-    
+
     parallelize<Layer*>(
         std::queue<Layer*>(std::deque<Layer*>(this->layers.begin(), this->layers.end())),  // cast LayerPtrs to std::queue<Layer*>
         boost::bind(&Slic3r::Layer::detect_surfaces_type, _1),
         this->_print->config.threads.value
     );
-    
+
     this->typed_slices = true;
     this->state.set_done(posDetectSurfaces);
 }
@@ -369,10 +372,10 @@ PrintObject::bridge_over_infill()
 {
     FOREACH_REGION(this->_print, region) {
         const size_t region_id = region - this->_print->regions.begin();
-        
+
         // skip bridging in case there are no voids
         if ((*region)->config.fill_density.value == 100) continue;
-        
+
         // get bridge flow
         const Flow bridge_flow = (*region)->flow(
             frSolidInfill,
@@ -382,28 +385,28 @@ PrintObject::bridge_over_infill()
             -1,     // custom width, not relevant for bridge flow
             *this
         );
-        
+
         // get the average extrusion volume per surface unit
         const double mm3_per_mm  = bridge_flow.mm3_per_mm();
         const double mm3_per_mm2 = mm3_per_mm / bridge_flow.width;
-        
+
         FOREACH_LAYER(this, layer_it) {
             // skip first layer
             if (layer_it == this->layers.begin()) continue;
-            
+
             Layer* layer        = *layer_it;
             LayerRegion* layerm = layer->get_region(region_id);
-            
+
             // extract the stInternalSolid surfaces that might be transformed into bridges
             Polygons internal_solid;
             layerm->fill_surfaces.filter_by_type(stInternalSolid, &internal_solid);
             if (internal_solid.empty()) continue;
-            
+
             // check whether we should bridge or not according to density
             {
                 // get the normal solid infill flow we would use if not bridging
                 const Flow normal_flow = layerm->flow(frSolidInfill, false);
-                
+
                 // Bridging over sparse infill has two purposes:
                 // 1) cover better the gaps of internal sparse infill, especially when
                 //    printing at very low densities;
@@ -429,66 +432,66 @@ PrintObject::bridge_over_infill()
                     ),
                     min_threshold
                 );
-                
+
                 if ((*region)->config.fill_density.value > density_threshold) continue;
             }
-            
+
             // check whether the lower area is deep enough for absorbing the extra flow
             // (for obvious physical reasons but also for preventing the bridge extrudates
             // from overflowing in 3D preview)
             ExPolygons to_bridge;
             {
                 Polygons to_bridge_pp = internal_solid;
-                
+
                 // Only bridge where internal infill exists below the solid shell matching
                 // these two conditions:
                 // 1) its depth is at least equal to our bridge extrusion diameter;
                 // 2) its free volume (thus considering infill density) is at least equal
                 //    to the volume needed by our bridge flow.
                 double excess_mm3_per_mm2 = mm3_per_mm2;
-                
+
                 // iterate through lower layers spanned by bridge_flow
                 const double bottom_z = layer->print_z - bridge_flow.height;
                 for (int i = (layer_it - this->layers.begin()) - 1; i >= 0; --i) {
                     const Layer* lower_layer = this->layers[i];
-                    
+
                     // subtract the void volume of this layer
                     excess_mm3_per_mm2 -= lower_layer->height * (100 - (*region)->config.fill_density.value)/100;
-                    
+
                     // stop iterating if both conditions are matched
                     if (lower_layer->print_z < bottom_z && excess_mm3_per_mm2 <= 0) break;
-                    
+
                     // iterate through regions and collect internal surfaces
                     Polygons lower_internal;
                     FOREACH_LAYERREGION(lower_layer, lower_layerm_it)
                         (*lower_layerm_it)->fill_surfaces.filter_by_type(stInternal, &lower_internal);
-                    
+
                     // intersect such lower internal surfaces with the candidate solid surfaces
                     to_bridge_pp = intersection(to_bridge_pp, lower_internal);
                 }
-                
+
                 // don't bridge if the volume condition isn't matched
                 if (excess_mm3_per_mm2 > 0) continue;
-                
+
                 // there's no point in bridging too thin/short regions
                 {
                     const double min_width = bridge_flow.scaled_width() * 3;
                     to_bridge_pp = offset2(to_bridge_pp, -min_width, +min_width);
                 }
-                
+
                 if (to_bridge_pp.empty()) continue;
-                
+
                 // convert into ExPolygons
                 to_bridge = union_ex(to_bridge_pp);
             }
-            
+
             #ifdef SLIC3R_DEBUG
             printf("Bridging %zu internal areas at layer %zu\n", to_bridge.size(), layer->id());
             #endif
-            
+
             // compute the remaning internal solid surfaces as difference
             const ExPolygons not_to_bridge = diff_ex(internal_solid, to_polygons(to_bridge), true);
-            
+
             // build the new collection of fill_surfaces
             {
                 Surfaces new_surfaces;
@@ -496,16 +499,16 @@ PrintObject::bridge_over_infill()
                     if (surface->surface_type != stInternalSolid)
                         new_surfaces.push_back(*surface);
                 }
-                
+
                 for (ExPolygons::const_iterator ex = to_bridge.begin(); ex != to_bridge.end(); ++ex)
                     new_surfaces.push_back(Surface(stInternalBridge, *ex));
-                
+
                 for (ExPolygons::const_iterator ex = not_to_bridge.begin(); ex != not_to_bridge.end(); ++ex)
                     new_surfaces.push_back(Surface(stInternalSolid, *ex));
-                
+
                 layerm->fill_surfaces.surfaces = new_surfaces;
             }
-            
+
             /*
             # exclude infill from the layers below if needed
             # see discussion at https://github.com/alexrj/Slic3r/issues/240
@@ -534,7 +537,7 @@ PrintObject::bridge_over_infill()
                         $lower_layerm->fill_surfaces->clear;
                         $lower_layerm->fill_surfaces->append($_) for @new_surfaces;
                     }
-                    
+
                     $excess -= $self->get_layer($i)->height;
                 }
             }
@@ -843,7 +846,7 @@ void PrintObject::_slice()
         }
         this->delete_layer(int(this->layers.size()) - 1);
     }
-    
+
     // Apply size compensation and perform clipping of multi-part objects.
     const coord_t xy_size_compensation = scale_(this->config.xy_size_compensation.value);
     for (Layer* layer : this->layers) {
@@ -862,26 +865,26 @@ void PrintObject::_slice()
                 for (size_t region_id = 0; region_id < layer->regions.size(); ++region_id) {
                     LayerRegion* layerm = layer->regions[region_id];
                     Polygons slices = layerm->slices;
-                    
+
                     if (abs(xy_size_compensation) > 0)
                         slices = offset(slices, xy_size_compensation);
-                    
+
                     if (region_id > 0)
                         // Trim by the slices of already processed regions.
                         slices = diff(std::move(slices), processed);
-                    
+
                     if (region_id + 1 < layer->regions.size())
                         // Collect the already processed regions to trim the to be processed regions.
                         append_to(processed, slices);
-                    
+
                     layerm->slices.set(union_ex(slices), stInternal);
                 }
             }
         }
-        
+
         // Merge all regions' slices to get islands, chain them by a shortest path.
         layer->make_slices();
-        
+
         // Apply regions overlap
         if (this->config.regions_overlap.value > 0) {
             const coord_t delta = scale_(this->config.regions_overlap.value)/2;
@@ -904,23 +907,23 @@ PrintObject::_slice_region(size_t region_id, std::vector<float> z, bool modifier
     std::vector<ExPolygons> layers;
     std::vector<int> &region_volumes = this->region_volumes[region_id];
     if (region_volumes.empty()) return layers;
-    
+
     ModelObject &object = *this->model_object();
-    
+
     // compose mesh
     TriangleMesh mesh;
     for (std::vector<int>::const_iterator it = region_volumes.begin();
         it != region_volumes.end(); ++it) {
-        
+
         const ModelVolume &volume = *object.volumes[*it];
         if (volume.modifier != modifier) continue;
-        
+
         mesh.merge(volume.mesh);
     }
     if (mesh.facets_count() == 0) return layers;
 
     // transform mesh
-    // we ignore the per-instance transformations currently and only 
+    // we ignore the per-instance transformations currently and only
     // consider the first one
     object.instances[0]->transform_mesh(&mesh, true);
 
@@ -930,7 +933,7 @@ PrintObject::_slice_region(size_t region_id, std::vector<float> z, bool modifier
         -unscale(this->_copies_shift.y),
         -object.bounding_box().min.z
     );
-    
+
     // perform actual slicing
     TriangleMeshSlicer<Z>(&mesh).slice(z, &layers);
     return layers;
@@ -941,10 +944,10 @@ PrintObject::_make_perimeters()
 {
     if (this->state.is_done(posPerimeters)) return;
     this->state.set_started(posPerimeters);
-    
+
     // merge slices if they were split into types
     // This is not currently taking place because since merge_slices + detect_surfaces_type
-    // are not truly idempotent we are invalidating posSlice here (see the Perl part of 
+    // are not truly idempotent we are invalidating posSlice here (see the Perl part of
     // this method).
     if (this->typed_slices) {
         // merge_slices() undoes detect_surfaces_type()
@@ -953,10 +956,10 @@ PrintObject::_make_perimeters()
         this->typed_slices = false;
         this->state.invalidate(posDetectSurfaces);
     }
-    
+
     // compare each layer to the one below, and mark those slices needing
     // one additional inner perimeter, like the top of domed objects-
-    
+
     // this algorithm makes sure that at least one perimeter is overlapping
     // but we don't generate any extra perimeter if fill density is zero, as they would be floating
     // inside the object - infill_only_where_needed should be the method of choice for printing
@@ -964,41 +967,41 @@ PrintObject::_make_perimeters()
     FOREACH_REGION(this->_print, region_it) {
         size_t region_id = region_it - this->_print->regions.begin();
         const PrintRegion &region = **region_it;
-        
+
         if (!region.config.extra_perimeters
             || region.config.perimeters == 0
             || region.config.fill_density == 0
             || this->layer_count() < 2) continue;
-        
+
         for (size_t i = 0; i <= (this->layer_count()-2); ++i) {
             LayerRegion &layerm                     = *this->get_layer(i)->get_region(region_id);
             const LayerRegion &upper_layerm         = *this->get_layer(i+1)->get_region(region_id);
-            
+
             // In order to avoid diagonal gaps (GH #3732) we ignore the external half of the upper
             // perimeter, since it's not truly covering this layer.
             const Polygons upper_layerm_polygons = offset(
                 upper_layerm.slices,
                 -upper_layerm.flow(frExternalPerimeter).scaled_width()/2
             );
-            
+
             // Filter upper layer polygons in intersection_ppl by their bounding boxes?
             // my $upper_layerm_poly_bboxes= [ map $_->bounding_box, @{$upper_layerm_polygons} ];
             double total_loop_length = 0;
             for (Polygons::const_iterator it = upper_layerm_polygons.begin(); it != upper_layerm_polygons.end(); ++it)
                 total_loop_length += it->length();
-            
+
             const coord_t perimeter_spacing     = layerm.flow(frPerimeter).scaled_spacing();
             const Flow ext_perimeter_flow       = layerm.flow(frExternalPerimeter);
             const coord_t ext_perimeter_width   = ext_perimeter_flow.scaled_width();
             const coord_t ext_perimeter_spacing = ext_perimeter_flow.scaled_spacing();
-            
+
             for (Surfaces::iterator slice = layerm.slices.surfaces.begin();
                 slice != layerm.slices.surfaces.end(); ++slice) {
                 while (true) {
                     // compute the total thickness of perimeters
                     const coord_t perimeters_thickness = ext_perimeter_width/2 + ext_perimeter_spacing/2
                         + (region.config.perimeters-1 + slice->extra_perimeters) * perimeter_spacing;
-                    
+
                     // define a critical area where we don't want the upper slice to fall into
                     // (it should either lay over our perimeters or outside this area)
                     const coord_t critical_area_depth = perimeter_spacing * 1.5;
@@ -1006,13 +1009,13 @@ PrintObject::_make_perimeters()
                         offset(slice->expolygon, -perimeters_thickness),
                         offset(slice->expolygon, -(perimeters_thickness + critical_area_depth))
                     );
-                    
+
                     // check whether a portion of the upper slices falls inside the critical area
                     const Polylines intersection = intersection_pl(
                         upper_layerm_polygons,
                         critical_area
                     );
-                    
+
                     // only add an additional loop if at least 30% of the slice loop would benefit from it
                     {
                         double total_intersection_length = 0;
@@ -1020,7 +1023,7 @@ PrintObject::_make_perimeters()
                             total_intersection_length += it->length();
                         if (total_intersection_length <= total_loop_length*0.3) break;
                     }
-                    
+
                     /*
                     if (0) {
                         require "Slic3r/SVG.pm";
@@ -1032,10 +1035,10 @@ PrintObject::_make_perimeters()
                         );
                     }
                     */
-                    
+
                     slice->extra_perimeters++;
                 }
-                
+
                 #ifdef DEBUG
                     if (slice->extra_perimeters > 0)
                         printf("  adding %d more perimeter(s) at layer %zu\n", slice->extra_perimeters, i);
@@ -1043,20 +1046,20 @@ PrintObject::_make_perimeters()
             }
         }
     }
-    
+
     parallelize<Layer*>(
         std::queue<Layer*>(std::deque<Layer*>(this->layers.begin(), this->layers.end())),  // cast LayerPtrs to std::queue<Layer*>
         boost::bind(&Slic3r::Layer::make_perimeters, _1),
         this->_print->config.threads.value
     );
-    
+
     /*
         simplify slices (both layer and region slices),
         we only need the max resolution for perimeters
     ### This makes this method not-idempotent, so we keep it disabled for now.
     ###$self->_simplify_slices(&Slic3r::SCALED_RESOLUTION);
     */
-    
+
     this->state.set_done(posPerimeters);
 }
 
@@ -1065,17 +1068,17 @@ PrintObject::_infill()
 {
     if (this->state.is_done(posInfill)) return;
     this->state.set_started(posInfill);
-    
+
     parallelize<Layer*>(
         std::queue<Layer*>(std::deque<Layer*>(this->layers.begin(), this->layers.end())),  // cast LayerPtrs to std::queue<Layer*>
         boost::bind(&Slic3r::Layer::make_fills, _1),
         this->_print->config.threads.value
     );
-    
+
     /*  we could free memory now, but this would make this step not idempotent
     ### $_->fill_surfaces->clear for map @{$_->regions}, @{$object->layers};
     */
-    
+
     this->state.set_done(posInfill);
 }
 
diff --git a/xs/src/libslic3r/SLAPrint.cpp b/xs/src/libslic3r/SLAPrint.cpp
index ceb89018e..f8fa01b13 100644
--- a/xs/src/libslic3r/SLAPrint.cpp
+++ b/xs/src/libslic3r/SLAPrint.cpp
@@ -7,9 +7,12 @@
 #include <iostream>
 #include <complex>
 #include <cstdio>
+#include <boost/bind/bind.hpp>
 
 namespace Slic3r {
 
+using boost::placeholders::_1;
+
 void
 SLAPrint::slice()
 {
diff --git a/xs/src/libslic3r/TriangleMesh.cpp b/xs/src/libslic3r/TriangleMesh.cpp
index e4be594a0..b3f91a85a 100644
--- a/xs/src/libslic3r/TriangleMesh.cpp
+++ b/xs/src/libslic3r/TriangleMesh.cpp
@@ -14,6 +14,7 @@
 #include <stdexcept>
 #include <boost/config.hpp>
 #include <boost/nowide/convert.hpp>
+#include <boost/bind/bind.hpp>
 
 #ifdef SLIC3R_DEBUG
 #include "SVG.hpp"
@@ -21,6 +22,8 @@
 
 namespace Slic3r {
 
+using boost::placeholders::_1;
+
 TriangleMesh::TriangleMesh()
     : repaired(false)
 {
-- 
2.37.3

