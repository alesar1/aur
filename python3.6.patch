From 6b428ffc6e680c68f0ccc5f8c39723d311f45be8 Mon Sep 17 00:00:00 2001
From: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date: Mon, 26 Dec 2016 20:13:01 +0100
Subject: [PATCH] py36: fix url parsing

---
 mitmproxy/net/http/url.py           | 14 ++++++++------
 test/mitmproxy/net/http/test_url.py | 19 +++++++++++++------
 2 files changed, 21 insertions(+), 12 deletions(-)

diff --git a/mitmproxy/net/http/url.py b/mitmproxy/net/http/url.py
index ff3d526..b6dcee9 100644
--- a/mitmproxy/net/http/url.py
+++ b/mitmproxy/net/http/url.py
@@ -51,10 +51,17 @@ def parse(url):
     else:
         host = parsed.hostname.encode("idna")
         parsed = encode_parse_result(parsed, "ascii")
+    if not check.is_valid_host(host):
+        raise ValueError("Invalid Host")
 
-    port = parsed.port
+    try:
+        port = parsed.port
+    except:
+        raise ValueError("Invalid Port")
     if not port:
         port = 443 if parsed.scheme == b"https" else 80
+    if not check.is_valid_port(port):
+        raise ValueError("Invalid Port")
 
     full_path = urllib.parse.urlunparse(
         (b"", b"", parsed.path, parsed.params, parsed.query, parsed.fragment)
@@ -62,11 +69,6 @@ def parse(url):
     if not full_path.startswith(b"/"):
         full_path = b"/" + full_path
 
-    if not check.is_valid_host(host):
-        raise ValueError("Invalid Host")
-    if not check.is_valid_port(port):
-        raise ValueError("Invalid Port")
-
     return parsed.scheme, host, port, full_path
 
 
diff --git a/test/mitmproxy/net/http/test_url.py b/test/mitmproxy/net/http/test_url.py
index 94b2eac..e55d186 100644
--- a/test/mitmproxy/net/http/test_url.py
+++ b/test/mitmproxy/net/http/test_url.py
@@ -1,3 +1,6 @@
+import sys
+import pytest
+
 from mitmproxy.test import tutils
 from mitmproxy.net.http import url
 
@@ -30,9 +33,6 @@ def test_parse():
     s, h, po, pa = url.parse(b"https://foo")
     assert po == 443
 
-    with tutils.raises(ValueError):
-        url.parse(b"https://foo:bar")
-
     # Invalid IDNA
     with tutils.raises(ValueError):
         url.parse("http://\xfafoo")
@@ -42,14 +42,21 @@ def test_parse():
     # Null byte in host
     with tutils.raises(ValueError):
         url.parse("http://foo\0")
-    # Port out of range
-    _, _, port, _ = url.parse("http://foo:999999")
-    assert port == 80
+    # Invalid port
+    with tutils.raises(ValueError):
+        url.parse(b"https://foo:bar")
     # Invalid IPv6 URL - see http://www.ietf.org/rfc/rfc2732.txt
     with tutils.raises(ValueError):
         url.parse('http://lo[calhost')
 
 
+@pytest.mark.skipif(sys.version_info < (3, 6), reason='requires Python 3.6 or higher')
+def test_parse_port_range():
+    # Port out of range
+    with tutils.raises(ValueError):
+        url.parse("http://foo:999999")
+
+
 def test_unparse():
     assert url.unparse("http", "foo.com", 99, "") == "http://foo.com:99"
     assert url.unparse("http", "foo.com", 80, "/bar") == "http://foo.com/bar"
From e10022b8189b8a0696316deeb0e3bdecd5bc6afa Mon Sep 17 00:00:00 2001
From: Thomas Kriechbaumer <thomas@kriechbaumer.name>
Date: Mon, 26 Dec 2016 19:59:29 +0100
Subject: [PATCH] py36: fix type information

---
 mitmproxy/utils/typecheck.py | 27 ++++++++++++++++++++-------
 1 file changed, 20 insertions(+), 7 deletions(-)

diff --git a/mitmproxy/utils/typecheck.py b/mitmproxy/utils/typecheck.py
index ca2c7d5..0b29f6a 100644
--- a/mitmproxy/utils/typecheck.py
+++ b/mitmproxy/utils/typecheck.py
@@ -1,4 +1,5 @@
 import typing
+import sys
 
 
 def check_type(attr_name: str, value: typing.Any, typeinfo: type) -> None:
@@ -21,8 +22,15 @@ def check_type(attr_name: str, value: typing.Any, typeinfo: type) -> None:
         type(value)
     ))
 
-    if typeinfo.__qualname__ == "Union":
-        for T in typeinfo.__union_params__:
+    typename = str(typeinfo)
+
+    if typename.startswith("typing.Union"):
+        if sys.version_info < (3, 6):
+            types = typeinfo.__union_params__
+        else:
+            types = typeinfo.__args__
+
+        for T in types:
             try:
                 check_type(attr_name, value, T)
             except TypeError:
@@ -30,21 +38,26 @@ def check_type(attr_name: str, value: typing.Any, typeinfo: type) -> None:
             else:
                 return
         raise e
-    elif typeinfo.__qualname__ == "Tuple":
+    elif typename.startswith("typing.Tuple"):
+        if sys.version_info < (3, 6):
+            types = typeinfo.__tuple_params__
+        else:
+            types = typeinfo.__args__
+
         if not isinstance(value, (tuple, list)):
             raise e
-        if len(typeinfo.__tuple_params__) != len(value):
+        if len(types) != len(value):
             raise e
-        for i, (x, T) in enumerate(zip(value, typeinfo.__tuple_params__)):
+        for i, (x, T) in enumerate(zip(value, types)):
             check_type("{}[{}]".format(attr_name, i), x, T)
         return
-    elif typeinfo.__qualname__ == "Sequence":
+    elif typename.startswith("typing.Sequence"):
         T = typeinfo.__args__[0]
         if not isinstance(value, (tuple, list)):
             raise e
         for v in value:
             check_type(attr_name, v, T)
-    elif typeinfo.__qualname__ == "IO":
+    elif typename.startswith("typing.IO"):
         if hasattr(value, "read"):
             return
     elif not isinstance(value, typeinfo):
