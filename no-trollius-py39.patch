diff -ur catkin_tools-0.4.5/catkin_tools/common.py catkin_tools-0.4.5/catkin_tools/common.py
--- catkin_tools-0.4.5/catkin_tools/common.py	2019-04-02 06:04:14.000000000 -0700
+++ catkin_tools-0.4.5/catkin_tools/common.py	2020-12-04 01:03:56.132007101 -0800
@@ -20,7 +20,7 @@
 import re
 import sys
 
-import trollius as asyncio
+import asyncio
 
 from shlex import split as _cmd_split
 try:
diff -ur catkin_tools-0.4.5/catkin_tools/execution/executor.py catkin_tools-0.4.5/catkin_tools/execution/executor.py
--- catkin_tools-0.4.5/catkin_tools/execution/executor.py	2019-04-02 06:04:14.000000000 -0700
+++ catkin_tools-0.4.5/catkin_tools/execution/executor.py	2020-12-04 01:06:29.696984322 -0800
@@ -18,7 +18,7 @@
 
 from itertools import tee
 
-import trollius as asyncio
+import asyncio
 
 from concurrent.futures import ThreadPoolExecutor
 from concurrent.futures import FIRST_COMPLETED
@@ -43,8 +43,7 @@
     return [v for c, v in head if c], [v for c, v in tail if not c]
 
 
-@asyncio.coroutine
-def async_job(verb, job, threadpool, locks, event_queue, log_path):
+async def async_job(verb, job, threadpool, locks, event_queue, log_path):
     """Run a sequence of Stages from a Job and collect their output.
 
     :param job: A Job instance
@@ -70,7 +69,7 @@
         # Check for stage synchronization lock
         if stage.locked_resource is not None:
             lock = locks.setdefault(stage.locked_resource, asyncio.Lock())
-            yield asyncio.From(lock)
+            await lock.acquire()
         else:
             lock = FakeLock()
 
@@ -79,7 +78,7 @@
             if stage.occupy_job:
                 if not occupying_job:
                     while job_server.try_acquire() is None:
-                        yield asyncio.From(asyncio.sleep(0.05))
+                        await asyncio.sleep(0.05)
                     occupying_job = True
             else:
                 if occupying_job:
@@ -103,16 +102,15 @@
                             # Get the logger
                             protocol_type = stage.logger_factory(verb, job.jid, stage.label, event_queue, log_path)
                             # Start asynchroonous execution
-                            transport, logger = yield asyncio.From(
-                                async_execute_process(
-                                    protocol_type,
-                                    **stage.async_execute_process_kwargs))
+                            transport, logger = await async_execute_process(
+                                protocol_type,
+                                **stage.async_execute_process_kwargs)
                             break
                         except OSError as exc:
                             if 'Text file busy' in str(exc):
                                 # This is a transient error, try again shortly
                                 # TODO: report the file causing the problem (exc.filename)
-                                yield asyncio.From(asyncio.sleep(0.01))
+                                await asyncio.sleep(0.01)
                                 continue
                             raise
 
@@ -125,7 +123,7 @@
                         **stage.async_execute_process_kwargs))
 
                     # Asynchronously yield until this command is completed
-                    retcode = yield asyncio.From(logger.complete)
+                    retcode = await logger.complete
                 except:  # noqa: E722
                     # Bare except is permissable here because the set of errors which the CommandState might raise
                     # is unbounded. We capture the traceback here and save it to the build's log files.
@@ -137,11 +135,11 @@
                 logger = IOBufferLogger(verb, job.jid, stage.label, event_queue, log_path)
                 try:
                     # Asynchronously yield until this function is completed
-                    retcode = yield asyncio.From(get_loop().run_in_executor(
+                    retcode = await get_loop().run_in_executor(
                         threadpool,
                         stage.function,
                         logger,
-                        event_queue))
+                        event_queue)
                 except:  # noqa: E722
                     # Bare except is permissable here because the set of errors which the FunctionStage might raise
                     # is unbounded. We capture the traceback here and save it to the build's log files.
@@ -179,11 +177,10 @@
             lock.release()
 
     # Finally, return whether all stages of the job completed
-    raise asyncio.Return(job.jid, all_stages_succeeded)
+    return (job.jid, all_stages_succeeded)
 
 
-@asyncio.coroutine
-def execute_jobs(
+async def execute_jobs(
         verb,
         jobs,
         locks,
@@ -272,14 +269,14 @@
         ))
 
         # Process jobs as they complete asynchronously
-        done_job_fs, active_job_fs = yield asyncio.From(asyncio.wait(
+        done_job_fs, active_job_fs = await asyncio.wait(
             active_job_fs,
             timeout=0.10,
-            return_when=FIRST_COMPLETED))
+            return_when=FIRST_COMPLETED)
 
         for done_job_f in done_job_fs:
             # Capture a result once the job has finished
-            job_id, succeeded = yield asyncio.From(done_job_f)
+            job_id, succeeded = await done_job_f
 
             # Release a jobserver token now that this job has succeeded
             job_server.release(job_id)
@@ -362,7 +359,7 @@
         completed=completed_jobs
     ))
 
-    raise asyncio.Return(all(completed_jobs.values()))
+    return all(completed_jobs.values())
 
 
 def run_until_complete(coroutine):
diff -ur catkin_tools-0.4.5/catkin_tools/verbs/catkin_build/build.py catkin_tools-0.4.5/catkin_tools/verbs/catkin_build/build.py
--- catkin_tools-0.4.5/catkin_tools/verbs/catkin_build/build.py	2019-04-02 06:04:14.000000000 -0700
+++ catkin_tools-0.4.5/catkin_tools/verbs/catkin_build/build.py	2020-12-04 01:03:56.132007101 -0800
@@ -22,7 +22,7 @@
 import traceback
 import yaml
 
-import trollius as asyncio
+import asyncio
 
 try:
     # Python3
diff -ur catkin_tools-0.4.5/requirements.txt catkin_tools-0.4.5/requirements.txt
--- catkin_tools-0.4.5/requirements.txt	2019-04-02 06:04:14.000000000 -0700
+++ catkin_tools-0.4.5/requirements.txt	2020-12-04 01:03:56.132007101 -0800
@@ -3,4 +3,3 @@
 pyyaml
 setuptools
 sphinxcontrib-programoutput
-trollius
diff -ur catkin_tools-0.4.5/setup.py catkin_tools-0.4.5/setup.py
--- catkin_tools-0.4.5/setup.py	2019-04-02 06:04:14.000000000 -0700
+++ catkin_tools-0.4.5/setup.py	2020-12-04 01:03:56.132007101 -0800
@@ -15,7 +15,6 @@
     'setuptools',
     'PyYAML',
     'osrf-pycommon > 0.1.1',
-    'trollius'
 ]
 if sys.version_info[0] == 2 and sys.version_info[1] <= 6:
     install_requires.append('argparse')
