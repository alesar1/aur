
 modules/video_filter/opencv_wrapper.c | 108 +++++++++++++-------------
 1 file changed, 56 insertions(+), 52 deletions(-)

diff --git a/modules/video_filter/opencv_wrapper.c b/modules/video_filter/opencv_wrapper.c
index ed48fe1f67..6560502fa6 100644
--- a/modules/video_filter/opencv_wrapper.c
+++ b/modules/video_filter/opencv_wrapper.c
@@ -158,6 +158,8 @@ static int Create( vlc_object_t *p_this )
     if( p_filter-&gt;p_sys == NULL )
         return VLC_ENOMEM;
 
+    filter_sys_t *p_sys = p_filter-&gt;p_sys;
+
     /* Load the internal OpenCV filter.
      *
      * This filter object is needed to call the internal OpenCV filter
@@ -167,39 +169,39 @@ static int Create( vlc_object_t *p_this )
      * We don't need to set up video formats for this filter as it not
      * actually using a picture_t.
      */
-    p_filter-&gt;p_sys-&gt;p_opencv = vlc_object_create( p_filter, sizeof(filter_t) );
-    if( !p_filter-&gt;p_sys-&gt;p_opencv ) {
-        free( p_filter-&gt;p_sys );
+    p_sys-&gt;p_opencv = vlc_object_create( p_filter, sizeof(filter_t) );
+    if( !p_sys-&gt;p_opencv ) {
+        free( p_sys );
         return VLC_ENOMEM;
     }
 
-    p_filter-&gt;p_sys-&gt;psz_inner_name = var_InheritString( p_filter, "opencv-filter-name" );
-    if( p_filter-&gt;p_sys-&gt;psz_inner_name )
-        p_filter-&gt;p_sys-&gt;p_opencv-&gt;p_module =
-            module_need( p_filter-&gt;p_sys-&gt;p_opencv,
+    p_sys-&gt;psz_inner_name = var_InheritString( p_filter, "opencv-filter-name" );
+    if( p_sys-&gt;psz_inner_name )
+        p_sys-&gt;p_opencv-&gt;p_module =
+            module_need( p_sys-&gt;p_opencv,
                          "opencv internal filter",
-                         p_filter-&gt;p_sys-&gt;psz_inner_name,
+                         p_sys-&gt;psz_inner_name,
                          true );
 
-    if( !p_filter-&gt;p_sys-&gt;p_opencv-&gt;p_module )
+    if( !p_sys-&gt;p_opencv-&gt;p_module )
     {
-        msg_Err( p_filter, "can't open internal opencv filter: %s", p_filter-&gt;p_sys-&gt;psz_inner_name );
-        free( p_filter-&gt;p_sys-&gt;psz_inner_name );
-        p_filter-&gt;p_sys-&gt;psz_inner_name = NULL;
-        vlc_object_release( p_filter-&gt;p_sys-&gt;p_opencv );
-        free( p_filter-&gt;p_sys );
+        msg_Err( p_filter, "can't open internal opencv filter: %s", p_sys-&gt;psz_inner_name );
+        free( p_sys-&gt;psz_inner_name );
+        p_sys-&gt;psz_inner_name = NULL;
+        vlc_object_release( p_sys-&gt;p_opencv );
+        free( p_sys );
 
         return VLC_ENOMOD;
     }
 
 
     /* Init structure */
-    p_filter-&gt;p_sys-&gt;p_image = image_HandlerCreate( p_filter );
+    p_sys-&gt;p_image = image_HandlerCreate( p_filter );
     for( int i = 0; i &lt; VOUT_MAX_PLANES; i++ )
-        p_filter-&gt;p_sys-&gt;p_cv_image[i] = NULL;
-    p_filter-&gt;p_sys-&gt;p_proc_image = NULL;
-    p_filter-&gt;p_sys-&gt;p_to_be_freed = NULL;
-    p_filter-&gt;p_sys-&gt;i_cv_image_size = 0;
+        p_sys-&gt;p_cv_image[i] = NULL;
+    p_sys-&gt;p_proc_image = NULL;
+    p_sys-&gt;p_to_be_freed = NULL;
+    p_sys-&gt;i_cv_image_size = 0;
 
     /* Retrieve and apply config */
     psz_chroma = var_InheritString( p_filter, "opencv-chroma" );
@@ -207,16 +209,16 @@ static int Create( vlc_object_t *p_this )
     {
         msg_Err( p_filter, "configuration variable %s empty, using 'grey'",
                          "opencv-chroma" );
-        p_filter-&gt;p_sys-&gt;i_internal_chroma = GREY;
+        p_sys-&gt;i_internal_chroma = GREY;
     } else if( !strcmp( psz_chroma, "input" ) )
-        p_filter-&gt;p_sys-&gt;i_internal_chroma = CINPUT;
+        p_sys-&gt;i_internal_chroma = CINPUT;
     else if( !strcmp( psz_chroma, "I420" ) )
-        p_filter-&gt;p_sys-&gt;i_internal_chroma = GREY;
+        p_sys-&gt;i_internal_chroma = GREY;
     else if( !strcmp( psz_chroma, "RGB32" ) )
-        p_filter-&gt;p_sys-&gt;i_internal_chroma = RGB;
+        p_sys-&gt;i_internal_chroma = RGB;
     else {
         msg_Err( p_filter, "no valid opencv-chroma provided, using 'grey'" );
-        p_filter-&gt;p_sys-&gt;i_internal_chroma = GREY;
+        p_sys-&gt;i_internal_chroma = GREY;
     }
 
     free( psz_chroma );
@@ -226,28 +228,28 @@ static int Create( vlc_object_t *p_this )
     {
         msg_Err( p_filter, "configuration variable %s empty, using 'input'",
                          "opencv-output" );
-        p_filter-&gt;p_sys-&gt;i_wrapper_output = VINPUT;
+        p_sys-&gt;i_wrapper_output = VINPUT;
     } else if( !strcmp( psz_output, "none" ) )
-        p_filter-&gt;p_sys-&gt;i_wrapper_output = NONE;
+        p_sys-&gt;i_wrapper_output = NONE;
     else if( !strcmp( psz_output, "input" ) )
-        p_filter-&gt;p_sys-&gt;i_wrapper_output = VINPUT;
+        p_sys-&gt;i_wrapper_output = VINPUT;
     else if( !strcmp( psz_output, "processed" ) )
-        p_filter-&gt;p_sys-&gt;i_wrapper_output = PROCESSED;
+        p_sys-&gt;i_wrapper_output = PROCESSED;
     else {
         msg_Err( p_filter, "no valid opencv-output provided, using 'input'" );
-        p_filter-&gt;p_sys-&gt;i_wrapper_output = VINPUT;
+        p_sys-&gt;i_wrapper_output = VINPUT;
     }
     free( psz_output );
 
-    p_filter-&gt;p_sys-&gt;f_scale =
+    p_sys-&gt;f_scale =
         var_InheritFloat( p_filter, "opencv-scale" );
 
     msg_Info(p_filter, "Configuration: opencv-scale: %f, opencv-chroma: %d, "
         "opencv-output: %d, opencv-filter %s",
-        p_filter-&gt;p_sys-&gt;f_scale,
-        p_filter-&gt;p_sys-&gt;i_internal_chroma,
-        p_filter-&gt;p_sys-&gt;i_wrapper_output,
-        p_filter-&gt;p_sys-&gt;psz_inner_name);
+        p_sys-&gt;f_scale,
+        p_sys-&gt;i_internal_chroma,
+        p_sys-&gt;i_wrapper_output,
+        p_sys-&gt;psz_inner_name);
 
 #ifndef NDEBUG
     msg_Dbg( p_filter, "opencv_wrapper successfully started" );
@@ -266,14 +268,15 @@ static int Create( vlc_object_t *p_this )
 static void Destroy( vlc_object_t *p_this )
 {
     filter_t* p_filter = (filter_t*)p_this;
+    filter_sys_t* p_sys = p_filter-&gt;p_sys;
     ReleaseImages( p_filter );
 
     // Release the internal OpenCV filter.
-    module_unneed( p_filter-&gt;p_sys-&gt;p_opencv, p_filter-&gt;p_sys-&gt;p_opencv-&gt;p_module );
-    vlc_object_release( p_filter-&gt;p_sys-&gt;p_opencv );
-    p_filter-&gt;p_sys-&gt;p_opencv = NULL;
+    module_unneed( p_sys-&gt;p_opencv, p_sys-&gt;p_opencv-&gt;p_module );
+    vlc_object_release( p_sys-&gt;p_opencv );
+    p_sys-&gt;p_opencv = NULL;
 
-    free( p_filter-&gt;p_sys );
+    free( p_sys );
 }
 
 /*****************************************************************************
@@ -403,6 +406,7 @@ static void VlcPictureToIplImage( filter_t* p_filter, picture_t* p_in )
  *****************************************************************************/
 static picture_t* Filter( filter_t* p_filter, picture_t* p_pic )
 {
+    filter_sys_t* p_sys = p_filter-&gt;p_sys;
     picture_t* p_outpic = filter_NewPicture( p_filter );
     if( p_outpic == NULL ) {
         msg_Err( p_filter, "couldn't get a p_outpic!" );
@@ -413,20 +417,20 @@ static picture_t* Filter( filter_t* p_filter, picture_t* p_pic )
     video_format_t fmt_out;
 
     // Make a copy if we want to show the original input
-    if (p_filter-&gt;p_sys-&gt;i_wrapper_output == VINPUT)
+    if (p_sys-&gt;i_wrapper_output == VINPUT)
         picture_Copy( p_outpic, p_pic );
 
     VlcPictureToIplImage( p_filter, p_pic );
     // Pass the image (as a pointer to the first IplImage*) to the
     // internal OpenCV filter for processing.
-    p_filter-&gt;p_sys-&gt;p_opencv-&gt;pf_video_filter( p_filter-&gt;p_sys-&gt;p_opencv, (picture_t*)&amp;(p_filter-&gt;p_sys-&gt;p_cv_image[0]) );
+    p_sys-&gt;p_opencv-&gt;pf_video_filter( p_sys-&gt;p_opencv, (picture_t*)&amp;(p_sys-&gt;p_cv_image[0]) );
 
-    if(p_filter-&gt;p_sys-&gt;i_wrapper_output == PROCESSED) {
+    if(p_sys-&gt;i_wrapper_output == PROCESSED) {
         // Processed video
-        if( (p_filter-&gt;p_sys-&gt;p_proc_image) &amp;&amp;
-            (p_filter-&gt;p_sys-&gt;p_proc_image-&gt;i_planes &gt; 0) &amp;&amp;
-            (p_filter-&gt;p_sys-&gt;i_internal_chroma != CINPUT) ) {
-            //p_filter-&gt;p_sys-&gt;p_proc_image-&gt;format.i_chroma = VLC_CODEC_RGB24;
+        if( (p_sys-&gt;p_proc_image) &amp;&amp;
+            (p_sys-&gt;p_proc_image-&gt;i_planes &gt; 0) &amp;&amp;
+            (p_sys-&gt;i_internal_chroma != CINPUT) ) {
+            //p_sys-&gt;p_proc_image-&gt;format.i_chroma = VLC_CODEC_RGB24;
 
             memset( &amp;fmt_out, 0, sizeof(video_format_t) );
             fmt_out = p_pic-&gt;format;
@@ -438,16 +442,16 @@ static picture_t* Filter( filter_t* p_filter, picture_t* p_pic )
              * main video output error: pictures leaked, trying to workaround
              */
             picture_t* p_outpic_tmp = image_Convert(
-                        p_filter-&gt;p_sys-&gt;p_image,
-                        p_filter-&gt;p_sys-&gt;p_proc_image,
-                        &amp;(p_filter-&gt;p_sys-&gt;p_proc_image-&gt;format),
+                        p_sys-&gt;p_image,
+                        p_sys-&gt;p_proc_image,
+                        &amp;(p_sys-&gt;p_proc_image-&gt;format),
                         &amp;fmt_out );
 
             picture_CopyPixels( p_outpic, p_outpic_tmp );
             CopyInfoAndRelease( p_outpic, p_outpic_tmp );
-        } else if( p_filter-&gt;p_sys-&gt;i_internal_chroma == CINPUT ) {
-            picture_CopyPixels( p_outpic, p_filter-&gt;p_sys-&gt;p_proc_image );
-            picture_CopyProperties( p_outpic, p_filter-&gt;p_sys-&gt;p_proc_image );
+        } else if( p_sys-&gt;i_internal_chroma == CINPUT ) {
+            picture_CopyPixels( p_outpic, p_sys-&gt;p_proc_image );
+            picture_CopyProperties( p_outpic, p_sys-&gt;p_proc_image );
         }
     }
 
@@ -458,7 +462,7 @@ static picture_t* Filter( filter_t* p_filter, picture_t* p_pic )
     msg_Dbg( p_filter, "Filter() done" );
 #endif
 
-    if( p_filter-&gt;p_sys-&gt;i_wrapper_output != NONE ) {
+    if( p_sys-&gt;i_wrapper_output != NONE ) {
         return p_outpic;
     } else { // NONE
         picture_Release( p_outpic );
-- 
2.17.0


