diff -rupN ipfw3-2012/kipfw/ipfw2_mod.c ipfw3-2012.new/kipfw/ipfw2_mod.c
--- ipfw3-2012/kipfw/ipfw2_mod.c	2013-05-02 12:04:52.000000000 +0200
+++ ipfw3-2012.new/kipfw/ipfw2_mod.c	2015-07-18 13:01:20.781769941 +0200
@@ -97,6 +97,9 @@ static inline int inet_iif(const struct
 }
 
 #else
+#ifdef _NET_IPV6_H
+#undef _NET_IPV6_H
+#endif
 #include <net/inet_hashtables.h>	/* inet_lookup */
 #endif
 #endif /* __linux__ */
@@ -218,7 +221,7 @@ ipfw_ctl_h(struct sockopt *s, int cmd, i
 	struct thread t;
 	int ret = EINVAL;
 
-	memset(s, 0, sizeof(s));
+	memset(s, 0, sizeof(*s));
 	s->sopt_name = cmd;
 	s->sopt_dir = dir;
 	s->sopt_valsize = len;
@@ -466,16 +469,15 @@ static struct nf_sockopt_ops ipfw_sockop
  * so we have an #ifdef to set the proper argument type.
  */
 static unsigned int
-call_ipfw(unsigned int hooknum,
+call_ipfw(const struct nf_hook_ops *ops,
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,23) // in 2.6.22 we have **
 	struct sk_buff  **skb,
 #else
 	struct sk_buff  *skb,
 #endif
-	const struct net_device *in, const struct net_device *out,
-	int (*okfn)(struct sk_buff *))
+	const struct nf_hook_state *state)
 {
-	(void)hooknum; (void)skb; (void)in; (void)out; (void)okfn; /* UNUSED */
+	(void)ops; (void)skb; (void)state; /* UNUSED */
 	return NF_QUEUE;
 }
 
@@ -550,7 +552,7 @@ ipfw2_queue_handler(QH_ARGS)
 	m->m_skb = skb;
 	m->m_len = skb->len;		/* len from ip header to end */
 	m->m_pkthdr.len = skb->len;	/* total packet len */
-	m->m_pkthdr.rcvif = info->indev;
+	m->m_pkthdr.rcvif = info->state.in;
 	m->queue_entry = info;
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,22)	/* XXX was 2.6.0 */
 	m->m_data = (char *)skb->nh.iph;
@@ -559,10 +561,10 @@ ipfw2_queue_handler(QH_ARGS)
 #endif
 
 	/* XXX add the interface */
-	if (info->hook == IPFW_HOOK_IN) {
-		ret = ipfw_check_hook(NULL, &m, info->indev, PFIL_IN, NULL);
+	if (info->state.hook == IPFW_HOOK_IN) {
+		ret = ipfw_check_hook(NULL, &m, info->state.in, PFIL_IN, NULL);
 	} else {
-		ret = ipfw_check_hook(NULL, &m, info->outdev, PFIL_OUT, NULL);
+		ret = ipfw_check_hook(NULL, &m, info->state.out, PFIL_OUT, NULL);
 	}
 
 	if (m != NULL) {	/* Accept. reinject and free the mbuf */
@@ -615,7 +617,7 @@ netisr_dispatch(int num, struct mbuf *m)
 #endif
 
 	/* XXX to obey one-pass, possibly call the queue handler here */
-	REINJECT(info, ((num == -1)?NF_DROP:NF_STOP));	/* accept but no more firewall */
+	REINJECT(info, ((num == -1)?NF_DROP:NF_ACCEPT));	/* accept */
 }
 
 /*
@@ -724,8 +726,8 @@ linux_lookup(const int proto, const __be
 #define _CURR_GID f_gid
 #else /* 2.6.29 and above */
 /* use the current's file access real uid/gid */
-#define _CURR_UID f_cred->fsuid
-#define _CURR_GID f_cred->fsgid
+#define _CURR_UID f_cred->fsuid.val
+#define _CURR_GID f_cred->fsgid.val
 #endif
 
 #define GOOD_STATES (	\
@@ -818,18 +820,22 @@ nf_unregister_hooks(struct nf_hook_ops *
 
 static struct nf_hook_ops ipfw_ops[] __read_mostly = {
         {
+		{ NULL, NULL },
                 .hook           = call_ipfw,
+ 		.owner 		= THIS_MODULE,
+		NULL,
                 .pf             = PF_INET,
                 .hooknum        = IPFW_HOOK_IN,
                 .priority       = NF_IP_PRI_FILTER,
-                SET_MOD_OWNER
         },
         {
+		{ NULL, NULL },
                 .hook           = call_ipfw,
+ 		.owner 		= THIS_MODULE,
+		NULL,
                 .pf             = PF_INET,
                 .hooknum        = NF_IP_POST_ROUTING,
                 .priority       = NF_IP_PRI_FILTER,
-		SET_MOD_OWNER
         },
 };
 #endif /* __linux__ */
diff -rupN ipfw3-2012/kipfw/missing.h ipfw3-2012.new/kipfw/missing.h
--- ipfw3-2012/kipfw/missing.h	2013-05-02 12:04:52.000000000 +0200
+++ ipfw3-2012.new/kipfw/missing.h	2015-07-18 11:54:27.858473559 +0200
@@ -334,6 +334,14 @@ struct ifaltq {
 #define	if_xname	name
 #define	if_snd		XXX
 /* search local the ip addresses, used for the "me" keyword */
+
+struct ptr_heap {
+	void ** ptrs;
+	int max;
+	int size;
+	int (*gt)(void *, void *);
+};
+
 #include <linux/inetdevice.h>
 
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,25)
diff -rupN ipfw3-2012/sys/netinet/ipfw/ip_dummynet.c ipfw3-2012.new/sys/netinet/ipfw/ip_dummynet.c
--- ipfw3-2012/sys/netinet/ipfw/ip_dummynet.c	2012-08-20 17:43:52.000000000 +0200
+++ ipfw3-2012.new/sys/netinet/ipfw/ip_dummynet.c	2015-07-18 11:54:27.858473559 +0200
@@ -635,7 +635,7 @@ fsk_detach(struct dn_fsk *fs, int flags)
 		fs->sched->fp->free_fsk(fs);
 	fs->sched = NULL;
 	if (flags & DN_DELETE_FS) {
-		bzero(fs, sizeof(fs));	/* safety */
+		bzero(fs, sizeof(*fs));	/* safety */
 		free(fs, M_DUMMYNET);
 		dn_cfg.fsk_count--;
 	} else {
