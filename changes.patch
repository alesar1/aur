diff --git a/.gitignore b/.gitignore
index c63307f..347c1d9 100644
--- a/.gitignore
+++ b/.gitignore
@@ -11,7 +11,8 @@
 *.pydev*
 *.vcproj
 .idea/
-uid.dll
+lib/faf-uid
+lib/faf-uid.exe
 build/
 dist/
 Thumbs.db
diff --git a/.travis.yml b/.travis.yml
index 74ee1ab..3ca3e26 100644
--- a/.travis.yml
+++ b/.travis.yml
@@ -11,6 +11,7 @@ install:
   - "pip install cx_Freeze"
   - "pip install python-coveralls"
   - "pip install -r requirements.txt --trusted-host content.faforever.com"
+  - curl -s https://api.github.com/repos/FAForever/uid/releases/latest | jq -r '.assets[] | select(.name | contains("uid")) | .browser_download_url' | wget -i - -O ./lib/faf-uid
 
 
 before_script:
diff --git a/appveyor.yml b/appveyor.yml
index f58e1af..15e4cba 100644
--- a/appveyor.yml
+++ b/appveyor.yml
@@ -19,6 +19,7 @@ install:
   - ps: "$env:PYTEST_QT_API=\"pyqt4\""
   - ps: "$env:FAF_FORCE_PRODUCTION=true"
   - "%PYTHON%\\Scripts\\pip.exe install -r requirements.txt --trusted-host content.faforever.com"
+  - ps: (Invoke-WebRequest -Uri https://api.github.com/repos/FAForever/uid/releases/latest | ConvertFrom-Json).assets | where {$_.name -eq "faf-uid.exe"} | %{ iwr $_.browser_download_url -OutFile ".\\lib\\faf-uid.exe" }
 
 test_script:
     - "%PYTHON%\\Scripts\\py.test.exe -vv --full-trace"
diff --git a/setup.py b/setup.py
index cec04dc..2ea6973 100644
--- a/setup.py
+++ b/setup.py
@@ -11,7 +11,10 @@ sip.setapi('QList', 2)
 sip.setapi('QProcess', 2)
 
 import PyQt4.uic
-from cx_Freeze import setup, Executable
+if sys.platform == 'win32':
+    from cx_Freeze import setup, Executable
+else:
+    from distutils.core import setup
 
 sys.path.insert(0, "src")
 sys.path.insert(0, "lib")
@@ -19,16 +22,17 @@ sys.path.insert(0, "lib")
 company_name = 'FAF Community'
 product_name = 'Forged Alliance Forever'
 
-import config.version as version
-import PyQt4.uic
-git_version = version.get_git_version()
-msi_version = version.msi_version(git_version)
-appveyor_build_version = os.getenv('APPVEYOR_BUILD_VERSION')
-version.write_release_version(appveyor_build_version)
+if sys.platform == 'win32':
+  import config.version as version
+  import PyQt4.uic
+  git_version = version.get_git_version()
+  msi_version = version.msi_version(git_version)
+  appveyor_build_version = os.getenv('APPVEYOR_BUILD_VERSION')
+  version.write_release_version(appveyor_build_version)
 
-print('Git version:', git_version,
-      'Release version:', appveyor_build_version,
-      'Build version:', msi_version)
+  print('Git version:', git_version,
+        'Release version:', appveyor_build_version,
+        'Build version:', msi_version)
 
 # Ugly hack to fix broken PyQt4
 try:
@@ -43,7 +47,7 @@ except OSError:
 build_exe_options = {
     'include_files': ['res',
                       'RELEASE-VERSION',
-                      ('lib/uid.dll', 'uid.dll'),
+                      ('lib/faf-uid.exe', 'faf-uid.exe'),
                       ('lib/qt.conf', 'qt.conf'),
                       ('lib/xdelta3.exe', 'xdelta3.exe'),
                       ('lib/lua51.dll', 'lua51.dll')],
@@ -92,18 +96,31 @@ base = None
 if sys.platform == 'win32':
     base = 'Win32GUI'
 
-exe = Executable(
-    'src/__main__.py',
-    base=base,
-    targetName='FAForever.exe',
-    icon='res/faf.ico',
-    includes=[os.path.join(os.path.dirname(PyQt4.uic.__file__), "widget-plugins"),
-            "PyQt4.uic.widget-plugins"]
-)
+if sys.platform == 'win32':
+    platform_options = {
+        'executables': [Executable(
+                          'src/__main__.py',
+                          base=base,
+                          targetName='FAForever.exe',
+                          icon='res/faf.ico',
+                          includes=[os.path.join(os.path.dirname(PyQt4.uic.__file__), "widget-plugins"),
+                                  "PyQt4.uic.widget-plugins"]
+                      )],
+        'requires': ['bsdiff4', 'sip', 'PyQt4', 'cx_Freeze', 'cffi', 'py', 'faftools'],
+        'options': {'build_exe': build_exe_options,
+                 'bdist_msi': bdist_msi_options},
+        'version': msi_version,
+                 }
+        
+else:
+    from setuptools import find_packages
+    platform_options = {
+        'packages': find_packages(),
+        'version': os.getenv('FAFCLIENT_VERSION'),
+        }
 
 setup(
     name=product_name,
-    version=msi_version,
     description='Forged Alliance Forever - Lobby Client',
     long_description='FA Forever is a community project that allows you to play \
 Supreme Commander and Supreme Commander: Forged Alliance online \
@@ -113,8 +130,5 @@ ranked ladder play, and featured mods.',
     maintainer='Sheeo',
     url='http://www.faforever.com',
     license='GNU General Public License, Version 3',
-    options={'build_exe': build_exe_options,
-             'bdist_msi': bdist_msi_options},
-    executables=[exe],
-    requires=['bsdiff4', 'sip', 'PyQt4', 'cx_Freeze', 'cffi', 'py', 'faftools'],
+    **platform_options
 )
diff --git a/src/__main__.py b/src/__main__.py
index 438d743..f144245 100644
--- a/src/__main__.py
+++ b/src/__main__.py
@@ -30,14 +30,16 @@ uic.widgetPluginPath.append(path)
 if getattr(sys, 'frozen', False):
     os.chdir(os.path.dirname(sys.executable))
 else:
-    # We are most likely running from source
-    srcDir = os.path.dirname(os.path.relpath(__file__))
-    devRoot = os.path.abspath(os.path.join(srcDir, os.pardir))
-    os.chdir(devRoot)
-    # We need to set the working directory correctly.
+    if sys.platform == 'win32':
+        # We are most likely running from source
+        srcDir = os.path.dirname(os.path.relpath(__file__))
+        devRoot = os.path.abspath(os.path.join(srcDir, os.pardir))
+        os.chdir(devRoot)
+        # We need to set the working directory correctly.
 
 import util
-util.COMMON_DIR = os.path.join(os.getcwd(), "res")
+if sys.platform == 'win32':
+    util.COMMON_DIR = os.path.join(os.getcwd(), "res")
 
 # Set up crash reporting
 excepthook_original = sys.excepthook
diff --git a/src/client/_clientwindow.py b/src/client/_clientwindow.py
index fc6b900..4e8e027 100644
--- a/src/client/_clientwindow.py
+++ b/src/client/_clientwindow.py
@@ -1193,11 +1193,10 @@ class ClientWindow(FormClass, BaseClass):
 
         # Run an initial connectivity test and initialize a gamesession object
         # when done
-        self.connectivity = ConnectivityHelper(self, self.gamePort)
-        self.connectivity.connectivity_status_established.connect(self.initialize_game_session)
-        self.connectivity.start_test()
+        #self.connectivity = ConnectivityHelper(self, self.gamePort)
+        #self.connectivity.connectivity_status_established.connect(self.initialize_game_session)
+        #self.connectivity.start_test()
 
-    def initialize_game_session(self):
         self.game_session = GameSession(self, self.connectivity)
 
     def handle_registration_response(self, message):
@@ -1217,55 +1216,41 @@ class ClientWindow(FormClass, BaseClass):
                 'gameport': self.gamePort,
                 'faction': faction
             }
-            if self.connectivity.state == 'STUN':
-                msg['relay_address'] = self.connectivity.relay_address
+            #if self.connectivity.state == 'STUN':
+            #    msg['relay_address'] = self.connectivity.relay_address
             self.send(msg)
             self.game_session.ready.disconnect(request_launch)
         if self.game_session:
             self.game_session.ready.connect(request_launch)
-            self.game_session.listen()
+            #self.game_session.listen()
 
     def host_game(self, title, mod, visibility, mapname, password, is_rehost=False):
-        def request_launch():
-            msg = {
-                'command': 'game_host',
-                'title': title,
-                'mod': mod,
-                'visibility': visibility,
-                'mapname': mapname,
-                'password': password,
-                'is_rehost': is_rehost
-            }
-            if self.connectivity.state == 'STUN':
-                msg['relay_address'] = self.connectivity.relay_address
-            self.send(msg)
-            self.game_session.ready.disconnect(request_launch)
-        if self.game_session:
-            self.game_session.game_password = password
-            self.game_session.ready.connect(request_launch)
-            self.game_session.listen()
+        msg = {
+            'command': 'game_host',
+            'title': title,
+            'mod': mod,
+            'visibility': visibility,
+            'mapname': mapname,
+            'password': password,
+            'is_rehost': is_rehost
+        }
+        self.send(msg)
 
     def join_game(self, uid, password=None):
-        def request_launch():
-            msg = {
-                'command': 'game_join',
-                'uid': uid,
-                'gameport': self.gamePort
-            }
-            if password:
-                msg['password'] = password
-            if self.connectivity.state == "STUN":
-                msg['relay_address'] = self.connectivity.relay_address
-            self.send(msg)
-            self.game_session.ready.disconnect(request_launch)
-        if self.game_session:
-            self.game_session.game_password = password
-            self.game_session.ready.connect(request_launch)
-            self.game_session.listen()
+        msg = {
+            'command': 'game_join',
+            'uid': uid,
+            'gameport': self.gamePort
+        }
+        if password:
+            msg['password'] = password
+        #if self.connectivity.state == "STUN":
+        #    msg['relay_address'] = self.connectivity.relay_address
+        self.send(msg)
 
     def handle_game_launch(self, message):
-        if not self.game_session or not self.connectivity.is_ready:
-            logger.error("Not ready for game launch")
+        #if not self.game_session or not self.connectivity.is_ready:
+        #    logger.error("Not ready for game launch")
 
         logger.info("Handling game_launch via JSON " + str(message))
 
diff --git a/src/config/__init__.py b/src/config/__init__.py
index 38bb1d0..493e9b1 100644
--- a/src/config/__init__.py
+++ b/src/config/__init__.py
@@ -124,4 +124,10 @@ if environment == 'development':
     logging.getLogger().addHandler(devh)
     logging.getLogger().setLevel(logging.INFO)
 
+ch = logging.StreamHandler()
+ch.setLevel(logging.DEBUG)
+formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
+ch.setFormatter(formatter)
+logging.getLogger().addHandler(ch)
+
 logging.getLogger().info("FAF version: {} Environment: {}".format(version.get_git_version(), environment))
diff --git a/src/config/version.py b/src/config/version.py
index 8ee2014..bca2bc6 100644
--- a/src/config/version.py
+++ b/src/config/version.py
@@ -40,7 +40,7 @@ def call_git_describe():
         return line.strip()
     except Exception as e:
         print("Error grabbing git version: {}".format(e))
-        return "0.0.0-dev"
+        return None
 
 def is_development_version(version):
     return "-" in version and not is_prerelease_version(version)
@@ -94,7 +94,7 @@ def get_git_version():
     # If we still don't have anything, that's an error.
 
     if version is None:
-        raise ValueError("Cannot find the version number!")
+        raise ValueError("Cannot find the version number! Please provide RELEASE-VERSION file or run from git.")
 
     # Finally, return the current version.
     return version
diff --git a/src/connectivity/JsonRpcTcpClient.py b/src/connectivity/JsonRpcTcpClient.py
new file mode 100644
index 0000000..eb39f05
--- /dev/null
+++ b/src/connectivity/JsonRpcTcpClient.py
@@ -0,0 +1,73 @@
+from PyQt4.QtNetwork import QTcpSocket
+from PyQt4 import QtCore
+
+import json
+
+from decorators import with_logger
+
+
+@with_logger
+class JsonRpcTcpClient:
+    def __init__(self, host, port, requestHandlerInstance):
+        self.socket = QTcpSocket()
+        self.socket.connectToHost(host, port)
+        self.socket.readyRead.connect(self._onData)
+        self.requestHandlerInstance = requestHandlerInstance
+        requestHandlerInstance._client = self
+
+        self.nextid = 1
+
+    def __getattr__(self, attr):
+        return lambda *args: self._call(attr, args)
+
+    @QtCore.pyqtSlot()
+    def _onData(self):
+        while self.socket.canReadLine():
+            data = str(self.socket.readLine())
+            try:
+                request = json.loads(data)
+
+                # is this a request?
+                if "method" in request:
+                    try:
+                        m = getattr(self.requestHandlerInstance, request["method"])
+                        if "params" in request and len(request["params"]) > 0:
+                            result = m(*request["params"])
+                        else:
+                            result = m()
+
+                        # we do not only have a notification, but a request which awaits a response
+                        if "id" in request:
+                            responseObject = {
+                                "id": request["id"],
+                                "result": result,
+                                "jsonrpc": "2.0"
+                            }
+                            self.socket.write(json.dumps(responseObject))
+                    except AttributeError:
+                        if "id" in request:
+                            responseObject = {
+                                "id": request["id"],
+                                "error": "no such method",
+                                "jsonrpc": "2.0"
+                            }
+                            self.socket.write(json.dumps(responseObject))
+
+                # this is only a response
+                elif "result" in request:
+                    self.lastResponse = request["result"]
+
+            except ValueError as e:
+                self._logger.error("parse failed {}".format(data))
+
+    def _call(self, method, args):
+        rpcObject = {
+            "id": self.nextid,
+            "method": method,
+            "params": args,
+            "jsonrpc": "2.0"
+        }
+        self.nextid += 1
+        self.socket.write(json.dumps(rpcObject))
+        self.socket.waitForReadyRead()
+        return self.lastResponse
diff --git a/src/connectivity/ice_adapter.py b/src/connectivity/ice_adapter.py
new file mode 100644
index 0000000..76f203a
--- /dev/null
+++ b/src/connectivity/ice_adapter.py
@@ -0,0 +1,23 @@
+from decorators import with_logger
+
+@with_logger
+class IceAdapterHandler:
+
+    def onNeedSdp(self, localId, remoteId):
+        self._logger.info("onNeedSdp {} {}".format(localId, remoteId))
+
+    def onSdpGathered(self, localId, remoteId, sdp):
+        self._logger.info("onSdpGathered {} {} {}".format(localId, remoteId, sdp))
+        self.game_session.send("SdpRecord", [remoteId, sdp])
+
+    def onConnectionStateChanged(self, newState):
+        self._logger.info("onConnectionStateChanged {}".format(newState))
+        if self.game_session and newState == "Connected":
+            self.game_session._new_game_connection()
+
+    def onGpgNetMessageReceived(self, header, chunks):
+        self._logger.info("onGpgNetMessageReceived {} {}".format(header, chunks))
+        self.game_session._on_game_message(header, chunks)
+
+    def setGameSession(self, game_session):
+        self.game_session = game_session
\ No newline at end of file
diff --git a/src/fa/game_process.py b/src/fa/game_process.py
index 9052f31..61d2c63 100644
--- a/src/fa/game_process.py
+++ b/src/fa/game_process.py
@@ -1,9 +1,11 @@
 import os
+import sys
 
 from PyQt4 import QtCore, QtGui
 import config
 import re
 
+import util
 import logging
 logger = logging.getLogger(__name__)
 
@@ -41,8 +43,14 @@ class GameProcess(QtCore.QProcess):
 
             executable = os.path.join(config.Settings.get('game/bin/path'),
                                       "ForgedAlliance.exe")
-            command = '"' + executable + '" ' + " ".join(arguments)
-
+            if sys.platform == 'win32':
+                command = '"' + executable + '" ' + " ".join(arguments)
+            else:
+                command = util.wine_cmd_prefix + " " + util.wine_exe + ' "' + executable + '" ' + " ".join(arguments)
+                if util.wine_prefix:
+                    wine_env = QtCore.QProcessEnvironment.systemEnvironment()
+                    wine_env.insert("WINEPREFIX", util.wine_prefix)
+                    QtCore.QProcess.setProcessEnvironment(self, wine_env)
             logger.info("Running FA with info: " + str(info))
             logger.info("Running FA via command: " + command)
             logger.info("Running FA via executable: " + executable)
diff --git a/src/fa/game_session.py b/src/fa/game_session.py
index 8d4a81e..c171ecd 100644
--- a/src/fa/game_session.py
+++ b/src/fa/game_session.py
@@ -8,6 +8,11 @@ from decorators import with_logger
 from fa.game_connection import GPGNetConnection
 from fa.game_process import GameProcess, instance as game_process_instance
 
+from connectivity.ice_adapter import IceAdapterHandler
+from connectivity.JsonRpcTcpClient import JsonRpcTcpClient
+
+import os
+import subprocess
 
 class GameSessionState(IntEnum):
     # Game services are entirely off
@@ -40,11 +45,6 @@ class GameSession(QObject):
         # Subscribe to messages targeted at 'game' from the server
         client.subscribe_to('game', self)
 
-        # Connectivity helper
-        self.connectivity = connectivity
-        self.connectivity.ready.connect(self.ready.emit)
-        self.connectivity.peer_bound.connect(self._peer_bound)
-
         # Keep a parent pointer so we can use it to send
         # relay messages about the game state
         self._client = client  # type: Client
@@ -57,11 +57,6 @@ class GameSession(QObject):
         self.init_mode = 0
         self._joins, self._connects = [], []
 
-        # 'GPGNet' TCP listener
-        self._game_listener = QTcpServer(self)
-        self._game_listener.newConnection.connect(self._new_game_connection)
-        self._game_listener.listen(QHostAddress.LocalHost)
-
         # We only allow one game connection at a time
         self._game_connection = None
 
@@ -69,9 +64,33 @@ class GameSession(QObject):
         self._process.started.connect(self._launched)
         self._process.finished.connect(self._exited)
 
+        self.state = GameSessionState.LISTENING
+
+        try:
+            env = os.environ
+            env['PATH'] += ":" + os.getcwd()  # the Windows setup places executables in the root/CWD
+            env['PATH'] += ":" + os.path.join(os.getcwd(), "lib")  # the default download location for travis/Appveyor
+            self.ice_adapter_process = subprocess.Popen(["faf-ice-adapter",
+                                                         "-i",
+                                                         str(self.player.id),
+                                                         "-l",
+                                                         self.player.login],
+                                                        env=env
+                                                        #stdout=subprocess.STDOUT,
+                                                        #stderr=subprocess.STDOUT
+                                                        )
+            self.ice_adapter_handler = IceAdapterHandler()
+            self.ice_adapter_handler.setGameSession(self)
+            self.ice_adapter = JsonRpcTcpClient("127.0.0.1", 7236, self.ice_adapter_handler)
+        except OSError as err:
+            self._logger.error("error finding the faf-ice-adapter executable: {}".format(err))
+        except subprocess.CalledProcessError as exc:
+            self._logger.error("faf-ice-adapter executable error: {}".format(exc.output))
+
     @property
     def relay_port(self):
-        return self._game_listener.serverPort()
+        #print(self.ice_adapter.status())
+        return self.ice_adapter.status()["gpgnet"]["local_port"]
 
     @property
     def state(self):
@@ -81,40 +100,46 @@ class GameSession(QObject):
     def state(self, val):
         self._state = val
 
-    def listen(self):
-        """
-        Start listening for remote commands
-
-        Call this in good time before hosting a game,
-        e.g. when the host game dialog is being shown.
-        """
-        assert self.state == GameSessionState.OFF
-        self.state = GameSessionState.LISTENING
-        if self.connectivity.is_ready:
-            self.ready.emit()
-        else:
-            self.connectivity.prepare()
-
     def handle_message(self, message):
         command, args = message.get('command'), message.get('args', [])
         if command == 'SendNatPacket':
-            addr_and_port, message = args
-            host, port = addr_and_port.split(':')
-            self.connectivity.send(message, (host, port))
+            #addr_and_port, message = args
+            #host, port = addr_and_port.split(':')
+            #self.connectivity.send(message, (host, port))
+            None
         elif command == 'CreatePermission':
-            addr_and_port = args[0]
-            host, port = addr_and_port.split(':')
-            self.connectivity.permit((host, port))
+            #addr_and_port = args[0]
+            #host, port = addr_and_port.split(':')
+            #self.connectivity.permit((host, port))
+            None
         elif command == 'JoinGame':
-            addr, login, peer_id = args
-            self._joins.append(peer_id)
-            self.connectivity.bind(addr, login, peer_id)
+            login, peer_id = args
+            #self._joins.append(peer_id)
+            #self.connectivity.bind(addr, login, peer_id)
+            self.ice_adapter.joinGame(login, peer_id)
+        elif command == 'HostGame':
+            #addr, login, peer_id = args
+            #self._joins.append(peer_id)
+            #self.connectivity.bind(addr, login, peer_id)
+            self.ice_adapter.hostGame(args[0])
         elif command == 'ConnectToPeer':
-            addr, login, peer_id = args
-            self._connects.append(peer_id)
-            self.connectivity.bind(addr, login, peer_id)
+            login, peer_id = args
+            #self._connects.append(peer_id)
+            #self.connectivity.bind(addr, login, peer_id)
+            self.ice_adapter.connectToPeer(login, peer_id)
+        elif command == 'DisconnectFromPeer':
+            #addr, login, peer_id = args
+            #self._connects.append(peer_id)
+            #self.connectivity.bind(addr, login, peer_id)
+            self.ice_adapter.disconnectFromPeer(args[0])
+        elif command == "SdpRecord":
+            peer_id, sdp = args
+            #self._connects.append(peer_id)
+            #self.connectivity.bind(addr, login, peer_id)
+            self.ice_adapter.setSdp(peer_id, sdp)
         else:
-            self._game_connection.send(command, *args)
+            self._logger.warn("sending unhandled GPGNet message {} {}".format(command, args))
+            self.ice_adapter.sendToGpgNet(command, args)
 
     def send(self, command_id, args):
         self._logger.info("Outgoing relay message {} {}".format(command_id, args))
@@ -135,22 +160,22 @@ class GameSession(QObject):
 
     def _new_game_connection(self):
         self._logger.info("Game connected through GPGNet")
-        assert not self._game_connection
-        self._game_connection = GPGNetConnection(self._game_listener.nextPendingConnection())
-        self._game_connection.messageReceived.connect(self._on_game_message)
         self.state = GameSessionState.RUNNING
+        self.ready.emit()
 
     def _on_game_message(self, command, args):
+        self._logger.info("_on_game_message {}".format(self.game_map))
         self._logger.info("Incoming GPGNet: {} {}".format(command, args))
         if command == "GameState":
             if args[0] == 'Idle':
+                pass
                 # autolobby, port, nickname, uid, hasSupcom
-                self._game_connection.send("CreateLobby",
-                                           self.init_mode,
-                                           self.game_port + 1,
-                                           self.me.login,
-                                           self.me.id,
-                                           1)
+                #self._game_connection.send("CreateLobby",
+                #                           self.init_mode,
+                #                           self.game_port + 1,
+                #                           self.me.login,
+                #                           self.me.id,
+                #                           1)
             elif args[0] == 'Lobby':
                 # TODO: Eagerly initialize the game by hosting/joining early
                 pass
@@ -159,15 +184,11 @@ class GameSession(QObject):
 
         self.send(command, args)
 
-    def _turn_state_changed(self, val):
-        if val == TURNState.BOUND:
-            self.ready.emit()
-
     def _launched(self):
         self._logger.info("Game has started")
 
     def _exited(self, status):
-        self._game_connection = None
+        #self._game_connection = None
         self.state = GameSessionState.OFF
         self._logger.info("Game has exited with status code: {}".format(status))
         self.send('GameState', ['Ended'])
diff --git a/src/fa/updater.py b/src/fa/updater.py
index f235d73..9e6dceb 100644
--- a/src/fa/updater.py
+++ b/src/fa/updater.py
@@ -157,6 +157,7 @@ class Updater(QtCore.QObject):
 
 
     def run(self, *args, **kwargs):
+        return self.RESULT_SUCCESS
         clearLog()
         log("Update started at " + timestamp())
         log("Using appdata: " + util.APPDATA_DIR)
@@ -400,6 +401,7 @@ class Updater(QtCore.QObject):
                 os.chmod(dst_file, st.st_mode | stat.S_IWRITE)   # make all files we were considering writable, because we may need to patch them
 
     def doUpdate(self):
+        return
         """ The core function that does most of the actual update work."""
         try:
             if self.sim:
diff --git a/src/util/__init__.py b/src/util/__init__.py
index 21989b0..26bf310 100644
--- a/src/util/__init__.py
+++ b/src/util/__init__.py
@@ -1,12 +1,17 @@
 import sys
-
 import os
+import subprocess
+import getpass
 from ctypes import *
+
+from PyQt4.QtGui import QDesktopServices
+
 from config import Settings
+from PyQt4.QtGui import QDesktopServices
 
 # Developer mode flag
 def developer():
-    return sys.executable.endswith("python.exe")
+    return sys.executable.contains("python")
 
 from config import VERSION as VERSION_STRING
 
@@ -14,8 +19,11 @@ LOGFILE_MAX_SIZE = 256 * 1024  #256kb should be enough for anyone
 
 UNITS_PREVIEW_ROOT = "{}/faf/unitsDB/icons/big/".format(Settings.get('content/host'))
 
-#These are paths relative to the executable or main.py script
+# On Windows the res dir is relative to the executable or main.py script
 COMMON_DIR = os.path.join(os.getcwd(), "res")
+if sys.platform != 'win32' and not os.path.exists(COMMON_DIR):
+    #On Linux the res dir is installed as /usr/share/fafclient
+    COMMON_DIR = os.path.join("/usr", "share", "fafclient")
 
 # These directories are in Appdata (e.g. C:\ProgramData on some Win7 versions)
 if 'ALLUSERSPROFILE' in os.environ:
@@ -52,33 +60,42 @@ REPO_DIR = os.path.join(APPDATA_DIR, "repo")
 if not os.path.exists(REPO_DIR):
     os.makedirs(REPO_DIR)
 
+# Public settings object
+# Stolen from Config because reasons
+from config import _settings
+settings = _settings
+
+# initialize wine settings for non Windows platforms
+if sys.platform != 'win32':
+    wine_exe = settings.value("wine/exe", "wine", type=str)
+    wine_cmd_prefix = settings.value("wine/cmd_prefix", "", type=str)
+    if settings.contains("wine/prefix"):
+        wine_prefix = str(settings.value("wine/prefix", type=str))
+    else:
+        wine_prefix = os.path.join(os.path.expanduser("~"), ".wine")
+
 LOCALFOLDER = os.path.join(os.path.expandvars("%LOCALAPPDATA%"), "Gas Powered Games",
                            "Supreme Commander Forged Alliance")
 if not os.path.exists(LOCALFOLDER):
     LOCALFOLDER = os.path.join(os.path.expandvars("%USERPROFILE%"), "Local Settings", "Application Data",
                                "Gas Powered Games", "Supreme Commander Forged Alliance")
+if not os.path.exists(LOCALFOLDER) and sys.platform != 'win32':
+    LOCALFOLDER = os.path.join(wine_prefix, "drive_c", "users", getpass.getuser(), "Local Settings", "Application Data",
+                               "Gas Powered Games", "Supreme Commander Forged Alliance")
+
 PREFSFILENAME = os.path.join(LOCALFOLDER, "game.prefs")
+if not os.path.exists(PREFSFILENAME):
+    PREFSFILENAME = os.path.join(LOCALFOLDER, "Game.prefs")
 
 DOWNLOADED_RES_PIX = {}
 DOWNLOADING_RES_PIX = {}
 
-# This should be "My Documents" for most users. However, users with accents in their names can't even use these folders in Supcom
-# so we are nice and create a new home for them in the APPDATA_DIR
+PERSONAL_DIR = QDesktopServices.storageLocation(QDesktopServices.DocumentsLocation)
 try:
-    os.environ['USERNAME'].decode('ascii')  # Try to see if the user has a wacky username
-
-    import ctypes
-    from ctypes.wintypes import MAX_PATH
-
-    dll = ctypes.windll.shell32
-    buf = ctypes.create_unicode_buffer(MAX_PATH + 1)
-    if dll.SHGetSpecialFolderPathW(None, buf, 0x0005, False):
-        PERSONAL_DIR = (buf.value)
-    else:
-        raise StandardError
+    getpass.getuser().decode('ascii')  # Try to see if the user has a wacky username
 except:
     PERSONAL_DIR = os.path.join(APPDATA_DIR, "user")
-
+    
 #Ensure Application data directories exist
 if not os.path.isdir(APPDATA_DIR):
     os.makedirs(APPDATA_DIR)
@@ -149,11 +166,6 @@ __theme = None
 __themedir = None
 
 
-# Public settings object
-# Stolen from Config because reasons
-from config import _settings
-settings = _settings
-
 def clean_slate(path):
     if os.path.exists(path):
         logger.info("Wiping " + path)
@@ -560,23 +572,17 @@ def md5(file_name):
 
 def uniqueID(user, session):
     ''' This is used to uniquely identify a user's machine to prevent smurfing. '''
+    env = os.environ
+    env['PATH'] += ":" + os.getcwd() # the Windows setup places executables in the root/CWD
+    env['PATH'] += ":" + os.path.join(os.getcwd(), "lib") # the default download location for travis/Appveyor
     try:
-        if os.path.isfile("uid.dll"):
-            mydll = cdll.LoadLibrary("uid.dll")
-        else:
-            mydll = cdll.LoadLibrary(os.path.join("lib", "uid.dll"))
-
-        mydll.uid.restype = c_char_p
-        baseString = (mydll.uid(session, os.path.join(LOG_DIR, "uid.log")) )
-        DllCanUnloadNow()
-
-        return baseString
-
-    except:
-        QtGui.QMessageBox.warning(None, "C++ 2010 Runtime Missing",
-                                  "You are missing the Microsoft Visual C++ 2010 Runtime.<br><br>Get it from here: <a href='https://www.microsoft.com/en-us/download/details.aspx?id=5555'>https://www.microsoft.com/en-us/download/details.aspx?id=5555</a>")
-        logger.warning("UniqueID Failure, user warned", exc_info=sys.exc_info())
-        QtGui.QApplication.quit()
+        # on error, the uid exe returns 1 which will result in a CalledProcessError exception
+        return subprocess.check_output(["faf-uid", session], env=env, stderr=subprocess.STDOUT)
+    except OSError as err:
+        logger.error("UniqueID error finding the executable: {}".format(err))
+    except subprocess.CalledProcessError as exc:
+        logger.error("UniqueID executable error: {}".format(exc.output))
+    return None
 
 
 import datetime
diff --git a/tests/unit_tests/client/test_updating.py b/tests/unit_tests/client/test_updating.py
index 05b4ca4..ebf086a 100644
--- a/tests/unit_tests/client/test_updating.py
+++ b/tests/unit_tests/client/test_updating.py
@@ -6,7 +6,6 @@ import config
 def test_client_sends_current_version(qtbot, mocker):
     import client
     c = client.instance
-    mocker.patch('util.uniqueID', side_effect='some_unique_id')
     mocker.patch.object(c, 'send')
     mocker.patch.object(c, 'connected')
     mocker.patch.object(c, 'socket')
