--- a/libgaminggear/macros_converter_roccat_swarm.c
+++ b/libgaminggear/macros_converter_roccat_swarm.c
@@ -64,36 +64,46 @@
 	g_strlcpy((gchar *)(macro->name), new_name, SWARM_MACRO_NAME_LENGTH);
 }
 
+static gboolean myread(int fd, void *buffer, size_t nbytes, GError **error) {
+	int result;
+
+	result = read(fd, buffer, nbytes);
+	if (result == 0) {
+		g_set_error(error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Trying to read behind file boundaries"));
+		return FALSE;
+	} else if (result < 0) {
+		g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno), _("Could not read: %s"), g_strerror(errno));
+		return FALSE;
+	}
+	return TRUE;
+}
+
 static gboolean read32be(int fd, guint32 *value, GError **error) {
 	guint32 buffer;
 	int result;
 
-	result = read(fd, &buffer, sizeof(guint32));
-	if (result == 0) {
-		g_set_error(error, G_FILE_ERROR, G_FILE_ERROR_IO, _("Trying to read behind file boundaries"));
-		return FALSE;
-	} else if (result < 0) {
-		g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno), _("Could not read: %s"), g_strerror(errno));
-		return FALSE;
-	}
+	result = myread(fd, &buffer, sizeof(guint32), error);
+	if (!result)
+		return FALSE;
 
 	*value = GUINT32_FROM_BE(buffer);
+
+	return TRUE;
+}
+
+static gboolean mywrite(int fd, void const *buffer, size_t nbytes, GError **error) {
+	if (write(fd, buffer, nbytes) < 0) {
+		g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno), _("Could not write: %s"), g_strerror(errno));
+		return FALSE;
+	}
 	return TRUE;
 }
 
 static gboolean write32be(int fd, guint32 value, GError **error) {
 	guint32 buffer;
-	int result;
-
 	buffer = GUINT32_TO_BE(value);
 
-	result = write(fd, &buffer, sizeof(guint32));
-	if (result < 0) {
-		g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno), _("Could not write: %s"), g_strerror(errno));
-		return FALSE;
-	}
-
-	return TRUE;
+	return mywrite(fd, &buffer, sizeof(guint32), error);
 }
 
 static void utf16_from_be(gunichar2 *data, guint length) {
@@ -165,7 +175,7 @@
 	glong size;
 	int fd;
 
-	fd = open(filename, O_WRONLY | O_CREAT);
+	fd = open(filename, O_WRONLY | O_CREAT, 0666);
 	if (fd < 0) {
 		g_set_error(error, G_FILE_ERROR, g_file_error_from_errno(errno), _("Could not open %2$s macro file %1$s: %3$s"), filename, "Roccat Swarm", g_strerror(errno));
 		return FALSE;
@@ -181,7 +191,9 @@
 		utf16_to_be(macroset_name, size);
 		if (!write32be(fd, size * 2, error))
 			goto free_macrosets;
-		write(fd, macroset_name, size * 2);
+		if (!mywrite(fd, macroset_name, size * 2, error))
+			goto free_macrosets;
+
 		g_free(macroset_name);
 
 		macros = gaminggear_macros_get_macros(gaminggear_macros, *macroset, &macro_count, error);
@@ -202,7 +214,8 @@
 			if (!write32be(fd, sizeof(SwarmMacro), error))
 				goto free_macros;
 
-			write(fd, swarm_macro, sizeof(SwarmMacro));
+			if (!mywrite(fd, swarm_macro, sizeof(SwarmMacro), error))
+				goto free_macros;
 
 			g_free(swarm_macro);
 		}
@@ -244,7 +257,7 @@
 	for (macroset_index = 0; macroset_index < macroset_count; ++macroset_index) {
 		if (!read32be(fd, &size, error)) goto exit;
 		raw_macroset_name = (gunichar2 *)g_malloc(size);
-		read(fd, raw_macroset_name, size);
+		if (!myread(fd, raw_macroset_name, size, error)) goto exit;
 		utf16_from_be(raw_macroset_name, size / 2);
 		macroset_name = g_utf16_to_utf8(raw_macroset_name, size / 2, NULL, NULL, NULL);
 		g_free(raw_macroset_name);
@@ -256,7 +269,7 @@
 				g_warning("%u != %lu", size, sizeof(SwarmMacro));
 				// FIXME consequence
 			}
-			read(fd, &swarm_macro, size);
+			if (!myread(fd, &swarm_macro, size, error)) goto exit;
 
 			gaminggear_macro_keystrokes = swarm_macro_to_gaminggear_macro_keystrokes(&swarm_macro);
 			gaminggear_macro = gaminggear_macro_new(macroset_name, (gchar const *)swarm_macro.name, gaminggear_macro_keystrokes);
