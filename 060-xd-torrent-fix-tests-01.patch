backport of https://github.com/majestrate/XD/commit/e320c7c796fdd6d9587fd82a1f466ce196b827f2

diff --git a/src/xd/lib/bittorrent/extensions/extensions.go b/src/xd/lib/bittorrent/extensions/extensions.go
index d2b7640..29c255b 100644
--- a/src/xd/lib/bittorrent/extensions/extensions.go
+++ b/src/xd/lib/bittorrent/extensions/extensions.go
@@ -4,7 +4,6 @@ import (
 	"errors"
 	"github.com/zeebo/bencode"
 	"xd/lib/common"
-	"xd/lib/log"
 	"xd/lib/util"
 	"xd/lib/version"
 )
@@ -117,7 +116,6 @@ func (opts Message) ToWireMessage() common.WireMessage {
 		body = opts.PayloadRaw
 	} else {
 		// wtf? invalid message
-		log.Errorf("cannot create invalid extended message: %q", opts)
 		return nil
 	}
 	return common.NewWireMessage(common.Extended, []byte{opts.ID}, body)
diff --git a/src/xd/lib/bittorrent/swarm/peer.go b/src/xd/lib/bittorrent/swarm/peer.go
index d627d84..4a9221e 100644
--- a/src/xd/lib/bittorrent/swarm/peer.go
+++ b/src/xd/lib/bittorrent/swarm/peer.go
@@ -227,11 +227,11 @@ func (c *PeerConn) Unchoke() {
 	}
 }
 
-func (c *PeerConn) gotDownload(p common.PieceData) {
+func (c *PeerConn) gotDownload(p *common.PieceData) {
 	c.access.Lock()
 	var downloading []common.PieceRequest
 	for idx := range c.downloading {
-		if c.downloading[idx].Matches(&p) {
+		if c.downloading[idx].Matches(p) {
 			c.t.pt.handlePieceData(p)
 		} else {
 			downloading = append(downloading, c.downloading[idx])
@@ -411,8 +411,6 @@ func (c *PeerConn) metaInfoDownload() {
 			} else {
 				log.Debugf("metainfo len=%d", len(c.t.metaInfo))
 			}
-		} else {
-			log.Debugf("no metainfo size: %q", c.theirOpts)
 		}
 		id, ok := c.theirOpts.Extensions[extensions.UTMetaData.String()]
 		if ok {
@@ -633,7 +631,6 @@ func (c *PeerConn) sendLNPEX(connected, disconnected []common.Peer) {
 }
 
 func (c *PeerConn) handleExtendedOpts(opts extensions.Message) {
-	log.Debugf("got extended opts from %s: %q", c.id.String(), opts)
 	if opts.ID == 0 {
 		// handshake
 		c.theirOpts = opts.Copy()
@@ -749,7 +746,7 @@ func (c *PeerConn) tickDownload() {
 		}
 	} else if (c.usInterested || c.peerInterested) && !c.closing {
 		if c.RemoteChoking() {
-			log.Debugf("will not download this tick, %s is choking", c.id.String())
+			//log.Debugf("will not download this tick, %s is choking", c.id.String())
 			return
 		}
 		// pending request
diff --git a/src/xd/lib/bittorrent/swarm/piece.go b/src/xd/lib/bittorrent/swarm/piece.go
index 328882f..d796aa4 100644
--- a/src/xd/lib/bittorrent/swarm/piece.go
+++ b/src/xd/lib/bittorrent/swarm/piece.go
@@ -224,14 +224,14 @@ func (pt *pieceTracker) canceledRequest(r common.PieceRequest) {
 	})
 }
 
-func (pt *pieceTracker) handlePieceData(d common.PieceData) {
+func (pt *pieceTracker) handlePieceData(d *common.PieceData) {
 	idx := d.Index
 	pt.visitCached(idx, func(pc *cachedPiece) {
 		if !pc.accept(d.Begin, uint32(len(d.Data))) {
 			log.Errorf("invalid piece data: index=%d offset=%d length=%d", d.Index, d.Begin, len(d.Data))
 			return
 		}
-		err := pt.st.PutChunk(idx, d.Begin, d.Data)
+		err := pt.st.PutChunk(d)
 		if err == nil {
 			pc.put(d.Begin)
 		} else {
diff --git a/src/xd/lib/bittorrent/swarm/torrent.go b/src/xd/lib/bittorrent/swarm/torrent.go
index fdbd907..43c6ad7 100644
--- a/src/xd/lib/bittorrent/swarm/torrent.go
+++ b/src/xd/lib/bittorrent/swarm/torrent.go
@@ -832,7 +832,7 @@ func (t *Torrent) handlePieceRequest(c *PeerConn, r common.PieceRequest) {
 				c.Close()
 			}
 		} else {
-			log.Infof("%s asked for oversized piece bytes=%d", r.Length)
+			log.Infof("%s asked for oversized piece bytes=%d", c.id.String(), r.Length)
 			c.Close()
 		}
 	} else {
diff --git a/src/xd/lib/common/wire.go b/src/xd/lib/common/wire.go
index ecfc609..e33778f 100644
--- a/src/xd/lib/common/wire.go
+++ b/src/xd/lib/common/wire.go
@@ -185,7 +185,7 @@ func (req PieceRequest) ToWireMessage() WireMessage {
 }
 
 // VisitPieceData gets this wire message as a PieceData if applicable
-func (msg WireMessage) VisitPieceData(v func(PieceData)) {
+func (msg WireMessage) VisitPieceData(v func(*PieceData)) {
 
 	if msg.MessageID() == Piece {
 		data := msg.Payload()
@@ -194,7 +194,7 @@ func (msg WireMessage) VisitPieceData(v func(PieceData)) {
 			p.Index = binary.BigEndian.Uint32(data[:])
 			p.Begin = binary.BigEndian.Uint32(data[4:])
 			p.Data = data[8:]
-			v(p)
+			v(&p)
 		}
 	}
 	return
diff --git a/src/xd/lib/fs/fs.go b/src/xd/lib/fs/fs.go
index ff69b01..e17a7d5 100644
--- a/src/xd/lib/fs/fs.go
+++ b/src/xd/lib/fs/fs.go
@@ -2,6 +2,7 @@ package fs
 
 import (
 	"io"
+	"os"
 )
 
 type ReadFile interface {
@@ -12,6 +13,7 @@ type ReadFile interface {
 type WriteFile interface {
 	io.WriteCloser
 	io.WriterAt
+	Sync() error
 }
 
 type Driver interface {
@@ -40,4 +42,6 @@ type Driver interface {
 	Move(oldPath, newPath string) error
 	// split path into dirname, basename
 	Split(path string) (string, string)
+	// call stat()
+	Stat(path string) (os.FileInfo, error)
 }
diff --git a/src/xd/lib/fs/sftp.go b/src/xd/lib/fs/sftp.go
index 26f718e..79ee6d2 100644
--- a/src/xd/lib/fs/sftp.go
+++ b/src/xd/lib/fs/sftp.go
@@ -23,6 +23,10 @@ func (f *sftpFile) Write(data []byte) (int, error) {
 	return f.f.Write(data)
 }
 
+func (f *sftpFile) Sync() error {
+	return nil
+}
+
 func (f *sftpFile) Read(data []byte) (int, error) {
 	return f.f.Read(data)
 }
@@ -303,6 +307,14 @@ func (fs *sftpFS) Remove(fpath string) error {
 	})
 }
 
+func (fs *sftpFS) Stat(fpath string) (fi os.FileInfo, err error) {
+	err = fs.ensureConn(func(c *sftp.Client) error {
+		fi, err = c.Stat(fpath)
+		return err
+	})
+	return
+}
+
 func (fs *sftpFS) RemoveAll(fpath string) error {
 	return fs.ensureConn(func(c *sftp.Client) error {
 		st, err := c.Stat(fpath)
diff --git a/src/xd/lib/fs/std.go b/src/xd/lib/fs/std.go
index c1618a9..2e2c9f8 100644
--- a/src/xd/lib/fs/std.go
+++ b/src/xd/lib/fs/std.go
@@ -67,3 +67,7 @@ func (f stdFs) Split(path string) (base, file string) {
 	base, file = filepath.Split(path)
 	return
 }
+
+func (f stdFs) Stat(path string) (os.FileInfo, error) {
+	return os.Stat(path)
+}
diff --git a/src/xd/lib/metainfo/metainfo.go b/src/xd/lib/metainfo/metainfo.go
index 3e096ff..5ad082e 100644
--- a/src/xd/lib/metainfo/metainfo.go
+++ b/src/xd/lib/metainfo/metainfo.go
@@ -3,6 +3,7 @@ package metainfo
 import (
 	"bytes"
 	"crypto/sha1"
+	"encoding/hex"
 	"github.com/zeebo/bencode"
 	"io"
 	"path/filepath"
@@ -76,7 +77,11 @@ func (i Info) CheckPiece(p *common.PieceData) bool {
 	if i.NumPieces() > p.Index {
 		h := sha1.Sum(p.Data)
 		expected := i.Pieces[idx : idx+20]
-		return bytes.Equal(h[:], expected)
+		if bytes.Equal(h[:], expected) {
+			return true
+		}
+		log.Warnf("piece missmatch: %s != %s", hex.EncodeToString(h[:]), hex.EncodeToString(expected))
+		return false
 	}
 	log.Error("piece index out of bounds")
 	return false
diff --git a/src/xd/lib/mktorrent/mktorrent.go b/src/xd/lib/mktorrent/mktorrent.go
new file mode 100644
index 0000000..b6a58f7
--- /dev/null
+++ b/src/xd/lib/mktorrent/mktorrent.go
@@ -0,0 +1,56 @@
+package mktorrent
+
+import (
+	"crypto/sha1"
+	"errors"
+	"io"
+	"path/filepath"
+	"xd/lib/fs"
+	"xd/lib/metainfo"
+)
+
+func mkTorrentSingle(f fs.Driver, fpath string, pieceLength uint32) (*metainfo.TorrentFile, error) {
+	var info metainfo.Info
+
+	info.PieceLength = pieceLength
+	info.Path = filepath.Base(fpath)
+
+	r, err := f.OpenFileReadOnly(fpath)
+	if err != nil {
+		return nil, err
+	}
+	buff := make([]byte, info.PieceLength)
+	for {
+		n, err := io.ReadFull(r, buff)
+		if err == io.ErrUnexpectedEOF {
+			err = nil
+			d := sha1.Sum(buff[0:n])
+			info.Pieces = append(info.Pieces, d[:]...)
+			break
+		} else if err == nil {
+			d := sha1.Sum(buff)
+			info.Pieces = append(info.Pieces, d[:]...)
+		} else {
+			return nil, err
+		}
+	}
+
+	return &metainfo.TorrentFile{
+		Info: info,
+	}, nil
+}
+
+func mkTorrentDir(f fs.Driver, fpath string, pieceLength uint32) (*metainfo.TorrentFile, error) {
+	return nil, errors.New("not implemented")
+}
+
+func MakeTorrent(f fs.Driver, fpath string, pieceLength uint32) (*metainfo.TorrentFile, error) {
+	st, err := f.Stat(fpath)
+	if err != nil {
+		return nil, err
+	}
+	if st.IsDir() {
+		return mkTorrentDir(f, fpath, pieceLength)
+	}
+	return mkTorrentSingle(f, fpath, pieceLength)
+}
diff --git a/src/xd/lib/storage/fs.go b/src/xd/lib/storage/fs.go
index ad92604..fbe8e91 100644
--- a/src/xd/lib/storage/fs.go
+++ b/src/xd/lib/storage/fs.go
@@ -198,6 +198,7 @@ func (t *fsTorrent) WriteAt(p []byte, off int64) (n int, err error) {
 			return
 		}
 		n1, err = f.WriteAt(p[:n1], off)
+		f.Sync()
 		f.Close()
 		if err != nil {
 			return
@@ -378,7 +379,12 @@ func (t *fsTorrent) VerifyAll() (err error) {
 	return
 }
 
-func (t *fsTorrent) PutChunk(idx, offset uint32, data []byte) (err error) {
+func (t *fsTorrent) PutChunk(d *common.PieceData) (err error) {
+	err = t.putChunk(d.Index, d.Begin, d.Data)
+	return
+}
+
+func (t *fsTorrent) putChunk(idx, offset uint32, data []byte) (err error) {
 	if t.meta == nil {
 		err = ErrNoMetaInfo
 		return
@@ -386,6 +392,7 @@ func (t *fsTorrent) PutChunk(idx, offset uint32, data []byte) (err error) {
 	t.access.Lock()
 	sz := int64(t.meta.Info.PieceLength)
 	off := (sz * int64(idx)) + int64(offset)
+	log.Debugf("put chunk idx=%d off=%d globaloff=%d len=%d", idx, offset, off, len(data))
 	if t.st.pooledIO() {
 		iop := writeIOP{
 			data:      data,
diff --git a/src/xd/lib/storage/storage.go b/src/xd/lib/storage/storage.go
index fa8a6d7..2b1c51f 100644
--- a/src/xd/lib/storage/storage.go
+++ b/src/xd/lib/storage/storage.go
@@ -23,8 +23,8 @@ type Torrent interface {
 	// return true if we are currently doing a deep check
 	Checking() bool
 
-	// put a chunk of data at index and offset
-	PutChunk(idx, offset uint32, data []byte) error
+	// put a chunk of data 
+	PutChunk(pc *common.PieceData) error
 
 	// visit a piece from storage
 	GetPiece(r common.PieceRequest, pc *common.PieceData) error
diff --git a/src/xd/lib/storage/storage_test.go b/src/xd/lib/storage/storage_test.go
new file mode 100644
index 0000000..1f57421
--- /dev/null
+++ b/src/xd/lib/storage/storage_test.go
@@ -0,0 +1,86 @@
+package storage
+
+import (
+	"crypto/rand"
+	"io"
+	"testing"
+	"xd/lib/common"
+	"xd/lib/fs"
+	"xd/lib/metainfo"
+	"xd/lib/mktorrent"
+)
+
+const testPieceLen = 65536
+
+func createRandomTorrent(testFname string) (*metainfo.TorrentFile, error) {
+	f, err := fs.STD.OpenFileWriteOnly(testFname)
+	if err != nil {
+		return nil, err
+	}
+	_, err = io.CopyN(f, rand.Reader, (testPieceLen*8)+128)
+	f.Sync()
+	f.Close()
+
+	return mktorrent.MakeTorrent(fs.STD, testFname, testPieceLen)
+}
+
+func TestStorage(t *testing.T) {
+
+	st := &FsStorage{
+		MetaDir:    "storage",
+		DataDir:    "data",
+		SeedingDir: "seeding",
+		FS:         fs.STD,
+	}
+
+	err := st.Init()
+	if err != nil {
+		t.Log("failed to init storage")
+		t.Fail()
+		return
+	}
+	fname := st.FS.Join(st.DataDir, "test.bin")
+	meta, err := createRandomTorrent(fname)
+	if err != nil {
+		t.Logf("failed to make torrent: %s", err.Error())
+		t.Fail()
+		return
+	}
+
+	torrent, err := st.OpenTorrent(meta)
+	if err != nil {
+		t.Log("failed to open torrent")
+		t.Fail()
+		return
+	}
+	err = torrent.VerifyAll()
+	if err != nil {
+		t.Log("verify all failed")
+		t.Fail()
+		return
+	}
+	var pc common.PieceData
+	err = torrent.GetPiece(common.PieceRequest{
+		Index:  0,
+		Begin:  0,
+		Length: 16384,
+	}, &pc)
+
+	if err != nil {
+		t.Fail()
+		return
+	}
+
+	err = torrent.PutChunk(&pc)
+	if err != nil {
+		t.Fail()
+		return
+	}
+
+	err = torrent.VerifyPiece(0)
+	if err != nil {
+		t.Fail()
+		return
+	}
+
+}
diff --git a/vendor b/vendor
deleted file mode 120000
index e831038..0000000
--- a/vendor
+++ /dev/null
@@ -1 +0,0 @@
-src
\ No newline at end of file
