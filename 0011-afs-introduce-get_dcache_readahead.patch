From 61b3bebcb0cade613e92be738c726cd0fc264658 Mon Sep 17 00:00:00 2001
From: Cheyenne Wills <cwills@sinenomine.net>
Date: Wed, 1 Jun 2022 08:59:11 -0600
Subject: [PATCH 11/12] afs: introduce get_dcache_readahead

Relocate the block of code that obtains the dcache for a readahead
operation from the afs_linux_readpages function into its own static
function.

Change-Id: Iaaf9523532e292a1f2426d5ced65ddfbceb5d060
---
 src/afs/LINUX/osi_vnodeops.c | 111 +++++++++++++++++++++++------------
 1 file changed, 75 insertions(+), 36 deletions(-)

diff --git a/src/afs/LINUX/osi_vnodeops.c b/src/afs/LINUX/osi_vnodeops.c
index 9f164f395..893f8afff 100644
--- a/src/afs/LINUX/osi_vnodeops.c
+++ b/src/afs/LINUX/osi_vnodeops.c
@@ -2733,6 +2733,78 @@ afs_linux_readpage(struct file *fp, struct page *pp)
 
     return code;
 }
+/*
+ * Updates the tdc and cacheFp parameters
+ * Returns:
+ *    0 - success
+ *   -1 - problem getting inode or no mapping function
+ */
+static int
+get_dcache_readahead(struct dcache **adc, struct file **acacheFp,
+		     struct vcache *avc, loff_t offset)
+{
+    struct dcache *tdc = *adc;
+    struct file *cacheFp = *acacheFp;
+    int code = 0;
+
+    if (tdc != NULL && (tdc)->f.chunk != AFS_CHUNK(offset)) {
+	AFS_GLOCK();
+	ReleaseReadLock(&tdc->lock);
+	afs_PutDCache(tdc);
+	AFS_GUNLOCK();
+	tdc = NULL;
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+    }
+
+    if (tdc != NULL) {
+	AFS_GLOCK();
+	if ((tdc = afs_FindDCache(avc, offset))) {
+	    ObtainReadLock(&tdc->lock);
+	    if (!afs_IsDCacheFresh(tdc, avc) ||
+		((tdc)->dflags & DFFetching)) {
+		ReleaseReadLock(&tdc->lock);
+		afs_PutDCache(tdc);
+		tdc = NULL;
+	    }
+	}
+	AFS_GUNLOCK();
+	if (tdc != NULL) {
+	    cacheFp = afs_linux_raw_open(&tdc->f.inode);
+	    if (cacheFp == NULL) {
+		/* Problem getting the inode */
+		code = -1;
+		goto out;
+	    }
+	    if (!(cacheFp)->f_dentry->d_inode->i_mapping->a_ops->readpage) {
+		cachefs_noreadpage = 1;
+		/* No mapping function */
+		code = -1;
+		goto out;
+	    }
+	}
+    }
+
+ out:
+    if (code) {
+	if (cacheFp != NULL) {
+	    filp_close(cacheFp, NULL);
+	    cacheFp = NULL;
+	}
+	if (tdc != NULL) {
+	    AFS_GLOCK();
+	    ReleaseReadLock(&tdc->lock);
+	    afs_PutDCache(tdc);
+	    AFS_GUNLOCK();
+	    tdc = NULL;
+	}
+    }
+    *adc = tdc;
+    *acacheFp = cacheFp;
+    return code;
+}
 
 /* Readpages reads a number of pages for a particular file. We use
  * this to optimise the reading, by limiting the number of times upon which
@@ -2783,42 +2855,9 @@ afs_linux_readpages(struct file *fp, struct address_space *mapping,
 	list_del(&page->lru);
 	offset = page_offset(page);
 
-	if (tdc && tdc->f.chunk != AFS_CHUNK(offset)) {
-	    AFS_GLOCK();
-	    ReleaseReadLock(&tdc->lock);
-	    afs_PutDCache(tdc);
-	    AFS_GUNLOCK();
-	    tdc = NULL;
-	    if (cacheFp) {
-		filp_close(cacheFp, NULL);
-		cacheFp = NULL;
-	    }
-	}
-
-	if (!tdc) {
-	    AFS_GLOCK();
-	    if ((tdc = afs_FindDCache(avc, offset))) {
-		ObtainReadLock(&tdc->lock);
-		if (!afs_IsDCacheFresh(tdc, avc) ||
-		    (tdc->dflags & DFFetching)) {
-		    ReleaseReadLock(&tdc->lock);
-		    afs_PutDCache(tdc);
-		    tdc = NULL;
-		}
-	    }
-	    AFS_GUNLOCK();
-	    if (tdc) {
-		cacheFp = afs_linux_raw_open(&tdc->f.inode);
-		if (cacheFp == NULL) {
-		    /* Problem getting the inode */
-		    goto out;
-		}
-		if (!cacheFp->f_dentry->d_inode->i_mapping->a_ops->readpage) {
-		    cachefs_noreadpage = 1;
-		    goto out;
-		}
-	    }
-	}
+	code = get_dcache_readahead(&tdc, &cacheFp, avc, offset);
+	if (code)
+	    goto out;
 
 	if (tdc && !add_to_page_cache(page, mapping, page->index,
 				      GFP_KERNEL)) {
-- 
2.36.1

