diff --git a/contrib/librdns/resolver.c b/contrib/librdns/resolver.c
index d6ddea576..7fa61a391 100644
--- a/contrib/librdns/resolver.c
+++ b/contrib/librdns/resolver.c
@@ -402,6 +402,8 @@ rdns_process_timer (void *arg)
 		if (!renew) {
 			req->async->del_timer (req->async->data,
 					req->async_event);
+			req->async_event = NULL;
+			HASH_DEL (req->io->requests, req);
 		}
 
 		/* We have not scheduled timeout actually due to send error */
@@ -480,6 +482,7 @@ rdns_process_retransmit (int fd, void *arg)
 
 	resolver->async->del_write (resolver->async->data,
 			req->async_event);
+	req->async_event = NULL;
 
 	r = rdns_send_request (req, fd, false);
 
@@ -530,7 +533,7 @@ rdns_make_request_full (
 	const char *cur_name, *last_name = NULL;
 	struct rdns_compression_entry *comp = NULL;
 
-	if (!resolver->initialized) {
+	if (resolver == NULL || !resolver->initialized) {
 		return NULL;
 	}
 
diff --git a/contrib/librdns/util.c b/contrib/librdns/util.c
index 9ea8f5c43..b03128983 100644
--- a/contrib/librdns/util.c
+++ b/contrib/librdns/util.c
@@ -409,12 +409,16 @@ rdns_request_free (struct rdns_request *req)
 						req->async_event);
 				/* Remove from id hashes */
 				HASH_DEL (req->io->requests, req);
+				req->async_event = NULL;
 			}
 			else if (req->state == RDNS_REQUEST_WAIT_SEND) {
 				/* Remove retransmit event */
 				req->async->del_write (req->async->data,
 						req->async_event);
+				HASH_DEL (req->io->requests, req);
+				req->async_event = NULL;
 			}
+
 		}
 #ifdef TWEETNACL
 		if (req->curve_plugin_data != NULL) {
@@ -556,6 +560,7 @@ rdns_resolver_parse_resolv_conf_cb (struct rdns_resolver *resolver,
 {
 	FILE *in;
 	char buf[BUFSIZ];
+	char *p;
 
 	in = fopen (path, "r");
 
@@ -568,6 +573,13 @@ rdns_resolver_parse_resolv_conf_cb (struct rdns_resolver *resolver,
 			break;
 		}
 
+		/* Strip trailing spaces */
+		p = buf + strlen (buf) - 1;
+		while (p > buf &&
+				(*p == ' ' || *p == '\t' || *p == '\r' || *p == '\n')) {
+			*p-- = '\0';
+		}
+
 		if (!rdns_resolver_conf_process_line (resolver, buf, cb, ud)) {
 			rdns_warn ("rdns_resolver_parse_resolv_conf: cannot parse line: %s", buf);
 			fclose (in);
diff --git a/src/controller.c b/src/controller.c
index f1daba22c..b72f0ad4f 100644
--- a/src/controller.c
+++ b/src/controller.c
@@ -126,12 +126,15 @@ worker_t controller_worker = {
  */
 struct rspamd_controller_worker_ctx {
 	guint64 magic;
-	guint32 timeout;
-	struct timeval io_tv;
-	/* DNS resolver */
-	struct rspamd_dns_resolver *resolver;
 	/* Events base */
 	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
+	guint32 timeout;
+	struct timeval io_tv;
 	/* Whether we use ssl for this server */
 	gboolean use_ssl;
 	/* Webui password */
@@ -147,8 +150,6 @@ struct rspamd_controller_worker_ctx {
 	time_t start_time;
 	/* Main server */
 	struct rspamd_main *srv;
-	/* Configuration */
-	struct rspamd_config *cfg;
 	/* SSL cert */
 	gchar *ssl_cert;
 	/* SSL private key */
diff --git a/src/fuzzy_storage.c b/src/fuzzy_storage.c
index 99b98ceff..6ffecf093 100644
--- a/src/fuzzy_storage.c
+++ b/src/fuzzy_storage.c
@@ -124,6 +124,13 @@ static const guint64 rspamd_fuzzy_storage_magic = 0x291a3253eb1b3ea5ULL;
 
 struct rspamd_fuzzy_storage_ctx {
 	guint64 magic;
+	/* Events base */
+	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
 	struct fuzzy_global_stat stat;
 	char *hashfile;
 	gdouble expire;
@@ -139,7 +146,6 @@ struct rspamd_fuzzy_storage_ctx {
 	const ucl_object_t *masters_map;
 	GHashTable *master_flags;
 	guint keypair_cache_size;
-	struct event_base *ev_base;
 	gint peer_fd;
 	struct event peer_ev;
 	struct event stat_ev;
@@ -160,8 +166,6 @@ struct rspamd_fuzzy_storage_ctx {
 	guint updates_failed;
 	guint updates_maxfail;
 	guint32 collection_id;
-	struct rspamd_dns_resolver *resolver;
-	struct rspamd_config *cfg;
 	struct rspamd_worker *worker;
 	struct rspamd_http_connection_router *collection_rt;
 	guchar cookie[COOKIE_SIZE];
diff --git a/src/hs_helper.c b/src/hs_helper.c
index 208ebe4e4..0031f029d 100644
--- a/src/hs_helper.c
+++ b/src/hs_helper.c
@@ -46,13 +46,18 @@ static const guint64 rspamd_hs_helper_magic = 0x22d310157a2288a0ULL;
  */
 struct hs_helper_ctx {
 	guint64 magic;
+	/* Events base */
+	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
 	gchar *hs_dir;
 	gboolean loaded;
 	gdouble max_time;
 	gdouble recompile_time;
-	struct rspamd_config *cfg;
 	struct event recompile_timer;
-	struct event_base *ev_base;
 };
 
 static gpointer
diff --git a/src/libserver/dns.c b/src/libserver/dns.c
index 9aeb24306..d2629fd21 100644
--- a/src/libserver/dns.c
+++ b/src/libserver/dns.c
@@ -240,8 +240,9 @@ rspamd_dns_resolv_conf_on_server (struct rdns_resolver *resolver,
 {
 	struct rspamd_dns_resolver *dns_resolver = ud;
 
-	return rspamd_upstreams_add_upstream (dns_resolver->ups,
-		name, port, NULL);
+	return rspamd_upstreams_add_upstream (dns_resolver->ups, name, port,
+			RSPAMD_UPSTREAM_PARSE_NAMESERVER,
+			NULL);
 }
 
 struct rspamd_dns_resolver *
@@ -269,60 +270,56 @@ dns_resolver_init (rspamd_logger_t *logger,
 		rdns_resolver_set_log_level (dns_resolver->r, cfg->log_level);
 		dns_resolver->cfg = cfg;
 		rdns_resolver_set_dnssec (dns_resolver->r, cfg->enable_dnssec);
-	}
-
-	rdns_resolver_set_logger (dns_resolver->r, rspamd_rnds_log_bridge, logger);
 
-	if (cfg == NULL || cfg->nameservers == NULL) {
-		/* Parse resolv.conf */
-		dns_resolver->ups = rspamd_upstreams_create (cfg->ups_ctx);
-		rspamd_upstreams_set_flags (dns_resolver->ups,
-				RSPAMD_UPSTREAM_FLAG_NORESOLVE);
-		rspamd_upstreams_set_rotation (dns_resolver->ups,
-				RSPAMD_UPSTREAM_MASTER_SLAVE);
-
-		if (!rdns_resolver_parse_resolv_conf_cb (dns_resolver->r,
-				"/etc/resolv.conf",
-				rspamd_dns_resolv_conf_on_server,
-				dns_resolver)) {
-			msg_err ("cannot parse resolv.conf and no nameservers defined, "
-					"so no ways to resolve addresses");
-			rdns_resolver_release (dns_resolver->r);
-			dns_resolver->r = NULL;
-
-			return dns_resolver;
+		if (cfg->nameservers == NULL) {
+			/* Parse resolv.conf */
+			dns_resolver->ups = rspamd_upstreams_create (cfg->ups_ctx);
+			rspamd_upstreams_set_flags (dns_resolver->ups,
+					RSPAMD_UPSTREAM_FLAG_NORESOLVE);
+			rspamd_upstreams_set_rotation (dns_resolver->ups,
+					RSPAMD_UPSTREAM_MASTER_SLAVE);
+
+			if (!rdns_resolver_parse_resolv_conf_cb (dns_resolver->r,
+					"/etc/resolv.conf",
+					rspamd_dns_resolv_conf_on_server,
+					dns_resolver)) {
+				msg_err ("cannot parse resolv.conf and no nameservers defined, "
+						"so no ways to resolve addresses");
+				rdns_resolver_release (dns_resolver->r);
+				dns_resolver->r = NULL;
+
+				return dns_resolver;
+			}
+
+			/* Use normal resolv.conf rules */
+			rspamd_upstreams_foreach (dns_resolver->ups, rspamd_dns_server_reorder,
+					dns_resolver);
+		}
+		else {
+			dns_resolver->ups = rspamd_upstreams_create (cfg->ups_ctx);
+			rspamd_upstreams_set_flags (dns_resolver->ups,
+					RSPAMD_UPSTREAM_FLAG_NORESOLVE);
+
+			if (!rspamd_upstreams_from_ucl (dns_resolver->ups, cfg->nameservers,
+					53, dns_resolver)) {
+				msg_err_config ("cannot parse DNS nameservers definitions");
+				rdns_resolver_release (dns_resolver->r);
+				dns_resolver->r = NULL;
+
+				return dns_resolver;
+			}
 		}
 
-		/* Use normal resolv.conf rules */
-		rspamd_upstreams_foreach (dns_resolver->ups, rspamd_dns_server_reorder,
+		rspamd_upstreams_foreach (dns_resolver->ups, rspamd_dns_server_init,
 				dns_resolver);
-	}
-	else {
-		dns_resolver->ups = rspamd_upstreams_create (cfg->ups_ctx);
-		rspamd_upstreams_set_flags (dns_resolver->ups,
-				RSPAMD_UPSTREAM_FLAG_NORESOLVE);
-
-		if (!rspamd_upstreams_from_ucl (dns_resolver->ups, cfg->nameservers,
-				53, dns_resolver)) {
-			msg_err_config ("cannot parse DNS nameservers definitions");
-			rdns_resolver_release (dns_resolver->r);
-			dns_resolver->r = NULL;
-
-			return dns_resolver;
-		}
+		rdns_resolver_set_upstream_lib (dns_resolver->r, &rspamd_ups_ctx,
+				dns_resolver->ups);
+		cfg->dns_resolver = dns_resolver;
 	}
 
-	rspamd_upstreams_foreach (dns_resolver->ups, rspamd_dns_server_init,
-			dns_resolver);
-	rdns_resolver_set_upstream_lib (dns_resolver->r, &rspamd_ups_ctx,
-			dns_resolver->ups);
-
+	rdns_resolver_set_logger (dns_resolver->r, rspamd_rnds_log_bridge, logger);
 	rdns_resolver_init (dns_resolver->r);
 
-	if (cfg != NULL) {
-		cfg->dns_resolver = dns_resolver;
-	}
-
 	return dns_resolver;
 }
 
diff --git a/src/libutil/upstream.c b/src/libutil/upstream.c
index 907024579..ac15780ad 100644
--- a/src/libutil/upstream.c
+++ b/src/libutil/upstream.c
@@ -563,20 +563,50 @@ rspamd_upstream_name (struct upstream *up)
 }
 
 gboolean
-rspamd_upstreams_add_upstream (struct upstream_list *ups,
-		const gchar *str, guint16 def_port, void *data)
+rspamd_upstreams_add_upstream (struct upstream_list *ups, const gchar *str,
+		guint16 def_port, enum rspamd_upstream_parse_type parse_type,
+		void *data)
 {
 	struct upstream *up;
 	GPtrArray *addrs = NULL;
 	guint i;
 	rspamd_inet_addr_t *addr;
+	gboolean ret = FALSE;
 
 	up = g_slice_alloc0 (sizeof (*up));
 
-	if (!rspamd_parse_host_port_priority (str, &addrs,
-			&up->weight,
-			&up->name, def_port, ups->ctx->pool)) {
+	switch (parse_type) {
+	case RSPAMD_UPSTREAM_PARSE_DEFAULT:
+		ret = rspamd_parse_host_port_priority (str, &addrs,
+				&up->weight,
+				&up->name, def_port, ups->ctx->pool);
+		break;
+	case RSPAMD_UPSTREAM_PARSE_NAMESERVER:
+		addrs = g_ptr_array_sized_new (1);
+
+		ret = rspamd_parse_inet_address (&addr, str, strlen (str));
+
+		if (ret) {
+			if (rspamd_inet_address_get_port (addr) == 0) {
+				rspamd_inet_address_set_port (addr, def_port);
+			}
+
+			g_ptr_array_add (addrs, addr);
+			rspamd_mempool_add_destructor (ups->ctx->pool,
+					(rspamd_mempool_destruct_t)rspamd_inet_address_free,
+					addr);
+			rspamd_mempool_add_destructor (ups->ctx->pool,
+					(rspamd_mempool_destruct_t)rspamd_ptr_array_free_hard,
+					addrs);
+		}
+		else {
+			g_ptr_array_free (addrs, TRUE);
+		}
+
+		break;
+	}
 
+	if (!ret) {
 		g_slice_free1 (sizeof (*up), up);
 		return FALSE;
 	}
@@ -691,7 +721,9 @@ rspamd_upstreams_parse_line (struct upstream_list *ups,
 			tmp = g_malloc (len + 1);
 			rspamd_strlcpy (tmp, p, len + 1);
 
-			if (rspamd_upstreams_add_upstream (ups, tmp, def_port, data)) {
+			if (rspamd_upstreams_add_upstream (ups, tmp, def_port,
+					RSPAMD_UPSTREAM_PARSE_DEFAULT,
+					data)) {
 				ret = TRUE;
 			}
 
diff --git a/src/libutil/upstream.h b/src/libutil/upstream.h
index ddc480afe..84e75288d 100644
--- a/src/libutil/upstream.h
+++ b/src/libutil/upstream.h
@@ -110,6 +110,11 @@ gsize rspamd_upstreams_count (struct upstream_list *ups);
  */
 gsize rspamd_upstreams_alive (struct upstream_list *ups);
 
+enum rspamd_upstream_parse_type {
+	RSPAMD_UPSTREAM_PARSE_DEFAULT = 0,
+	RSPAMD_UPSTREAM_PARSE_NAMESERVER,
+};
+
 /**
  * Add upstream from the string
  * @param ups upstream list
@@ -118,8 +123,9 @@ gsize rspamd_upstreams_alive (struct upstream_list *ups);
  * @param data optional userdata
  * @return TRUE if upstream has been added
  */
-gboolean rspamd_upstreams_add_upstream (struct upstream_list *ups,
-		const gchar *str, guint16 def_port, void *data);
+gboolean rspamd_upstreams_add_upstream (struct upstream_list *ups, const gchar *str,
+		guint16 def_port, enum rspamd_upstream_parse_type parse_type,
+		void *data);
 
 /**
  * Add multiple upstreams from comma, semicolon or space separated line
diff --git a/src/log_helper.c b/src/log_helper.c
index ade8dd3a9..84e485045 100644
--- a/src/log_helper.c
+++ b/src/log_helper.c
@@ -48,11 +48,15 @@ static const guint64 rspamd_log_helper_magic = 0x1090bb46aaa74c9aULL;
  */
 struct log_helper_ctx {
 	guint64 magic;
-	struct rspamd_config *cfg;
+	/* Events base */
 	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
 	struct event log_ev;
 	struct rspamd_worker_lua_script *scripts;
-	struct rspamd_dns_resolver *resolver;
 	lua_State *L;
 	gint pair[2];
 };
diff --git a/src/lua/lua_tcp.c b/src/lua/lua_tcp.c
index c0938d684..1f7b2b05b 100644
--- a/src/lua/lua_tcp.c
+++ b/src/lua/lua_tcp.c
@@ -216,12 +216,17 @@ static void lua_tcp_plan_handler_event (struct lua_tcp_cbdata *cbd,
 static const int default_tcp_timeout = 5000;
 
 static struct rspamd_dns_resolver *
-lua_tcp_global_resolver (struct event_base *ev_base)
+lua_tcp_global_resolver (struct event_base *ev_base,
+		struct rspamd_config *cfg)
 {
 	static struct rspamd_dns_resolver *global_resolver;
 
+	if (cfg && cfg->dns_resolver) {
+		return cfg->dns_resolver;
+	}
+
 	if (global_resolver == NULL) {
-		global_resolver = dns_resolver_init (NULL, ev_base, NULL);
+		global_resolver = dns_resolver_init (NULL, ev_base, cfg);
 	}
 
 	return global_resolver;
@@ -923,6 +928,7 @@ lua_tcp_request (lua_State *L)
 	struct rspamd_dns_resolver *resolver;
 	struct rspamd_async_session *session;
 	struct rspamd_task *task = NULL;
+	struct rspamd_config *cfg;
 	struct iovec *iov = NULL;
 	guint niov = 0, total_out;
 	guint64 h;
@@ -980,23 +986,33 @@ lua_tcp_request (lua_State *L)
 			}
 			lua_pop (L, 1);
 
-			lua_pushstring (L, "resolver");
+			lua_pushstring (L, "session");
 			lua_gettable (L, -2);
-			if (rspamd_lua_check_udata_maybe (L, -1, "rspamd{resolver}")) {
-				resolver = *(struct rspamd_dns_resolver **)lua_touserdata (L, -1);
+			if (rspamd_lua_check_udata_maybe (L, -1, "rspamd{session}")) {
+				session = *(struct rspamd_async_session **)lua_touserdata (L, -1);
 			}
 			else {
-				resolver = lua_tcp_global_resolver (ev_base);
+				session = NULL;
 			}
 			lua_pop (L, 1);
 
-			lua_pushstring (L, "session");
+			lua_pushstring (L, "config");
 			lua_gettable (L, -2);
-			if (rspamd_lua_check_udata_maybe (L, -1, "rspamd{session}")) {
-				session = *(struct rspamd_async_session **)lua_touserdata (L, -1);
+			if (rspamd_lua_check_udata_maybe (L, -1, "rspamd{config}")) {
+				cfg = *(struct rspamd_config **)lua_touserdata (L, -1);
 			}
 			else {
-				session = NULL;
+				cfg = NULL;
+			}
+			lua_pop (L, 1);
+
+			lua_pushstring (L, "resolver");
+			lua_gettable (L, -2);
+			if (rspamd_lua_check_udata_maybe (L, -1, "rspamd{resolver}")) {
+				resolver = *(struct rspamd_dns_resolver **)lua_touserdata (L, -1);
+			}
+			else {
+				resolver = lua_tcp_global_resolver (ev_base, cfg);
 			}
 			lua_pop (L, 1);
 		}
diff --git a/src/lua_worker.c b/src/lua_worker.c
index 484f79722..ffd9df531 100644
--- a/src/lua_worker.c
+++ b/src/lua_worker.c
@@ -53,10 +53,13 @@ static const guint64 rspamd_lua_ctx_magic = 0x8055e2652aacf96eULL;
  */
 struct rspamd_lua_worker_ctx {
 	guint64 magic;
-	/* DNS resolver */
-	struct rspamd_dns_resolver *resolver;
 	/* Events base */
 	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
 	/* Other params */
 	GHashTable *params;
 	/* Lua script to load */
@@ -67,8 +70,6 @@ struct rspamd_lua_worker_ctx {
 	gint cbref_accept;
 	/* Callback for finishing */
 	gint cbref_fin;
-	/* Config file */
-	struct rspamd_config *cfg;
 	/* The rest options */
 	ucl_object_t *opts;
 };
diff --git a/src/plugins/lua/dmarc.lua b/src/plugins/lua/dmarc.lua
index 5afda58a3..04382c00b 100644
--- a/src/plugins/lua/dmarc.lua
+++ b/src/plugins/lua/dmarc.lua
@@ -884,6 +884,7 @@ if opts['reporting'] == true then
         rspamd_tcp.request({
           ev_base = ev_base,
           callback = mail_cb,
+          config = rspamd_config,
           stop_pattern = '\r\n',
           host = report_settings.smtp,
           port = report_settings.smtp_port,
diff --git a/src/plugins/lua/metric_exporter.lua b/src/plugins/lua/metric_exporter.lua
index c28e58560..4951e6594 100644
--- a/src/plugins/lua/metric_exporter.lua
+++ b/src/plugins/lua/metric_exporter.lua
@@ -123,6 +123,7 @@ local function graphite_push(kwargs)
 
   tcp.request({
     ev_base = kwargs['ev_base'],
+    config = rspamd_config,
     pool = pool,
     host = settings['host'],
     port = settings['port'],
diff --git a/src/plugins/surbl.c b/src/plugins/surbl.c
index 78422461a..486b48388 100644
--- a/src/plugins/surbl.c
+++ b/src/plugins/surbl.c
@@ -768,7 +768,8 @@ surbl_module_config (struct rspamd_config *cfg)
 		{
 			redir_val = ucl_obj_tostring (cur);
 			if (rspamd_upstreams_add_upstream (surbl_module_ctx->redirectors,
-					redir_val, 80, NULL)) {
+					redir_val, 80, RSPAMD_UPSTREAM_PARSE_DEFAULT,
+					NULL)) {
 				surbl_module_ctx->use_redirector = TRUE;
 			}
 		}
diff --git a/src/rspamd.h b/src/rspamd.h
index a9638ebe2..a716c3788 100644
--- a/src/rspamd.h
+++ b/src/rspamd.h
@@ -78,6 +78,12 @@ struct rspamd_worker {
 
 struct rspamd_abstract_worker_ctx {
 	guint64 magic;
+	/* Events base */
+	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
 	char data[];
 };
 
diff --git a/src/rspamd_proxy.c b/src/rspamd_proxy.c
index fdad35f2d..f96e008b7 100644
--- a/src/rspamd_proxy.c
+++ b/src/rspamd_proxy.c
@@ -99,13 +99,15 @@ static const guint64 rspamd_rspamd_proxy_magic = 0xcdeb4fd1fc351980ULL;
 
 struct rspamd_proxy_ctx {
 	guint64 magic;
-	gdouble timeout;
-	struct timeval io_tv;
-	struct rspamd_config *cfg;
-	/* DNS resolver */
-	struct rspamd_dns_resolver *resolver;
 	/* Events base */
 	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+	/* END OF COMMON PART */
+	gdouble timeout;
+	struct timeval io_tv;
 	/* Encryption key for clients */
 	struct rspamd_cryptobox_keypair *key;
 	/* Keys cache */
diff --git a/src/worker.c b/src/worker.c
index 80bf13d80..49336e22d 100644
--- a/src/worker.c
+++ b/src/worker.c
@@ -96,7 +96,7 @@ rspamd_worker_call_finish_handlers (struct rspamd_worker *worker)
 {
 	struct rspamd_task *task;
 	struct rspamd_config *cfg = worker->srv->cfg;
-	struct rspamd_worker_ctx *ctx;
+	struct rspamd_abstract_worker_ctx *ctx;
 	struct rspamd_config_post_load_script *sc;
 
 	if (cfg->finish_callbacks) {
diff --git a/src/worker_private.h b/src/worker_private.h
index b9a9e57d6..d3339ea26 100644
--- a/src/worker_private.h
+++ b/src/worker_private.h
@@ -27,6 +27,13 @@ static const guint64 rspamd_worker_magic = 0xb48abc69d601dc1dULL;
 
 struct rspamd_worker_ctx {
 	guint64 magic;
+	/* Events base */
+	struct event_base *ev_base;
+	/* DNS resolver */
+	struct rspamd_dns_resolver *resolver;
+	/* Config */
+	struct rspamd_config *cfg;
+
 	guint32 timeout;
 	struct timeval io_tv;
 	/* Detect whether this worker is mime worker    */
@@ -37,20 +44,14 @@ struct rspamd_worker_ctx {
 	gboolean is_json;
 	/* Allow learning throught worker				*/
 	gboolean allow_learn;
-	/* DNS resolver */
-	struct rspamd_dns_resolver *resolver;
 	/* Limit of tasks */
 	guint32 max_tasks;
 	/* Maximum time for task processing */
 	gdouble task_timeout;
-	/* Events base */
-	struct event_base *ev_base;
 	/* Encryption key */
 	struct rspamd_cryptobox_keypair *key;
 	/* Keys cache */
 	struct rspamd_keypair_cache *keys_cache;
-	/* Configuration */
-	struct rspamd_config *cfg;
 };
 
 /*
diff --git a/test/rspamd_upstream_test.c b/test/rspamd_upstream_test.c
index 072a2a473..47094398f 100644
--- a/test/rspamd_upstream_test.c
+++ b/test/rspamd_upstream_test.c
@@ -78,7 +78,9 @@ rspamd_upstream_test_func (void)
 	 * Test v4/v6 priorities
 	 */
 	nls = rspamd_upstreams_create (cfg->ups_ctx);
-	g_assert (rspamd_upstreams_add_upstream (nls, "127.0.0.1", 0, NULL));
+	g_assert (rspamd_upstreams_add_upstream (nls, "127.0.0.1", 0,
+			RSPAMD_UPSTREAM_PARSE_DEFAULT,
+			NULL));
 	up = rspamd_upstream_get (nls, RSPAMD_UPSTREAM_RANDOM, NULL, 0);
 	rspamd_parse_inet_address (&paddr, "127.0.0.2", 0);
 	g_assert (rspamd_upstream_add_addr (up, paddr));
diff --git a/utils/cgp_rspamd.pl b/utils/cgp_rspamd.pl
index 68abc9342..8ef2a7cf4 100644
--- a/utils/cgp_rspamd.pl
+++ b/utils/cgp_rspamd.pl
@@ -64,7 +64,7 @@ sub rspamd_scan {
         print "$tag FAILURE\n";
       }
       else {
-        my $def     = $js->{'default'};
+        my $def     = $js;
         my $headers = "";
 
         if ( !$def ) {
