From 0bbc15f0d57b4bcbd389776b3bee492a75fd60a5 Mon Sep 17 00:00:00 2001
From: Maksim Sisov <msisov@igalia.com>
Date: Fri, 6 Dec 2019 20:31:04 +0000
Subject: [PATCH 5/9] ozone/Wayland: extract toplevel surface methods into
 WaylandSurface.

WaylandWindow handles too many things and confuses developers that
are not familiar with it. To make things better, extract
surface methods into WaylandSurface.

This change does not bring any functional changes except removed
is_active() method that was only used by tests. Instead, tests
just rely on the PlatformWindowDelegate::OnActivationChanged calls.

Test: ozone_unittests
Bug: 1028919
Change-Id: Ia58577f86d8e31ec93b113d887b34166fbe19cf0
Reviewed-on: https://chromium-review.googlesource.com/c/chromium/src/+/1954478
Commit-Queue: Maksim Sisov <msisov@igalia.com>
Reviewed-by: Michael Spang <spang@chromium.org>
Cr-Commit-Position: refs/heads/master@{#722592}
---
 ui/ozone/platform/wayland/BUILD.gn            |   2 +
 .../platform/wayland/host/wayland_surface.cc  | 348 ++++++++++++++++++
 .../platform/wayland/host/wayland_surface.h   | 114 ++++++
 .../platform/wayland/host/wayland_window.cc   | 346 ++---------------
 .../platform/wayland/host/wayland_window.h    | 110 ++----
 .../wayland/host/wayland_window_factory.cc    |  31 +-
 .../wayland/host/wayland_window_unittest.cc   |  14 +-
 .../wayland/host/xdg_popup_wrapper_impl.cc    |   9 +-
 8 files changed, 572 insertions(+), 402 deletions(-)
 create mode 100644 ui/ozone/platform/wayland/host/wayland_surface.cc
 create mode 100644 ui/ozone/platform/wayland/host/wayland_surface.h

diff --git a/ui/ozone/platform/wayland/BUILD.gn b/ui/ozone/platform/wayland/BUILD.gn
index a9c0302f162f..b6059c7d9962 100644
--- a/ui/ozone/platform/wayland/BUILD.gn
+++ b/ui/ozone/platform/wayland/BUILD.gn
@@ -91,6 +91,8 @@ source_set("wayland") {
     "host/wayland_shm.h",
     "host/wayland_shm_buffer.cc",
     "host/wayland_shm_buffer.h",
+    "host/wayland_surface.cc",
+    "host/wayland_surface.h",
     "host/wayland_touch.cc",
     "host/wayland_touch.h",
     "host/wayland_window.cc",
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.cc b/ui/ozone/platform/wayland/host/wayland_surface.cc
new file mode 100644
index 000000000000..cfd4349db885
--- /dev/null
+++ b/ui/ozone/platform/wayland/host/wayland_surface.cc
@@ -0,0 +1,348 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/wayland/host/wayland_surface.h"
+
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/hit_test.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/ozone/platform/wayland/host/shell_object_factory.h"
+#include "ui/ozone/platform/wayland/host/shell_surface_wrapper.h"
+#include "ui/ozone/platform/wayland/host/wayland_connection.h"
+#include "ui/platform_window/platform_window_handler/wm_drop_handler.h"
+
+namespace ui {
+
+WaylandSurface::WaylandSurface(PlatformWindowDelegate* delegate,
+                               WaylandConnection* connection)
+    : WaylandWindow(delegate, connection),
+      state_(PlatformWindowState::kNormal),
+      pending_state_(PlatformWindowState::kUnknown) {
+  // Set a class property key, which allows |this| to be used for interactive
+  // events, e.g. move or resize.
+  SetWmMoveResizeHandler(this, AsWmMoveResizeHandler());
+
+  // Set a class property key, which allows |this| to be used for drag action.
+  SetWmDragHandler(this, this);
+}
+
+WaylandSurface::~WaylandSurface() {
+  if (drag_closed_callback_) {
+    std::move(drag_closed_callback_)
+        .Run(DragDropTypes::DragOperation::DRAG_NONE);
+  }
+}
+
+void WaylandSurface::CreateShellSurface() {
+  ShellObjectFactory factory;
+  shell_surface_ = factory.CreateShellSurfaceWrapper(connection(), this);
+  if (!shell_surface_)
+    CHECK(false) << "Failed to initialize Wayland shell surface";
+}
+
+void WaylandSurface::ApplyPendingBounds() {
+  if (pending_bounds_dip_.IsEmpty())
+    return;
+  DCHECK(shell_surface_);
+
+  SetBoundsDip(pending_bounds_dip_);
+  shell_surface_->SetWindowGeometry(pending_bounds_dip_);
+  pending_bounds_dip_ = gfx::Rect();
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::DispatchHostWindowDragMovement(
+    int hittest,
+    const gfx::Point& pointer_location_in_px) {
+  DCHECK(shell_surface_);
+
+  connection()->ResetPointerFlags();
+  if (hittest == HTCAPTION)
+    shell_surface_->SurfaceMove(connection());
+  else
+    shell_surface_->SurfaceResize(connection(), hittest);
+
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::StartDrag(const ui::OSExchangeData& data,
+                               int operation,
+                               gfx::NativeCursor cursor,
+                               base::OnceCallback<void(int)> callback) {
+  DCHECK(!drag_closed_callback_);
+  drag_closed_callback_ = std::move(callback);
+  connection()->StartDrag(data, operation);
+}
+
+void WaylandSurface::Show(bool inactive) {
+  set_keyboard_focus(true);
+  // TODO(msisov): recreate |shell_surface_| on show calls.
+}
+
+void WaylandSurface::Hide() {
+  // TODO(msisov): destroy |shell_surface_| on hide calls.
+}
+
+bool WaylandSurface::IsVisible() const {
+  // X and Windows return true if the window is minimized. For consistency, do
+  // the same.
+  return !!shell_surface_ || IsMinimized();
+}
+
+void WaylandSurface::SetTitle(const base::string16& title) {
+  DCHECK(shell_surface_);
+  shell_surface_->SetTitle(title);
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::ToggleFullscreen() {
+  DCHECK(shell_surface_);
+
+  // There are some cases, when Chromium triggers a fullscreen state change
+  // before the surface is activated. In such cases, Wayland may ignore state
+  // changes and such flags as --kiosk or --start-fullscreen will be ignored.
+  // To overcome this, set a pending state, and once the surface is activated,
+  // trigger the change.
+  if (!is_active_) {
+    DCHECK(!IsFullscreen());
+    pending_state_ = PlatformWindowState::kFullScreen;
+    return;
+  }
+
+  // TODO(msisov, tonikitoo): add multiscreen support. As the documentation says
+  // if shell_surface_set_fullscreen() is not provided with wl_output, it's up
+  // to the compositor to choose which display will be used to map this surface.
+  if (!IsFullscreen()) {
+    // Fullscreen state changes have to be handled manually and then checked
+    // against configuration events, which come from a compositor. The reason
+    // of manually changing the |state_| is that the compositor answers about
+    // state changes asynchronously, which leads to a wrong return value in
+    // DesktopWindowTreeHostPlatform::IsFullscreen, for example, and media
+    // files can never be set to fullscreen.
+    state_ = PlatformWindowState::kFullScreen;
+    shell_surface_->SetFullscreen();
+  } else {
+    // Check the comment above. If it's not handled synchronously, media files
+    // may not leave the fullscreen mode.
+    state_ = PlatformWindowState::kUnknown;
+    shell_surface_->UnSetFullscreen();
+  }
+
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::Maximize() {
+  DCHECK(shell_surface_);
+
+  if (IsFullscreen())
+    ToggleFullscreen();
+
+  shell_surface_->SetMaximized();
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::Minimize() {
+  DCHECK(shell_surface_);
+  DCHECK(!is_minimizing_);
+  // Wayland doesn't explicitly say if a window is minimized. Instead, it
+  // notifies that the window is not activated. But there are many cases, when
+  // the window is not minimized and deactivated. In order to properly record
+  // the minimized state, mark this window as being minimized. And as soon as a
+  // configuration event comes, check if the window has been deactivated and has
+  // |is_minimizing_| set.
+  is_minimizing_ = true;
+  shell_surface_->SetMinimized();
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::Restore() {
+  DCHECK(shell_surface_);
+
+  // Unfullscreen the window if it is fullscreen.
+  if (IsFullscreen())
+    ToggleFullscreen();
+
+  shell_surface_->UnSetMaximized();
+  connection()->ScheduleFlush();
+}
+
+PlatformWindowState WaylandSurface::GetPlatformWindowState() const {
+  return state_;
+}
+
+void WaylandSurface::SizeConstraintsChanged() {
+  // Size constraints only make sense for normal windows.
+  if (!shell_surface_)
+    return;
+
+  DCHECK(delegate());
+  auto min_size = delegate()->GetMinimumSizeForWindow();
+  auto max_size = delegate()->GetMaximumSizeForWindow();
+
+  if (min_size.has_value())
+    shell_surface_->SetMinSize(min_size->width(), min_size->height());
+  if (max_size.has_value())
+    shell_surface_->SetMaxSize(max_size->width(), max_size->height());
+
+  connection()->ScheduleFlush();
+}
+
+void WaylandSurface::HandleSurfaceConfigure(int32_t width,
+                                            int32_t height,
+                                            bool is_maximized,
+                                            bool is_fullscreen,
+                                            bool is_activated) {
+  // Propagate the window state information to the client.
+  PlatformWindowState old_state = state_;
+
+  // Ensure that manually handled state changes to fullscreen correspond to the
+  // configuration events from a compositor.
+  DCHECK_EQ(is_fullscreen, IsFullscreen());
+
+  // There are two cases, which must be handled for the minimized state.
+  // The first one is the case, when the surface goes into the minimized state
+  // (check comment in WaylandSurface::Minimize), and the second case is when
+  // the surface still has been minimized, but another configuration event with
+  // !is_activated comes. For this, check if the WaylandSurface has been
+  // minimized before and !is_activated is sent.
+  if ((is_minimizing_ || IsMinimized()) && !is_activated) {
+    is_minimizing_ = false;
+    state_ = PlatformWindowState::kMinimized;
+  } else if (is_fullscreen) {
+    // To ensure the |delegate()| is notified about state changes to fullscreen,
+    // assume the old_state is UNKNOWN (check comment in ToggleFullscreen).
+    old_state = PlatformWindowState::kUnknown;
+    DCHECK(state_ == PlatformWindowState::kFullScreen);
+  } else if (is_maximized) {
+    state_ = PlatformWindowState::kMaximized;
+  } else {
+    state_ = PlatformWindowState::kNormal;
+  }
+  const bool state_changed = old_state != state_;
+  const bool is_normal = !IsFullscreen() && !IsMaximized();
+
+  // Update state before notifying delegate.
+  const bool did_active_change = is_active_ != is_activated;
+  is_active_ = is_activated;
+
+  // Rather than call SetBounds here for every configure event, just save the
+  // most recent bounds, and have WaylandConnection call ApplyPendingBounds
+  // when it has finished processing events. We may get many configure events
+  // in a row during an interactive resize, and only the last one matters.
+  //
+  // Width or height set to 0 means that we should decide on width and height by
+  // ourselves, but we don't want to set them to anything else. Use restored
+  // bounds size or the current bounds iff the current state is normal (neither
+  // maximized nor fullscreen).
+  //
+  // Note: if the browser was started with --start-fullscreen and a user exits
+  // the fullscreen mode, wayland may set the width and height to be 1. Instead,
+  // explicitly set the bounds to the current desired ones or the previous
+  // bounds.
+  if (width > 1 && height > 1) {
+    pending_bounds_dip_ = gfx::Rect(0, 0, width, height);
+  } else if (is_normal) {
+    pending_bounds_dip_.set_size(
+        gfx::ScaleToRoundedSize(GetRestoredBoundsInPixels().IsEmpty()
+                                    ? GetBounds().size()
+                                    : GetRestoredBoundsInPixels().size(),
+
+                                1.0 / buffer_scale()));
+  }
+
+  if (state_changed) {
+    // The |restored_bounds_| are used when the window gets back to normal
+    // state after it went maximized or fullscreen.  So we reset these if the
+    // window has just become normal and store the current bounds if it is
+    // either going out of normal state or simply changes the state and we don't
+    // have any meaningful value stored.
+    if (is_normal) {
+      SetRestoredBoundsInPixels({});
+    } else if (old_state == PlatformWindowState::kNormal ||
+               GetRestoredBoundsInPixels().IsEmpty()) {
+      SetRestoredBoundsInPixels(GetBounds());
+    }
+
+    delegate()->OnWindowStateChanged(state_);
+  }
+
+  ApplyPendingBounds();
+
+  if (did_active_change)
+    delegate()->OnActivationChanged(is_active_);
+
+  MaybeTriggerPendingStateChange();
+}
+
+void WaylandSurface::OnDragEnter(const gfx::PointF& point,
+                                 std::unique_ptr<OSExchangeData> data,
+                                 int operation) {
+  WmDropHandler* drop_handler = GetWmDropHandler(*this);
+  if (!drop_handler)
+    return;
+  drop_handler->OnDragEnter(point, std::move(data), operation);
+}
+
+int WaylandSurface::OnDragMotion(const gfx::PointF& point,
+                                 uint32_t time,
+                                 int operation) {
+  WmDropHandler* drop_handler = GetWmDropHandler(*this);
+  if (!drop_handler)
+    return 0;
+
+  return drop_handler->OnDragMotion(point, operation);
+}
+
+void WaylandSurface::OnDragDrop(std::unique_ptr<OSExchangeData> data) {
+  WmDropHandler* drop_handler = GetWmDropHandler(*this);
+  if (!drop_handler)
+    return;
+  drop_handler->OnDragDrop(std::move(data));
+}
+
+void WaylandSurface::OnDragLeave() {
+  WmDropHandler* drop_handler = GetWmDropHandler(*this);
+  if (!drop_handler)
+    return;
+  drop_handler->OnDragLeave();
+}
+
+void WaylandSurface::OnDragSessionClose(uint32_t dnd_action) {
+  std::move(drag_closed_callback_).Run(dnd_action);
+  connection()->ResetPointerFlags();
+}
+
+bool WaylandSurface::OnInitialize(PlatformWindowInitProperties properties) {
+  CreateShellSurface();
+  if (shell_surface_ && !properties.wm_class_class.empty())
+    shell_surface_->SetAppId(properties.wm_class_class);
+  return !!shell_surface_;
+}
+
+bool WaylandSurface::IsMinimized() const {
+  return state_ == PlatformWindowState::kMinimized;
+}
+
+bool WaylandSurface::IsMaximized() const {
+  return state_ == PlatformWindowState::kMaximized;
+}
+
+bool WaylandSurface::IsFullscreen() const {
+  return state_ == PlatformWindowState::kFullScreen;
+}
+
+void WaylandSurface::MaybeTriggerPendingStateChange() {
+  if (pending_state_ == PlatformWindowState::kUnknown || !is_active_)
+    return;
+  DCHECK_EQ(pending_state_, PlatformWindowState::kFullScreen);
+  pending_state_ = PlatformWindowState::kUnknown;
+  ToggleFullscreen();
+}
+
+WmMoveResizeHandler* WaylandSurface::AsWmMoveResizeHandler() {
+  return static_cast<WmMoveResizeHandler*>(this);
+}
+
+}  // namespace ui
diff --git a/ui/ozone/platform/wayland/host/wayland_surface.h b/ui/ozone/platform/wayland/host/wayland_surface.h
new file mode 100644
index 000000000000..0f7204db3c48
--- /dev/null
+++ b/ui/ozone/platform/wayland/host/wayland_surface.h
@@ -0,0 +1,114 @@
+// Copyright 2019 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_WAYLAND_HOST_WAYLAND_SURFACE_H_
+#define UI_OZONE_PLATFORM_WAYLAND_HOST_WAYLAND_SURFACE_H_
+
+#include "ui/ozone/platform/wayland/host/wayland_window.h"
+
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
+#include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
+
+namespace ui {
+
+class ShellSurfaceWrapper;
+
+class WaylandSurface : public WaylandWindow,
+                       public WmMoveResizeHandler,
+                       public WmDragHandler {
+ public:
+  WaylandSurface(PlatformWindowDelegate* delegate,
+                 WaylandConnection* connection);
+  ~WaylandSurface() override;
+
+  ShellSurfaceWrapper* shell_surface() const { return shell_surface_.get(); }
+
+  // Apply the bounds specified in the most recent configure event. This should
+  // be called after processing all pending events in the wayland connection.
+  void ApplyPendingBounds();
+
+  // WmMoveResizeHandler
+  void DispatchHostWindowDragMovement(
+      int hittest,
+      const gfx::Point& pointer_location_in_px) override;
+
+  // WmDragHandler
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
+  // PlatformWindow
+  void Show(bool inactive) override;
+  void Hide() override;
+  bool IsVisible() const override;
+  void SetTitle(const base::string16& title) override;
+  void ToggleFullscreen() override;
+  void Maximize() override;
+  void Minimize() override;
+  void Restore() override;
+  PlatformWindowState GetPlatformWindowState() const override;
+  void SizeConstraintsChanged() override;
+
+ private:
+  // WaylandWindow overrides:
+  void HandleSurfaceConfigure(int32_t widht,
+                              int32_t height,
+                              bool is_maximized,
+                              bool is_fullscreen,
+                              bool is_activated) override;
+  void OnDragEnter(const gfx::PointF& point,
+                   std::unique_ptr<OSExchangeData> data,
+                   int operation) override;
+  int OnDragMotion(const gfx::PointF& point,
+                   uint32_t time,
+                   int operation) override;
+  void OnDragDrop(std::unique_ptr<OSExchangeData> data) override;
+  void OnDragLeave() override;
+  void OnDragSessionClose(uint32_t dnd_action) override;
+  bool OnInitialize(PlatformWindowInitProperties properties) override;
+
+  bool IsMinimized() const;
+  bool IsMaximized() const;
+  bool IsFullscreen() const;
+
+  void MaybeTriggerPendingStateChange();
+
+  // Creates a surface window, which is visible as a main window.
+  void CreateShellSurface();
+
+  WmMoveResizeHandler* AsWmMoveResizeHandler();
+
+  // Wrappers around shell surface.
+  std::unique_ptr<ShellSurfaceWrapper> shell_surface_;
+
+  base::OnceCallback<void(int)> drag_closed_callback_;
+
+  // These bounds attributes below have suffices that indicate units used.
+  // Wayland operates in DIP but the platform operates in physical pixels so
+  // our WaylandSurface is the link that has to translate the units.  See also
+  // comments in the implementation.
+  //
+  // Bounds that will be applied when the window state is finalized.  The window
+  // may get several configuration events that update the pending bounds, and
+  // only upon finalizing the state is the latest value stored as the current
+  // bounds via |ApplyPendingBounds|.  Measured in DIP because updated in the
+  // handler that receives DIP from Wayland.
+  gfx::Rect pending_bounds_dip_;
+
+  // Stores current states of the window.
+  PlatformWindowState state_;
+  // Stores a pending state of the window, which is used before the surface is
+  // activated.
+  PlatformWindowState pending_state_;
+
+  bool is_active_ = false;
+  bool is_minimizing_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(WaylandSurface);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_WAYLAND_HOST_WAYLAND_SURFACE_H_
diff --git a/ui/ozone/platform/wayland/host/wayland_window.cc b/ui/ozone/platform/wayland/host/wayland_window.cc
index 1f8cc423d4aa..cdc95f904347 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window.cc
@@ -9,9 +9,6 @@
 
 #include "base/bind.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
-#include "ui/base/dragdrop/drag_drop_types.h"
-#include "ui/base/dragdrop/os_exchange_data.h"
-#include "ui/base/hit_test.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/ozone/events_ozone.h"
@@ -19,36 +16,19 @@
 #include "ui/ozone/platform/wayland/common/wayland_util.h"
 #include "ui/ozone/platform/wayland/host/shell_object_factory.h"
 #include "ui/ozone/platform/wayland/host/shell_popup_wrapper.h"
-#include "ui/ozone/platform/wayland/host/shell_surface_wrapper.h"
 #include "ui/ozone/platform/wayland/host/wayland_buffer_manager_host.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 #include "ui/ozone/platform/wayland/host/wayland_cursor_position.h"
 #include "ui/ozone/platform/wayland/host/wayland_output_manager.h"
 #include "ui/ozone/platform/wayland/host/wayland_pointer.h"
-#include "ui/platform_window/platform_window_handler/wm_drop_handler.h"
 
 namespace ui {
 
 WaylandWindow::WaylandWindow(PlatformWindowDelegate* delegate,
                              WaylandConnection* connection)
-    : delegate_(delegate),
-      connection_(connection),
-      state_(PlatformWindowState::kNormal),
-      pending_state_(PlatformWindowState::kUnknown) {
-  // Set a class property key, which allows |this| to be used for interactive
-  // events, e.g. move or resize.
-  SetWmMoveResizeHandler(this, AsWmMoveResizeHandler());
-
-  // Set a class property key, which allows |this| to be used for drag action.
-  SetWmDragHandler(this, this);
-}
+    : delegate_(delegate), connection_(connection) {}
 
 WaylandWindow::~WaylandWindow() {
-  if (drag_closed_callback_) {
-    std::move(drag_closed_callback_)
-        .Run(DragDropTypes::DragOperation::DRAG_NONE);
-  }
-
   PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
   if (surface_)
     connection_->wayland_window_manager()->RemoveWindow(GetWidget());
@@ -127,13 +107,6 @@ void WaylandWindow::CreateShellPopup() {
   parent_window_->set_child_window(this);
 }
 
-void WaylandWindow::CreateShellSurface() {
-  ShellObjectFactory factory;
-  shell_surface_ = factory.CreateShellSurfaceWrapper(connection_, this);
-  if (!shell_surface_)
-    CHECK(false) << "Failed to initialize Wayland shell surface";
-}
-
 void WaylandWindow::CreateAndShowTooltipSubSurface() {
   // Since Aura does not not provide a reference parent window, needed by
   // Wayland, we get the current focused window to place and show the tooltips.
@@ -172,21 +145,6 @@ void WaylandWindow::CreateAndShowTooltipSubSurface() {
   connection_->ScheduleFlush();
 }
 
-void WaylandWindow::ApplyPendingBounds() {
-  if (pending_bounds_dip_.IsEmpty())
-    return;
-  DCHECK(shell_surface_);
-
-  SetBoundsDip(pending_bounds_dip_);
-  shell_surface_->SetWindowGeometry(pending_bounds_dip_);
-  pending_bounds_dip_ = gfx::Rect();
-  connection_->ScheduleFlush();
-
-  // Opaque region is based on the size of the window. Thus, update the region
-  // on each update.
-  MaybeUpdateOpaqueRegion();
-}
-
 void WaylandWindow::SetPointerFocus(bool focus) {
   has_pointer_focus_ = focus;
 
@@ -197,36 +155,10 @@ void WaylandWindow::SetPointerFocus(bool focus) {
     connection_->SetCursorBitmap(bitmap_->bitmaps(), bitmap_->hotspot());
 }
 
-void WaylandWindow::DispatchHostWindowDragMovement(
-    int hittest,
-    const gfx::Point& pointer_location_in_px) {
-  DCHECK(shell_surface_);
-
-  connection_->ResetPointerFlags();
-  if (hittest == HTCAPTION)
-    shell_surface_->SurfaceMove(connection_);
-  else
-    shell_surface_->SurfaceResize(connection_, hittest);
-
-  connection_->ScheduleFlush();
-}
-
-void WaylandWindow::StartDrag(const ui::OSExchangeData& data,
-                              int operation,
-                              gfx::NativeCursor cursor,
-                              base::OnceCallback<void(int)> callback) {
-  DCHECK(!drag_closed_callback_);
-  drag_closed_callback_ = std::move(callback);
-  connection_->StartDrag(data, operation);
-}
-
 void WaylandWindow::Show(bool inactive) {
   if (!is_tooltip_)  // Tooltip windows should not get keyboard focus
     set_keyboard_focus(true);
 
-  if (shell_surface_)
-    return;
-
   if (is_tooltip_) {
     CreateAndShowTooltipSubSurface();
     return;
@@ -260,8 +192,7 @@ void WaylandWindow::Hide() {
 
   // Detach buffer from surface in order to completely shutdown popups and
   // tooltips, and release resources.
-  if (!shell_surface())
-    connection_->buffer_manager_host()->ResetSurfaceContents(GetWidget());
+  connection_->buffer_manager_host()->ResetSurfaceContents(GetWidget());
 }
 
 void WaylandWindow::Close() {
@@ -269,9 +200,7 @@ void WaylandWindow::Close() {
 }
 
 bool WaylandWindow::IsVisible() const {
-  // X and Windows return true if the window is minimized. For consistency, do
-  // the same.
-  return (!!shell_surface_ || !!shell_popup_) || IsMinimized();
+  return !!shell_popup_;
 }
 
 void WaylandWindow::PrepareForShutdown() {}
@@ -281,6 +210,10 @@ void WaylandWindow::SetBounds(const gfx::Rect& bounds_px) {
     return;
   bounds_px_ = bounds_px;
 
+  // Opaque region is based on the size of the window. Thus, update the region
+  // on each update.
+  MaybeUpdateOpaqueRegion();
+
   delegate_->OnBoundsChanged(bounds_px_);
 }
 
@@ -288,11 +221,7 @@ gfx::Rect WaylandWindow::GetBounds() {
   return bounds_px_;
 }
 
-void WaylandWindow::SetTitle(const base::string16& title) {
-  DCHECK(shell_surface_);
-  shell_surface_->SetTitle(title);
-  connection_->ScheduleFlush();
-}
+void WaylandWindow::SetTitle(const base::string16& title) {}
 
 void WaylandWindow::SetCapture() {
   // Wayland does implicit grabs, and doesn't allow for explicit grabs. The
@@ -309,79 +238,18 @@ bool WaylandWindow::HasCapture() const {
   return shell_popup() ? true : has_implicit_grab_;
 }
 
-void WaylandWindow::ToggleFullscreen() {
-  DCHECK(shell_surface_);
+void WaylandWindow::ToggleFullscreen() {}
 
-  // There are some cases, when Chromium triggers a fullscreen state change
-  // before the surface is activated. In such cases, Wayland may ignore state
-  // changes and such flags as --kiosk or --start-fullscreen will be ignored.
-  // To overcome this, set a pending state, and once the surface is activated,
-  // trigger the change.
-  if (!is_active_) {
-    DCHECK(!IsFullscreen());
-    pending_state_ = PlatformWindowState::kFullScreen;
-    return;
-  }
-
-  // TODO(msisov, tonikitoo): add multiscreen support. As the documentation says
-  // if shell_surface_set_fullscreen() is not provided with wl_output, it's up
-  // to the compositor to choose which display will be used to map this surface.
-  if (!IsFullscreen()) {
-    // Fullscreen state changes have to be handled manually and then checked
-    // against configuration events, which come from a compositor. The reason
-    // of manually changing the |state_| is that the compositor answers about
-    // state changes asynchronously, which leads to a wrong return value in
-    // DesktopWindowTreeHostPlatform::IsFullscreen, for example, and media
-    // files can never be set to fullscreen.
-    state_ = PlatformWindowState::kFullScreen;
-    shell_surface_->SetFullscreen();
-  } else {
-    // Check the comment above. If it's not handled synchronously, media files
-    // may not leave the fullscreen mode.
-    state_ = PlatformWindowState::kUnknown;
-    shell_surface_->UnSetFullscreen();
-  }
-
-  connection_->ScheduleFlush();
-}
+void WaylandWindow::Maximize() {}
 
-void WaylandWindow::Maximize() {
-  DCHECK(shell_surface_);
+void WaylandWindow::Minimize() {}
 
-  if (IsFullscreen())
-    ToggleFullscreen();
-
-  shell_surface_->SetMaximized();
-  connection_->ScheduleFlush();
-}
-
-void WaylandWindow::Minimize() {
-  DCHECK(shell_surface_);
-  DCHECK(!is_minimizing_);
-  // Wayland doesn't explicitly say if a window is minimized. Instead, it
-  // notifies that the window is not activated. But there are many cases, when
-  // the window is not minimized and deactivated. In order to properly record
-  // the minimized state, mark this window as being minimized. And as soon as a
-  // configuration event comes, check if the window has been deactivated and has
-  // |is_minimizing_| set.
-  is_minimizing_ = true;
-  shell_surface_->SetMinimized();
-  connection_->ScheduleFlush();
-}
-
-void WaylandWindow::Restore() {
-  DCHECK(shell_surface_);
-
-  // Unfullscreen the window if it is fullscreen.
-  if (IsFullscreen())
-    ToggleFullscreen();
-
-  shell_surface_->UnSetMaximized();
-  connection_->ScheduleFlush();
-}
+void WaylandWindow::Restore() {}
 
 PlatformWindowState WaylandWindow::GetPlatformWindowState() const {
-  return state_;
+  // Remove normal state for all the other types of windows as it's only the
+  // WaylandSurface that supports state changes.
+  return PlatformWindowState::kNormal;
 }
 
 void WaylandWindow::Activate() {
@@ -448,22 +316,7 @@ void WaylandWindow::SetWindowIcons(const gfx::ImageSkia& window_icon,
   NOTIMPLEMENTED_LOG_ONCE();
 }
 
-void WaylandWindow::SizeConstraintsChanged() {
-  // Size constraints only make sense for normal windows.
-  if (!shell_surface_)
-    return;
-
-  DCHECK(delegate_);
-  auto min_size = delegate_->GetMinimumSizeForWindow();
-  auto max_size = delegate_->GetMaximumSizeForWindow();
-
-  if (min_size.has_value())
-    shell_surface_->SetMinSize(min_size->width(), min_size->height());
-  if (max_size.has_value())
-    shell_surface_->SetMaxSize(max_size->width(), max_size->height());
-
-  connection_->ScheduleFlush();
-}
+void WaylandWindow::SizeConstraintsChanged() {}
 
 bool WaylandWindow::CanDispatchEvent(const PlatformEvent& event) {
   // This window is a nested popup window, all the events must be forwarded
@@ -508,7 +361,7 @@ uint32_t WaylandWindow::DispatchEvent(const PlatformEvent& native_event) {
   if (event->IsLocatedEvent() && shell_popup()) {
     // Parent window of the main menu window is not a popup, but rather an
     // xdg surface.
-    DCHECK(!parent_window_->shell_popup() && parent_window_->shell_surface());
+    DCHECK(!parent_window_->shell_popup() || !parent_window_->is_tooltip_);
     auto* window =
         connection_->wayland_window_manager()->GetCurrentFocusedWindow();
     if (window) {
@@ -524,92 +377,13 @@ uint32_t WaylandWindow::DispatchEvent(const PlatformEvent& native_event) {
   return POST_DISPATCH_STOP_PROPAGATION;
 }
 
-void WaylandWindow::HandleSurfaceConfigure(int32_t width,
+void WaylandWindow::HandleSurfaceConfigure(int32_t widht,
                                            int32_t height,
                                            bool is_maximized,
                                            bool is_fullscreen,
                                            bool is_activated) {
-  DCHECK(!shell_popup());
-
-  // Propagate the window state information to the client.
-  PlatformWindowState old_state = state_;
-
-  // Ensure that manually handled state changes to fullscreen correspond to the
-  // configuration events from a compositor.
-  DCHECK_EQ(is_fullscreen, IsFullscreen());
-
-  // There are two cases, which must be handled for the minimized state.
-  // The first one is the case, when the surface goes into the minimized state
-  // (check comment in WaylandWindow::Minimize), and the second case is when the
-  // surface still has been minimized, but another cofiguration event with
-  // !is_activated comes. For this, check if the WaylandWindow has been
-  // minimized before and !is_activated is sent.
-  if ((is_minimizing_ || IsMinimized()) && !is_activated) {
-    is_minimizing_ = false;
-    state_ = PlatformWindowState::kMinimized;
-  } else if (is_fullscreen) {
-    // To ensure the |delegate_| is notified about state changes to fullscreen,
-    // assume the old_state is UNKNOWN (check comment in ToggleFullscreen).
-    old_state = PlatformWindowState::kUnknown;
-    DCHECK(state_ == PlatformWindowState::kFullScreen);
-  } else if (is_maximized) {
-    state_ = PlatformWindowState::kMaximized;
-  } else {
-    state_ = PlatformWindowState::kNormal;
-  }
-  const bool state_changed = old_state != state_;
-  const bool is_normal = !IsFullscreen() && !IsMaximized();
-
-  // Update state before notifying delegate.
-  const bool did_active_change = is_active_ != is_activated;
-  is_active_ = is_activated;
-
-  // Rather than call SetBounds here for every configure event, just save the
-  // most recent bounds, and have WaylandConnection call ApplyPendingBounds
-  // when it has finished processing events. We may get many configure events
-  // in a row during an interactive resize, and only the last one matters.
-  //
-  // Width or height set to 0 means that we should decide on width and height by
-  // ourselves, but we don't want to set them to anything else. Use restored
-  // bounds size or the current bounds iff the current state is normal (neither
-  // maximized nor fullscreen).
-  //
-  // Note: if the browser was started with --start-fullscreen and a user exits
-  // the fullscreen mode, wayland may set the width and height to be 1. Instead,
-  // explicitly set the bounds to the current desired ones or the previous
-  // bounds.
-  if (width > 1 && height > 1) {
-    pending_bounds_dip_ = gfx::Rect(0, 0, width, height);
-  } else if (is_normal) {
-    pending_bounds_dip_.set_size(gfx::ScaleToRoundedSize(
-        restored_bounds_px_.IsEmpty() ? GetBounds().size()
-                                      : restored_bounds_px_.size(),
-
-        1.0 / buffer_scale_));
-  }
-
-  if (state_changed) {
-    // The |restored_bounds_| are used when the window gets back to normal
-    // state after it went maximized or fullscreen.  So we reset these if the
-    // window has just become normal and store the current bounds if it is
-    // either going out of normal state or simply changes the state and we don't
-    // have any meaningful value stored.
-    if (is_normal) {
-      SetRestoredBoundsInPixels({});
-    } else if (old_state == PlatformWindowState::kNormal ||
-               restored_bounds_px_.IsEmpty()) {
-      SetRestoredBoundsInPixels(bounds_px_);
-    }
-
-    delegate_->OnWindowStateChanged(state_);
-  }
-
-  ApplyPendingBounds();
-
-  if (did_active_change)
-    delegate_->OnActivationChanged(is_active_);
-
-  MaybeTriggerPendingStateChange();
+  NOTREACHED()
+      << "Only shell surfaces must receive HandleSurfaceConfigure calls.";
 }
 
 void WaylandWindow::HandlePopupConfigure(const gfx::Rect& bounds_dip) {
@@ -671,40 +445,22 @@ void WaylandWindow::OnCloseRequest() {
 
 void WaylandWindow::OnDragEnter(const gfx::PointF& point,
                                 std::unique_ptr<OSExchangeData> data,
-                                int operation) {
-  WmDropHandler* drop_handler = GetWmDropHandler(*this);
-  if (!drop_handler)
-    return;
-  drop_handler->OnDragEnter(point, std::move(data), operation);
-}
+                                int operation) {}
 
 int WaylandWindow::OnDragMotion(const gfx::PointF& point,
                                 uint32_t time,
                                 int operation) {
-  WmDropHandler* drop_handler = GetWmDropHandler(*this);
-  if (!drop_handler)
-    return 0;
-
-  return drop_handler->OnDragMotion(point, operation);
+  return -1;
 }
 
-void WaylandWindow::OnDragDrop(std::unique_ptr<OSExchangeData> data) {
-  WmDropHandler* drop_handler = GetWmDropHandler(*this);
-  if (!drop_handler)
-    return;
-  drop_handler->OnDragDrop(std::move(data));
-}
+void WaylandWindow::OnDragDrop(std::unique_ptr<OSExchangeData> data) {}
 
-void WaylandWindow::OnDragLeave() {
-  WmDropHandler* drop_handler = GetWmDropHandler(*this);
-  if (!drop_handler)
-    return;
-  drop_handler->OnDragLeave();
-}
+void WaylandWindow::OnDragLeave() {}
 
-void WaylandWindow::OnDragSessionClose(uint32_t dnd_action) {
-  std::move(drag_closed_callback_).Run(dnd_action);
-  connection_->ResetPointerFlags();
+void WaylandWindow::OnDragSessionClose(uint32_t dnd_action) {}
+
+void WaylandWindow::SetBoundsDip(const gfx::Rect& bounds_dip) {
+  SetBounds(gfx::ScaleToRoundedRect(bounds_dip, buffer_scale_));
 }
 
 bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
@@ -752,15 +508,11 @@ bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
     case ui::PlatformWindowType::kWindow:
     case ui::PlatformWindowType::kBubble:
     case ui::PlatformWindowType::kDrag:
-      // TODO(msisov): Figure out what kind of surface we need to create for
-      // bubble and drag windows.
-      CreateShellSurface();
+      if (!OnInitialize(std::move(properties)))
+        return false;
       break;
   }
 
-  if (shell_surface_ && !properties.wm_class_class.empty())
-    shell_surface_->SetAppId(properties.wm_class_class);
-
   connection_->ScheduleFlush();
 
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
@@ -773,10 +525,6 @@ bool WaylandWindow::Initialize(PlatformWindowInitProperties properties) {
   return true;
 }
 
-void WaylandWindow::SetBoundsDip(const gfx::Rect& bounds_dip) {
-  SetBounds(gfx::ScaleToRoundedRect(bounds_dip, buffer_scale_));
-}
-
 void WaylandWindow::SetBufferScale(int32_t new_scale, bool update_bounds) {
   DCHECK_GT(new_scale, 0);
 
@@ -793,26 +541,6 @@ void WaylandWindow::SetBufferScale(int32_t new_scale, bool update_bounds) {
   connection_->ScheduleFlush();
 }
 
-bool WaylandWindow::IsMinimized() const {
-  return state_ == PlatformWindowState::kMinimized;
-}
-
-bool WaylandWindow::IsMaximized() const {
-  return state_ == PlatformWindowState::kMaximized;
-}
-
-bool WaylandWindow::IsFullscreen() const {
-  return state_ == PlatformWindowState::kFullScreen;
-}
-
-void WaylandWindow::MaybeTriggerPendingStateChange() {
-  if (pending_state_ == PlatformWindowState::kUnknown || !is_active_)
-    return;
-  DCHECK_EQ(pending_state_, PlatformWindowState::kFullScreen);
-  pending_state_ = PlatformWindowState::kUnknown;
-  ToggleFullscreen();
-}
-
 WaylandWindow* WaylandWindow::GetParentWindow(
     gfx::AcceleratedWidget parent_widget) {
   auto* parent_window =
@@ -838,10 +566,6 @@ WaylandWindow* WaylandWindow::GetRootParentWindow() {
   return parent_window_ ? parent_window_->GetRootParentWindow() : this;
 }
 
-WmMoveResizeHandler* WaylandWindow::AsWmMoveResizeHandler() {
-  return static_cast<WmMoveResizeHandler*>(this);
-}
-
 void WaylandWindow::AddSurfaceListener() {
   static struct wl_surface_listener surface_listener = {
       &WaylandWindow::Enter,
@@ -960,10 +684,12 @@ gfx::Rect WaylandWindow::AdjustPopupWindowPosition() const {
   // the parent menu window, which results in showing it on a second display if
   // more than one display is used.
   if (parent_window_->shell_popup() && parent_window_->parent_window_ &&
-      !parent_window_->parent_window_->IsMaximized()) {
+      (parent_window_->parent_window()->GetPlatformWindowState() !=
+       PlatformWindowState::kMaximized)) {
     auto* top_level_window = parent_window_->parent_window_;
     DCHECK(top_level_window && !top_level_window->shell_popup());
-    if (new_bounds_dip.x() <= 0 && !top_level_window->IsMaximized()) {
+    if (new_bounds_dip.x() <= 0 && top_level_window->GetPlatformWindowState() !=
+                                       PlatformWindowState::kMaximized) {
       // Position the child menu window on the right side of the parent window
       // and let the Wayland compositor decide how to do constraint
       // adjustements.
@@ -995,6 +721,10 @@ bool WaylandWindow::IsOpaqueWindow() const {
   return opacity_ == ui::PlatformWindowOpacity::kOpaqueWindow;
 }
 
+bool WaylandWindow::OnInitialize(PlatformWindowInitProperties properties) {
+  return true;
+}
+
 // static
 void WaylandWindow::Enter(void* data,
                           struct wl_surface* wl_surface,
diff --git a/ui/ozone/platform/wayland/host/wayland_window.h b/ui/ozone/platform/wayland/host/wayland_window.h
index b8cdc991e30e..b9ee70d0ecd2 100644
--- a/ui/ozone/platform/wayland/host/wayland_window.h
+++ b/ui/ozone/platform/wayland/host/wayland_window.h
@@ -19,8 +19,6 @@
 #include "ui/ozone/platform/wayland/common/wayland_object.h"
 #include "ui/platform_window/platform_window.h"
 #include "ui/platform_window/platform_window_delegate.h"
-#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
-#include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 
 namespace gfx {
@@ -33,12 +31,8 @@ class BitmapCursorOzone;
 class OSExchangeData;
 class WaylandConnection;
 class ShellPopupWrapper;
-class ShellSurfaceWrapper;
 
-class WaylandWindow : public PlatformWindow,
-                      public PlatformEventDispatcher,
-                      public WmMoveResizeHandler,
-                      public WmDragHandler {
+class WaylandWindow : public PlatformWindow, public PlatformEventDispatcher {
  public:
   ~WaylandWindow() override;
 
@@ -59,17 +53,12 @@ class WaylandWindow : public PlatformWindow,
   void UpdateBufferScale(bool update_bounds);
 
   wl_surface* surface() const { return surface_.get(); }
-  ShellSurfaceWrapper* shell_surface() const { return shell_surface_.get(); }
   ShellPopupWrapper* shell_popup() const { return shell_popup_.get(); }
 
   WaylandWindow* parent_window() const { return parent_window_; }
 
   gfx::AcceleratedWidget GetWidget() const;
 
-  // Apply the bounds specified in the most recent configure event. This should
-  // be called after processing all pending events in the wayland connection.
-  void ApplyPendingBounds();
-
   // Set whether this window has pointer focus and should dispatch mouse events.
   void SetPointerFocus(bool focus);
   bool has_pointer_focus() const { return has_pointer_focus_; }
@@ -94,23 +83,10 @@ class WaylandWindow : public PlatformWindow,
 
   int32_t buffer_scale() const { return buffer_scale_; }
 
-  bool is_active() const { return is_active_; }
-
   const base::flat_set<uint32_t>& entered_outputs_ids() const {
     return entered_outputs_ids_;
   }
 
-  // WmMoveResizeHandler
-  void DispatchHostWindowDragMovement(
-      int hittest,
-      const gfx::Point& pointer_location_in_px) override;
-
-  // WmDragHandler
-  void StartDrag(const ui::OSExchangeData& data,
-                 int operation,
-                 gfx::NativeCursor cursor,
-                 base::OnceCallback<void(int)> callback) override;
-
   // PlatformWindow
   void Show(bool inactive) override;
   void Hide() override;
@@ -147,49 +123,49 @@ class WaylandWindow : public PlatformWindow,
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
 
-  // Handles the configuration events coming from the surface (see
-  // |XDGSurfaceWrapperStable::ConfigureTopLevel| and
-  // |XDGSurfaceWrapperV6::ConfigureTopLevel|.  The width and height come in
-  // DIP of the output that the surface is currently bound to.
-  void HandleSurfaceConfigure(int32_t widht,
-                              int32_t height,
-                              bool is_maximized,
-                              bool is_fullscreen,
-                              bool is_activated);
+  // Handles the configuration events coming from the shell objects.
+  // The width and height come in DIP of the output that the surface is
+  // currently bound to.
+  virtual void HandleSurfaceConfigure(int32_t widht,
+                                      int32_t height,
+                                      bool is_maximized,
+                                      bool is_fullscreen,
+                                      bool is_activated);
   void HandlePopupConfigure(const gfx::Rect& bounds);
 
   void OnCloseRequest();
 
-  void OnDragEnter(const gfx::PointF& point,
-                   std::unique_ptr<OSExchangeData> data,
-                   int operation);
-  int OnDragMotion(const gfx::PointF& point, uint32_t time, int operation);
-  void OnDragDrop(std::unique_ptr<OSExchangeData> data);
-  void OnDragLeave();
-  void OnDragSessionClose(uint32_t dnd_action);
+  // Notifies about drag/drop session events.
+  virtual void OnDragEnter(const gfx::PointF& point,
+                           std::unique_ptr<OSExchangeData> data,
+                           int operation);
+  virtual int OnDragMotion(const gfx::PointF& point,
+                           uint32_t time,
+                           int operation);
+  virtual void OnDragDrop(std::unique_ptr<OSExchangeData> data);
+  virtual void OnDragLeave();
+  virtual void OnDragSessionClose(uint32_t dnd_action);
+
+ protected:
+  WaylandWindow(PlatformWindowDelegate* delegate,
+                WaylandConnection* connection);
+
+  WaylandConnection* connection() { return connection_; }
+  PlatformWindowDelegate* delegate() { return delegate_; }
+
+  // Sets bounds in dip.
+  void SetBoundsDip(const gfx::Rect& bounds_dip);
 
  private:
   FRIEND_TEST_ALL_PREFIXES(WaylandScreenTest, SetBufferScale);
 
-  WaylandWindow(PlatformWindowDelegate* delegate,
-                WaylandConnection* connection);
-
   // Initializes the WaylandWindow with supplied properties.
   bool Initialize(PlatformWindowInitProperties properties);
 
-  void SetBoundsDip(const gfx::Rect& bounds_dip);
   void SetBufferScale(int32_t scale, bool update_bounds);
 
-  bool IsMinimized() const;
-  bool IsMaximized() const;
-  bool IsFullscreen() const;
-
-  void MaybeTriggerPendingStateChange();
-
   // Creates a popup window, which is visible as a menu window.
   void CreateShellPopup();
-  // Creates a surface window, which is visible as a main window.
-  void CreateShellSurface();
   // Creates (if necessary) and show subsurface window, to host
   // tooltip's content.
   void CreateAndShowTooltipSubSurface();
@@ -200,8 +176,6 @@ class WaylandWindow : public PlatformWindow,
   // Returns a root parent window.
   WaylandWindow* GetRootParentWindow();
 
-  WmMoveResizeHandler* AsWmMoveResizeHandler();
-
   // Install a surface listener and start getting wl_output enter/leave events.
   void AddSurfaceListener();
 
@@ -221,6 +195,9 @@ class WaylandWindow : public PlatformWindow,
 
   bool IsOpaqueWindow() const;
 
+  // Additional initialization of derived classes.
+  virtual bool OnInitialize(PlatformWindowInitProperties properties);
+
   // wl_surface_listener
   static void Enter(void* data,
                     struct wl_surface* wl_surface,
@@ -239,25 +216,11 @@ class WaylandWindow : public PlatformWindow,
 
   // Wrappers around xdg v5 and xdg v6 objects. WaylandWindow doesn't
   // know anything about the version.
-  std::unique_ptr<ShellSurfaceWrapper> shell_surface_;
   std::unique_ptr<ShellPopupWrapper> shell_popup_;
 
   // The current cursor bitmap (immutable).
   scoped_refptr<BitmapCursorOzone> bitmap_;
 
-  base::OnceCallback<void(int)> drag_closed_callback_;
-
-  // These bounds attributes below have suffices that indicate units used.
-  // Wayland operates in DIP but the platform operates in physical pixels so
-  // our WaylandWindow is the link that has to translate the units.  See also
-  // comments in the implementation.
-  //
-  // Bounds that will be applied when the window state is finalized.  The window
-  // may get several configuration events that update the pending bounds, and
-  // only upon finalizing the state is the latest value stored as the current
-  // bounds via |ApplyPendingBounds|.  Measured in DIP because updated in the
-  // handler that receives DIP from Wayland.
-  gfx::Rect pending_bounds_dip_;
   // Current bounds of the platform window.
   gfx::Rect bounds_px_;
   // The bounds of the platform window before it went maximized or fullscreen.
@@ -275,18 +238,9 @@ class WaylandWindow : public PlatformWindow,
   // We need it to place and size the menus properly.
   float ui_scale_ = 1.0;
 
-  // Stores current states of the window.
-  PlatformWindowState state_;
-  // Stores a pending state of the window, which is used before the surface is
-  // activated.
-  PlatformWindowState pending_state_;
-
   // Stores current opacity of the window. Set on ::Initialize call.
   ui::PlatformWindowOpacity opacity_;
 
-  bool is_active_ = false;
-  bool is_minimizing_ = false;
-
   bool is_tooltip_ = false;
 
   // For top level window, stores IDs of outputs that the window is currently
diff --git a/ui/ozone/platform/wayland/host/wayland_window_factory.cc b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
index 19da59357d55..892902e7f845 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_factory.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_factory.cc
@@ -6,6 +6,7 @@
 
 #include <memory>
 
+#include "ui/ozone/platform/wayland/host/wayland_surface.h"
 #include "ui/ozone/platform/wayland/host/wayland_window.h"
 
 namespace ui {
@@ -15,12 +16,30 @@ std::unique_ptr<WaylandWindow> WaylandWindow::Create(
     PlatformWindowDelegate* delegate,
     WaylandConnection* connection,
     PlatformWindowInitProperties properties) {
-  // TODO(msisov): once WaylandWindow becomes a base class, add switch cases to
-  // create different Wayland windows.
-  std::unique_ptr<WaylandWindow> window(
-      new WaylandWindow(delegate, connection));
-  return window->Initialize(std::move(properties)) ? std::move(window)
-                                                   : nullptr;
+  std::unique_ptr<WaylandWindow> window;
+  switch (properties.type) {
+    case PlatformWindowType::kMenu:
+    case PlatformWindowType::kPopup:
+      // TODO(msisov): Add WaylandPopup.
+      window.reset(new WaylandWindow(delegate, connection));
+      break;
+    case PlatformWindowType::kTooltip:
+      // TODO(msisov): Add WaylandSubsurface.
+      window.reset(new WaylandWindow(delegate, connection));
+      break;
+    case PlatformWindowType::kWindow:
+    case PlatformWindowType::kBubble:
+    case PlatformWindowType::kDrag:
+      // TODO(msisov): Figure out what kind of surface we need to create for
+      // bubble and drag windows.
+      window.reset(new WaylandSurface(delegate, connection));
+      break;
+    default:
+      NOTREACHED();
+      break;
+  }
+  return window && window->Initialize(std::move(properties)) ? std::move(window)
+                                                             : nullptr;
 }
 
 }  // namespace ui
\ No newline at end of file
diff --git a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
index b03a28daadf2..132f740b0eb1 100644
--- a/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
+++ b/ui/ozone/platform/wayland/host/wayland_window_unittest.cc
@@ -26,6 +26,7 @@
 #include "ui/ozone/platform/wayland/test/test_wayland_server_thread.h"
 #include "ui/ozone/platform/wayland/test/wayland_test.h"
 #include "ui/ozone/test/mock_platform_window_delegate.h"
+#include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
 #include "ui/platform_window/platform_window_init_properties.h"
 
 using ::testing::_;
@@ -249,7 +250,6 @@ TEST_P(WaylandWindowTest, MaximizeAndRestore) {
   SendConfigureEvent(kMaximizedBounds.width(), kMaximizedBounds.height(), 2,
                      inactive_maximized.get());
   Sync();
-  EXPECT_FALSE(window_->is_active());
   VerifyAndClearExpectations();
 
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kMaximizedBounds.width(),
@@ -259,7 +259,6 @@ TEST_P(WaylandWindowTest, MaximizeAndRestore) {
   SendConfigureEvent(kMaximizedBounds.width(), kMaximizedBounds.height(), 3,
                      active_maximized.get());
   Sync();
-  EXPECT_TRUE(window_->is_active());
   VerifyAndClearExpectations();
 
   EXPECT_CALL(*xdg_surface_, SetWindowGeometry(0, 0, kNormalBounds.width(),
@@ -703,21 +702,17 @@ TEST_P(WaylandWindowTest, ConfigureEventWithNulledSize) {
 }
 
 TEST_P(WaylandWindowTest, OnActivationChanged) {
-  EXPECT_FALSE(window_->is_active());
-
   {
     ScopedWlArray states = InitializeWlArrayWithActivatedState();
     EXPECT_CALL(delegate_, OnActivationChanged(Eq(true)));
     SendConfigureEvent(0, 0, 1, states.get());
     Sync();
-    EXPECT_TRUE(window_->is_active());
   }
 
   ScopedWlArray states;
   EXPECT_CALL(delegate_, OnActivationChanged(Eq(false)));
   SendConfigureEvent(0, 0, 2, states.get());
   Sync();
-  EXPECT_FALSE(window_->is_active());
 }
 
 TEST_P(WaylandWindowTest, OnAcceleratedWidgetDestroy) {
@@ -847,7 +842,7 @@ TEST_P(WaylandWindowTest, CanDispatchEventToMenuWindowNested) {
 
 TEST_P(WaylandWindowTest, DispatchWindowMove) {
   EXPECT_CALL(*GetXdgSurface(), Move(_));
-  window_->DispatchHostWindowDragMovement(HTCAPTION, gfx::Point());
+  ui::GetWmMoveResizeHandler(*window_)->DispatchHostWindowDragMovement(HTCAPTION, gfx::Point());
 }
 
 // Makes sure hit tests are converted into right edges.
@@ -855,11 +850,14 @@ TEST_P(WaylandWindowTest, DispatchWindowResize) {
   std::vector<int> hit_test_values;
   InitializeWithSupportedHitTestValues(&hit_test_values);
 
+  auto* wm_move_resize_handler = ui::GetWmMoveResizeHandler(*window_);
+
   for (const int value : hit_test_values) {
     {
       uint32_t direction = wl::IdentifyDirection(*(connection_.get()), value);
       EXPECT_CALL(*GetXdgSurface(), Resize(_, Eq(direction)));
-      window_->DispatchHostWindowDragMovement(value, gfx::Point());
+      wm_move_resize_handler->DispatchHostWindowDragMovement(value,
+                                                             gfx::Point());
     }
   }
 }
diff --git a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
index abf6e7fa6461..e85236ce47d7 100644
--- a/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
+++ b/ui/ozone/platform/wayland/host/xdg_popup_wrapper_impl.cc
@@ -14,6 +14,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/ozone/platform/wayland/host/wayland_connection.h"
 #include "ui/ozone/platform/wayland/host/wayland_pointer.h"
+#include "ui/ozone/platform/wayland/host/wayland_surface.h"
 #include "ui/ozone/platform/wayland/host/wayland_window.h"
 #include "ui/ozone/platform/wayland/host/xdg_surface_wrapper_impl.h"
 
@@ -290,8 +291,10 @@ bool XDGPopupWrapperImpl::InitializeStable(WaylandConnection* connection,
         wayland_window_->parent_window()->shell_popup());
     parent_xdg_surface = popup->xdg_surface();
   } else {
+    WaylandSurface* wayland_surface =
+        static_cast<WaylandSurface*>(wayland_window_->parent_window());
     parent_xdg_surface = reinterpret_cast<XDGSurfaceWrapperImpl*>(
-        wayland_window_->parent_window()->shell_surface());
+        wayland_surface->shell_surface());
   }
 
   if (!parent_xdg_surface)
@@ -405,8 +408,10 @@ bool XDGPopupWrapperImpl::InitializeV6(WaylandConnection* connection,
         wayland_window_->parent_window()->shell_popup());
     parent_xdg_surface = popup->xdg_surface();
   } else {
+    WaylandSurface* wayland_surface =
+        static_cast<WaylandSurface*>(wayland_window_->parent_window());
     parent_xdg_surface = reinterpret_cast<XDGSurfaceWrapperImpl*>(
-        wayland_window_->parent_window()->shell_surface());
+        wayland_surface->shell_surface());
   }
 
   if (!parent_xdg_surface)
-- 
2.24.1

