diff --git a/include/gsl/multi_span b/include/gsl/multi_span
index 65e65a1..f697093 100644
--- a/include/gsl/multi_span
+++ b/include/gsl/multi_span
@@ -51,6 +51,16 @@
 #endif                          // _MSC_VER < 1910
 #endif                          // _MSC_VER
 
+// GCC 7 does not like the signed unsigned missmatch (size_t ptrdiff_t)
+// While there is a conversion from signed to unsigned, it happens at 
+// compiletime, so the compiler wouldn't have to warn indiscriminently, but 
+// could check if the source value actually doesn't fit into the target type 
+// and only warn in those cases.
+#if __GNUC__ > 6
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wsign-conversion"
+#endif
+
 #ifdef GSL_THROW_ON_CONTRACT_VIOLATION
 #define GSL_NOEXCEPT /*noexcept*/
 #else
@@ -2225,4 +2235,8 @@ general_span_iterator<Span> operator+(typename general_span_iterator<Span>::diff
 
 #endif // _MSC_VER
 
+#if __GNUC__ > 6 
+#pragma GCC diagnostic pop
+#endif // __GNUC__ > 6
+
 #endif // GSL_MULTI_SPAN_H
diff --git a/include/gsl/span b/include/gsl/span
index 6dd1c1f..2fa9cc5 100644
--- a/include/gsl/span
+++ b/include/gsl/span
@@ -58,6 +58,16 @@
 
 #endif                          // _MSC_VER
 
+// GCC 7 does not like the signed unsigned missmatch (size_t ptrdiff_t)
+// While there is a conversion from signed to unsigned, it happens at 
+// compiletime, so the compiler wouldn't have to warn indiscriminently, but 
+// could check if the source value actually doesn't fit into the target type 
+// and only warn in those cases.
+#if __GNUC__ > 6
+#pragma GCC diagnostic push
+#pragma GCC diagnostic ignored "-Wsign-conversion"
+#endif
+
 namespace gsl
 {
 
@@ -191,6 +201,11 @@ namespace details
             return ret += n;
         }
 
+        friend constexpr span_iterator operator+(difference_type n, span_iterator const& rhs)
+        {
+            return rhs + n;
+        }
+
         constexpr span_iterator& operator+=(difference_type n)
         {
             Expects((index_ + n) >= 0 && (index_ + n) <= span_->size());
@@ -253,27 +268,49 @@ namespace details
             return !(rhs > lhs);
         }
 
+#ifdef _MSC_VER
+        // MSVC++ iterator debugging support; allows STL algorithms in 15.8+
+        // to unwrap span_iterator to a pointer type after a range check in STL
+        // algorithm calls
+        friend constexpr void _Verify_range(span_iterator lhs,
+                                            span_iterator rhs) noexcept
+        {   // test that [lhs, rhs) forms a valid range inside an STL algorithm
+            Expects(lhs.span_ == rhs.span_ // range spans have to match
+                && lhs.index_ <= rhs.index_); // range must not be transposed
+        }
+
+        constexpr void _Verify_offset(const difference_type n) const noexcept
+        {   // test that the iterator *this + n is a valid range in an STL
+            // algorithm call
+            Expects((index_ + n) >= 0 && (index_ + n) <= span_->size());
+        }
+
+        constexpr pointer _Unwrapped() const noexcept
+        {   // after seeking *this to a high water mark, or using one of the
+            // _Verify_xxx functions above, unwrap this span_iterator to a raw
+            // pointer
+            return span_->data() + index_;
+        }
+
+        // Tell the STL that span_iterator should not be unwrapped if it can't
+        // validate in advance, even in release / optimized builds:
+#if defined(GSL_USE_STATIC_CONSTEXPR_WORKAROUND)
+        static constexpr const bool _Unwrap_when_unverified = false;
+#else
+        static constexpr bool _Unwrap_when_unverified = false;
+#endif
+        constexpr void _Seek_to(const pointer p) noexcept
+        {   // adjust the position of *this to previously verified location p
+            // after _Unwrapped
+            index_ = p - span_->data();
+        }
+#endif
+
     protected:
         const Span* span_ = nullptr;
         std::ptrdiff_t index_ = 0;
     };
 
-    template <class Span, bool IsConst>
-    constexpr span_iterator<Span, IsConst>
-    operator+(typename span_iterator<Span, IsConst>::difference_type n,
-              span_iterator<Span, IsConst> rhs)
-    {
-        return rhs + n;
-    }
-
-    template <class Span, bool IsConst>
-    constexpr span_iterator<Span, IsConst>
-    operator-(typename span_iterator<Span, IsConst>::difference_type n,
-              span_iterator<Span, IsConst> rhs)
-    {
-        return rhs - n;
-    }
-
     template <std::ptrdiff_t Ext>
     class extent_type
     {
@@ -418,7 +455,7 @@ public:
 
     ~span() noexcept = default;
     constexpr span& operator=(const span& other) noexcept = default;
-    
+
     // [span.sub], span subviews
     template <std::ptrdiff_t Count>
     constexpr span<element_type, Count> first() const
@@ -493,10 +530,16 @@ public:
     constexpr const_reverse_iterator crbegin() const noexcept { return const_reverse_iterator{cend()}; }
     constexpr const_reverse_iterator crend() const noexcept { return const_reverse_iterator{cbegin()}; }
 
+#ifdef _MSC_VER
+    // Tell MSVC how to unwrap spans in range-based-for
+    constexpr pointer _Unchecked_begin() const noexcept { return data(); }
+    constexpr pointer _Unchecked_end() const noexcept { return data() + size(); }
+#endif // _MSC_VER
+
 private:
 
     // Needed to remove unnecessary null check in subspans
-    struct KnownNotNull 
+    struct KnownNotNull
     {
         pointer p;
     };
@@ -508,7 +551,7 @@ private:
     class storage_type : public ExtentType
     {
     public:
-        // KnownNotNull parameter is needed to remove unnecessary null check 
+        // KnownNotNull parameter is needed to remove unnecessary null check
         // in subspans and constructors from arrays
         template <class OtherExtentType>
         constexpr storage_type(KnownNotNull data, OtherExtentType ext) : ExtentType(ext), data_(data.p)
@@ -716,4 +759,8 @@ constexpr ElementType& at(span<ElementType, Extent> s, index i)
 #pragma warning(pop)
 #endif // _MSC_VER
 
+#if __GNUC__ > 6 
+#pragma GCC diagnostic pop
+#endif // __GNUC__ > 6
+
 #endif // GSL_SPAN_H
