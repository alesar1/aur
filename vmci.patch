diff --git a/vmci/linux/driver.c b/vmci/linux/driver.c
index 64a3cca..526f9a9 100644
--- a/vmci/linux/driver.c
+++ b/vmci/linux/driver.c
@@ -26,6 +26,7 @@
 
 #include <linux/file.h>
 #include <linux/fs.h>
+#include <linux/vmalloc.h>
 #include <linux/init.h>
 #if defined(__x86_64__) && LINUX_VERSION_CODE < KERNEL_VERSION(2, 6, 12)
 #   include <linux/ioctl32.h>
@@ -713,7 +714,7 @@ LinuxDriver_Ioctl(struct inode *inode,
 
    case IOCTL_VMCI_INIT_CONTEXT: {
       VMCIInitBlock initBlock;
-      VMCIHostUser user;
+      uid_t user;
 
       retval = copy_from_user(&initBlock, (void *)ioarg, sizeof initBlock);
       if (retval != 0) {
@@ -735,7 +736,11 @@ LinuxDriver_Ioctl(struct inode *inode,
          goto init_release;
       }
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 13, 0)
       user = current_uid();
+#else
+      user = from_kuid(&init_user_ns, current_uid());
+#endif
       retval = VMCIContext_InitContext(initBlock.cid, initBlock.flags,
                                        0 /* Unused */, vmciLinux->userVersion,
                                        &user, &vmciLinux->context);
@@ -1467,7 +1472,11 @@ VMCIUserVALockPage(VA addr) // IN:
    int retval;
 
    down_read(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+   retval = get_user_pages(addr,
+#else
    retval = get_user_pages(current, current->mm, addr,
+#endif
                            1, 1, 0, &page, NULL);
    up_read(&current->mm->mmap_sem);
 
@@ -1683,7 +1692,11 @@ vmci_guest_init(void)
    /* This should be last to make sure we are done initializing. */
    retval = pci_register_driver(&vmci_driver);
    if (retval < 0) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
       vfree(data_buffer);
+#else
+      kvfree(data_buffer);
+#endif
       data_buffer = NULL;
       return retval;
    }
@@ -2470,7 +2483,11 @@ vmci_exit(void)
 
    if (guestDeviceInit) {
       pci_unregister_driver(&vmci_driver);
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 15, 0)
       vfree(data_buffer);
+#else
+      kvfree(data_buffer);
+#endif
       guestDeviceInit = FALSE;
    }
 
@@ -2479,12 +2496,16 @@ vmci_exit(void)
 
       VMCI_HostCleanup();
 
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4, 3, 0)
       retval = misc_deregister(&linuxState.misc);
       if (retval) {
          Warning(LGPFX "Module %s: error unregistering\n", VMCI_MODULE_NAME);
       } else {
          Log(LGPFX"Module %s: unloaded\n", VMCI_MODULE_NAME);
       }
+#else
+      misc_deregister(&linuxState.misc);
+#endif
 
       hostDeviceInit = FALSE;
    }
diff --git a/vmci/linux/vmciKernelIf.c b/vmci/linux/vmciKernelIf.c
index 8b1788f..12cce68 100644
--- a/vmci/linux/vmciKernelIf.c
+++ b/vmci/linux/vmciKernelIf.c
@@ -40,6 +40,7 @@
 #include <linux/socket.h>       /* For memcpy_{to,from}iovec(). */
 #include <linux/vmalloc.h>
 #include <linux/wait.h>
+#include <linux/skbuff.h>
 
 #include "compat_highmem.h"
 #include "compat_interrupt.h"
@@ -1198,11 +1199,19 @@ __VMCIMemcpyToQueue(VMCIQueue *queue,   // OUT:
       }
 
       if (isIovec) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
          struct iovec *iov = (struct iovec *)src;
+#else
+         struct msghdr *msg = (struct msghdr *)src;
+#endif
          int err;
 
          /* The iovec will track bytesCopied internally. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
          err = memcpy_fromiovec((uint8 *)va + pageOffset, iov, toCopy);
+#else
+         err = memcpy_from_msg((u8 *)va + pageOffset, msg, toCopy);
+#endif
          if (err != 0) {
             if (kernelIf->host) {
                kunmap(kernelIf->u.h.page[pageIndex]);
@@ -1273,11 +1282,19 @@ __VMCIMemcpyFromQueue(void *dest,             // OUT:
       }
 
       if (isIovec) {
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
          struct iovec *iov = (struct iovec *)dest;
+#else
+         struct msghdr *msg = (struct msghdr *)dest;
+#endif
          int err;
 
          /* The iovec will track bytesCopied internally. */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(3, 19, 0)
          err = memcpy_toiovec(iov, (uint8 *)va + pageOffset, toCopy);
+#else
+         err = memcpy_to_msg(msg, (uint8 *)va + pageOffset, toCopy);
+#endif
          if (err != 0) {
             if (kernelIf->host) {
                kunmap(kernelIf->u.h.page[pageIndex]);
@@ -1834,7 +1851,11 @@ VMCIReleasePages(struct page **pages,  // IN
       if (dirty) {
          set_page_dirty(pages[i]);
       }
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+      put_page(pages[i]);
+#else
       page_cache_release(pages[i]);
+#endif
       pages[i] = NULL;
    }
 }
@@ -2048,8 +2069,12 @@ VMCIHost_GetUserMemory(VA64 produceUVA,       // IN
    int err = VMCI_SUCCESS;
 
    down_write(&current->mm->mmap_sem);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+   retval = get_user_pages(
+#else
    retval = get_user_pages(current,
                            current->mm,
+#endif
                            (VA)produceUVA,
                            produceQ->kernelIf->numPages,
                            1, 0,
@@ -2062,8 +2087,12 @@ VMCIHost_GetUserMemory(VA64 produceUVA,       // IN
       goto out;
    }
 
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4, 6, 0)
+   retval = get_user_pages(
+#else
    retval = get_user_pages(current,
                            current->mm,
+#endif
                            (VA)consumeUVA,
                            consumeQ->kernelIf->numPages,
                            1, 0,
diff --git a/vmci/shared/vm_device_version.h b/vmci/shared/vm_device_version.h
index e2cb477..3dd7097 100644
--- a/vmci/shared/vm_device_version.h
+++ b/vmci/shared/vm_device_version.h
@@ -53,7 +53,9 @@
  *    VMware HD Audio codec
  *    VMware HD Audio controller
  */
+#ifndef PCI_VENDOR_ID_VMWARE
 #define PCI_VENDOR_ID_VMWARE                    0x15AD
+#endif
 #define PCI_DEVICE_ID_VMWARE_SVGA2              0x0405
 #define PCI_DEVICE_ID_VMWARE_SVGA               0x0710
 #define PCI_DEVICE_ID_VMWARE_VGA                0x0711
diff --git a/vmci/shared/vmci_kernel_if.h b/vmci/shared/vmci_kernel_if.h
index 9def671..082fe59 100644
--- a/vmci/shared/vmci_kernel_if.h
+++ b/vmci/shared/vmci_kernel_if.h
@@ -93,7 +93,7 @@
   typedef Semaphore VMCIEvent;
   typedef Semaphore VMCIMutex;
   typedef World_ID VMCIHostVmID;
-  typedef uint32 VMCIHostUser;
+  typedef uint32_t VMCIHostUser;
   typedef PPN *VMCIQPGuestMem;
 #elif defined(linux)
   typedef spinlock_t VMCILock;
