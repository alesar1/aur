From b5c80feb62683d24ec0529f685a1d7a36962a1d4 Mon Sep 17 00:00:00 2001
From: Ate Eskola <ajieskola@gmail.com>
Date: Tue, 31 Aug 2021 00:01:00 +0300
Subject: [PATCH] Added the needed `.get`s to make compile with removed alias
 this in Nullable

---
 BioD/bio/std/experimental/hts/bam/reader.d | 63 +++++++++++-----------
 BioD/bio/std/experimental/hts/bgzf.d       | 14 ++---
 BioD/bio/std/experimental/hts/pileup.d     |  8 +--
 sambamba/markdup.d                         | 10 ++--
 sambamba/pileup.d                          | 26 ++++-----
 sambamba/subsample.d                       |  6 +--
 6 files changed, 65 insertions(+), 62 deletions(-)

diff --git a/BioD/bio/std/experimental/hts/bam/reader.d b/BioD/bio/std/experimental/hts/bam/reader.d
index 6710aae..13a6b23 100644
--- a/BioD/bio/std/experimental/hts/bam/reader.d
+++ b/BioD/bio/std/experimental/hts/bam/reader.d
@@ -33,7 +33,7 @@ import std.string;
 import std.typecons;
 import std.bitmanip;
 
-//TODO remove these dependecies 
+//TODO remove these dependecies
 import bio.std.hts.bam.cigar;
 import bio.std.hts.bam.constants;
 
@@ -234,7 +234,7 @@ struct ProcessReadBlob {
   }
 
   @property void cleanup() {
-    _read2.cleanup;
+    _read2.get.cleanup;
   }
 
   @property nothrow bool isNull() {
@@ -242,20 +242,20 @@ struct ProcessReadBlob {
   }
 
   @property RefId ref_id() {
-    enforce(_read2.is_mapped,"Trying to get ref_id an unmapped read " ~ to!string(_read2));
-    return _read2.refid;
+    enforce(_read2.get.is_mapped,"Trying to get ref_id an unmapped read " ~ to!string(_read2));
+    return _read2.get.refid;
   }
 
   @property RefId raw_ref_id() {
-    return _read2.refid;
+    return _read2.get.refid;
   }
 
   @property nothrow uint _flag_nc() {
-    return _read2._flag_nc;
+    return _read2.get._flag_nc;
   }
 
   @property nothrow ushort _flag() {
-    return _read2._flag;
+    return _read2.get._flag;
   }
 
   alias ref_id refid;
@@ -264,24 +264,24 @@ struct ProcessReadBlob {
   /// start_loc), i.e., the first base that gets consumed in the
   /// CIGAR.
   @property GenomePos start_pos() {
-    assert(_read2.is_mapped,"Trying to get pos on an unmapped read"); // BAM spec
-    asserte(_read2.pos < GenomePos.max);
-    return cast(GenomePos)_read2.pos;
+    assert(_read2.get.is_mapped,"Trying to get pos on an unmapped read"); // BAM spec
+    asserte(_read2.get.pos < GenomePos.max);
+    return cast(GenomePos)_read2.get.pos;
   }
 
   @property GenomePos raw_start_pos() {
-    return cast(GenomePos)_read2.pos;
+    return cast(GenomePos)_read2.get.pos;
   }
 
   /// Get the end position on the reference sequence (better use end_loc)
   @property GenomePos end_pos() {
     assert(sequence_length > 0, "Trying to get end_pos on an empty read sequence");
     assert(!consumed_reference_bases.isNull);
-    return start_pos + consumed_reference_bases;
+    return start_pos + consumed_reference_bases.get;
   }
 
   @property GenomePos raw_end_pos() {
-    return raw_start_pos + consumed_reference_bases;
+    return raw_start_pos + consumed_reference_bases.get;
   }
 
   @property GenomeLocation start_loc() {
@@ -293,27 +293,27 @@ struct ProcessReadBlob {
   }
 
   @property @trusted MappingQuality mapping_quality() { // MAPQ
-    assert(_read2.is_mapped,"Trying to get MAPQ on an unmapped read"); // BAM spec
-    return MappingQuality(_read2.mapping_quality);
+    assert(_read2.get.is_mapped,"Trying to get MAPQ on an unmapped read"); // BAM spec
+    return MappingQuality(_read2.get.mapping_quality);
   }
 
   @property @trusted int tlen() { // do not use
-    return _read2._tlen;
+    return _read2.get._tlen;
   }
 
   @property @trusted GenomePos sequence_length() {
     if (sequence_length2.isNull)
-      sequence_length2 = _read2.sequence_length;
-    return sequence_length2;
+      sequence_length2 = _read2.get.sequence_length;
+    return sequence_length2.get;
   }
 
   /// Count and caches consumed reference bases. Uses raw_cigar to
   /// avoid a heap allocation.
   @property @trusted Nullable!GenomePos consumed_reference_bases() {
     if (consumed_reference_bases2.isNull) {
-      assert(_read2.is_mapped,"Trying to get consumed bases on an unmapped read"); // BAM spec
+      assert(_read2.get.is_mapped,"Trying to get consumed bases on an unmapped read"); // BAM spec
       assert(!read_name.isNull,"Trying to get CIGAR on RNAME is '*'"); // BAM spec
-      auto raw = cast(uint[]) _read2.raw_cigar();
+      auto raw = cast(uint[]) _read2.get.raw_cigar();
       if (raw.length==1 && raw[0] == '*')
         return consumed_reference_bases2; // null
       else {
@@ -332,11 +332,14 @@ struct ProcessReadBlob {
   /// Count query consumed bases. Uses raw_cigar to avoid a heap
   /// allocation.
   @property @trusted GenomePos consumed_query_bases() {
-    assert(_read2.is_mapped,"Trying to get consumed bases on an unmapped read"); // BAM spec
+    assert(_read2.get.is_mapped,"Trying to get consumed bases on an unmapped read"); // BAM spec
     assert(!read_name.isNull,"Trying to get CIGAR on RNAME is '*'"); // BAM spec
-    auto raw = cast(uint[]) _read2.raw_cigar();
+    auto raw = cast(uint[]) _read2.get.raw_cigar();
     if (raw.length==1 && raw[0] == '*')
-      return consumed_reference_bases2; // null
+      // The existing comment here says "null", but function return type
+      // forces reading the value anyway. Bug?
+      // -Nix packager
+      return consumed_reference_bases2.get; // null
     else {
       GenomePos bases = 0;
       for (size_t i = 0; i < raw.length; i++) {
@@ -352,8 +355,8 @@ struct ProcessReadBlob {
   /// null. Caches name.
   @property Nullable!string read_name() {
     if (read_name2.isNull) {
-      assert(_read2.is_mapped,"Trying to get RNAME on an unmapped read"); // BAM spec
-      auto raw = _read2.read_name;
+      assert(_read2.get.is_mapped,"Trying to get RNAME on an unmapped read"); // BAM spec
+      auto raw = _read2.get.read_name;
       if (raw.length == 0 || (raw.length ==1 && raw[0] == '*'))
         return read_name2; // null
       assert(raw.length < 255); // BAM spec
@@ -368,9 +371,9 @@ struct ProcessReadBlob {
   /// operations. Caches Cigar when there are operations.
   @property Nullable!CigarOperations cigar() {
     if (cigar2.isNull) {
-      assert(_read2.is_mapped,"Trying to get CIGAR on an unmapped read"); // BAM spec
+      assert(_read2.get.is_mapped,"Trying to get CIGAR on an unmapped read"); // BAM spec
       assert(!read_name.isNull,"Trying to get CIGAR on RNAME is '*'"); // BAM spec
-      auto raw = cast(uint[]) _read2.raw_cigar();
+      auto raw = cast(uint[]) _read2.get.raw_cigar();
       if (raw.length==0 || (raw.length==1 && raw[0] == '*'))
         return cigar2; // null
       else {
@@ -389,7 +392,7 @@ struct ProcessReadBlob {
   /// undefined. Caches sequence.
   @property Nullable!string sequence() {
     if (sequence2.isNull) { // is it cached in sequence2?
-      auto raw = _read2.raw_sequence();
+      auto raw = _read2.get.raw_sequence();
       if (raw[0] == '*') {
         assert(raw.length == 1);
         return sequence2; // null
@@ -409,7 +412,7 @@ struct ProcessReadBlob {
   }
 
   @property ubyte[] toBlob() {
-    return _read2._data;
+    return _read2.get._data;
   }
 
   @property string posString() {
@@ -488,7 +491,7 @@ struct BamReadBlobStream {
     // void *p = pureMalloc(block_size-2*int.sizeof); // test for GC effectiveness
     data = new ubyte[block_size-2*int.sizeof];
     readbuf = ReadBlob(refid,pos,stream.read(data));
-    assert(readbuf._data.ptr == data.ptr);
+    assert(readbuf.get._data.ptr == data.ptr);
   }
 
 }
diff --git a/BioD/bio/std/experimental/hts/bgzf.d b/BioD/bio/std/experimental/hts/bgzf.d
index 1841d2e..ddfe219 100644
--- a/BioD/bio/std/experimental/hts/bgzf.d
+++ b/BioD/bio/std/experimental/hts/bgzf.d
@@ -199,7 +199,7 @@ struct BgzfReader {
     try {
       if (fpos.isNull) throwBgzfException("Trying to read past eof");
       report_fpos = fpos;
-      f.seek(fpos);
+      f.seek(fpos.get);
       immutable compressed_size = read_block_header();
       auto ret = read_compressed_data(buffer[0..compressed_size]);
       auto compressed_buf = ret[0];
@@ -209,7 +209,7 @@ struct BgzfReader {
       if (uncompressed_size == 0) {
         // check for eof marker, rereading block header
         auto lastpos = f.tell();
-        f.seek(start_offset);
+        f.seek(start_offset.get);
         ubyte[BGZF_EOF.length] buf;
         f.rawRead(buf);
         f.seek(lastpos);
@@ -412,17 +412,17 @@ struct BgzfStream {
     size_t remaining = buffer_length;
 
     while (remaining > 0) {
-      if (block_pos + remaining < uncompressed_size) {
+      if (block_pos.get + remaining < uncompressed_size) {
         // full copy
         assert(buffer_pos + remaining == buffer_length);
-        memcpy(buffer[buffer_pos..buffer_pos+remaining].ptr,uncompressed_buf[block_pos..block_pos+remaining].ptr,remaining);
-        block_pos += remaining;
+        memcpy(buffer[buffer_pos..buffer_pos+remaining].ptr,uncompressed_buf[block_pos.get..block_pos.get+remaining].ptr,remaining);
+        block_pos.get += remaining;
         remaining = 0;
       }
       else {
         // read tail of buffer
-        immutable tail = uncompressed_size - block_pos;
-        memcpy(buffer[buffer_pos..buffer_pos+tail].ptr,uncompressed_buf[block_pos..uncompressed_size].ptr,tail);
+        immutable tail = uncompressed_size - block_pos.get;
+        memcpy(buffer[buffer_pos..buffer_pos+tail].ptr,uncompressed_buf[block_pos.get..uncompressed_size].ptr,tail);
         buffer_pos += tail;
         remaining -= tail;
         auto res = blockread.read_block(bgzf,fpos,uncompressed_buf);
diff --git a/BioD/bio/std/experimental/hts/pileup.d b/BioD/bio/std/experimental/hts/pileup.d
index 9f3e729..effb493 100644
--- a/BioD/bio/std/experimental/hts/pileup.d
+++ b/BioD/bio/std/experimental/hts/pileup.d
@@ -271,14 +271,14 @@ class PileUp(R) {
   }
   ref R read_current() {
     enforce(!current.isNull, "current should be set for PileUp.read_current");
-    return read(current);
+    return read(current.get);
   }
   bool is_at_end(RingBufferIndex idx) { return ring.is_tail(idx); }
 
   @property void current_inc() {
     asserte(!empty);
-    asserte(!ring.is_tail(current));
-    ++current;
+    asserte(!ring.is_tail(current.get));
+    ++current.get;
   }
 
   @property void set_current_to_head() {
@@ -290,7 +290,7 @@ class PileUp(R) {
   }
 
   @property bool current_is_tail() {
-    return ring.is_tail(current);
+    return ring.is_tail(current.get);
   }
 
   void each(void delegate(R) dg) {
diff --git a/sambamba/markdup.d b/sambamba/markdup.d
index c1c9d72..03e9cac 100644
--- a/sambamba/markdup.d
+++ b/sambamba/markdup.d
@@ -504,8 +504,8 @@ struct CollateReadPairRange(R, bool keepFragments, alias charsHashFunc)
     void popFrontTempFiles() {
         while (!_tmp_reads.empty) {
             auto r2 = next(_tmp_reads);
-            if (readsArePaired(_tmp_r1, r2)) {
-                _front = FrontType(_tmp_r1, r2);
+            if (readsArePaired(_tmp_r1.get, r2)) {
+                _front = FrontType(_tmp_r1.get, r2);
                 if (!_tmp_reads.empty)
                     _tmp_r1 = next(_tmp_reads);
                 else
@@ -513,7 +513,7 @@ struct CollateReadPairRange(R, bool keepFragments, alias charsHashFunc)
                 return;
             } else {
                 static if (keepFragments) {
-                    _front = FrontType(_tmp_r1);
+                    _front = FrontType(_tmp_r1.get);
                     _tmp_r1 = r2;
                     return;
                 } else {
@@ -523,7 +523,7 @@ struct CollateReadPairRange(R, bool keepFragments, alias charsHashFunc)
         }
 
         if (!_tmp_r1.isNull) {
-            _front = FrontType(_tmp_r1);
+            _front = FrontType(_tmp_r1.get);
             _tmp_r1.nullify();
             return;
         }
@@ -1050,7 +1050,7 @@ auto getDuplicateOffsets(R)(R reads, ReadGroupIndex rg_index,
                                        cfg.tmpdir, pool)) {
         auto end1 = collectSingleEndInfo(pf.read1, rg_index);
         if (!pf.read2.isNull) {
-            auto end2 = collectSingleEndInfo(pf.read2, rg_index);
+            auto end2 = collectSingleEndInfo(pf.read2.get, rg_index);
             auto pair = combine(end1, end2);
             paired_ends.put(pair);
             second_ends.put(end2.basic_info);
diff --git a/sambamba/pileup.d b/sambamba/pileup.d
index 010afca..723ed14 100644
--- a/sambamba/pileup.d
+++ b/sambamba/pileup.d
@@ -429,28 +429,28 @@ class ChunkDispatcher(ChunkRange) {
         }
 
         if (num_ > 1) {
-            ulong diff = chunk[0].end_position - chunk[0].start_position;
-            int ref_id = chunk[0].ref_id;
-            if (ref_id == prev_ref_id && !chunk[0].front.reads.empty &&
-                prev_pos_diff + diff < chunk[0].front.reads[0].sequence_length) // assume reads are ~same length
+            ulong diff = chunk.get[0].end_position - chunk.get[0].start_position;
+            int ref_id = chunk.get[0].ref_id;
+            if (ref_id == prev_ref_id && !chunk.get[0].front.reads.empty &&
+                prev_pos_diff + diff < chunk.get[0].front.reads[0].sequence_length) // assume reads are ~same length
                 stderr.writeln("[WARNING] COVERAGE IS TOO HIGH, INCREASE --buffer-size TO AVOID WRONG RESULTS");
             prev_pos_diff = diff;
             prev_ref_id = ref_id;
         }
 
-        auto ref_name = bam_.reference_sequences[chunk[0].ref_id].name;
+        auto ref_name = bam_.reference_sequences[chunk.get[0].ref_id].name;
         auto f = std.stdio.File(filename ~ ".bed", "w");
         if (bed_filename is null) {
-            auto start = chunk[0].start_position;
-            auto end = chunk[0].end_position;
+            auto start = chunk.get[0].start_position;
+            auto end = chunk.get[0].end_position;
 
             auto bed = BedRecord(ref_name, start, end);
             f.writeln(bed);
         } else {
             foreach (reg; regions) {
-                if (chunk[0].ref_id != reg.ref_id) continue;
-                auto start = max(reg.start, chunk[0].start_position);
-                auto end = min(reg.end, chunk[0].end_position);
+                if (chunk.get[0].ref_id != reg.ref_id) continue;
+                auto start = max(reg.start, chunk.get[0].start_position);
+                auto end = min(reg.end, chunk.get[0].end_position);
                 if (start > end) continue;
                 auto bed = BedRecord(ref_name, start, end);
                 f.writeln(bed);
@@ -525,9 +525,9 @@ void worker(Dispatcher)(Dispatcher d,
         if (result.isNull)
             return;
 
-        auto chunk = result[0];
-        auto filename = result[1];
-        auto num = result[2];
+        auto chunk = result.get[0];
+        auto filename = result.get[1];
+        auto num = result.get[2];
         makeFifo(filename);
 
         import core.sys.posix.signal;
diff --git a/sambamba/subsample.d b/sambamba/subsample.d
index c73a3da..c162230 100644
--- a/sambamba/subsample.d
+++ b/sambamba/subsample.d
@@ -243,7 +243,7 @@ void foreach_invalid_read(ref BamBlobReader reader, void delegate(ProcessReadBlo
 
 // ---- When current is unmapped, move through reads that are ignored.
 void foreach_outside_read(ref BamBlobReader reader, void delegate(ProcessReadBlob) dg) {
-  if (reader.peek.is_unmapped) {
+  if (reader.peek.get.is_unmapped) {
     foreach_invalid_read(reader,dg);
   }
 }
@@ -384,13 +384,13 @@ int subsample_main(string[] args) {
        }
       if (!pileup.empty) {
         auto read = reader.peek;
-        if (read.is_mapped && depth.ref_id != read.refid) {
+        if (read.get.is_mapped && depth.ref_id != read.get.refid) {
           // moving into a new pileup
           pileup.purge( (ReadState read) {
               write(",");
               writer.push(read.read);
             });
-          depth.reset(read.refid);
+          depth.reset(read.get.refid);
         }
       }
 
