diff --color --unified --recursive --text a/vlib/v/util/util.v b/vlib/v/util/util.v
--- a/vlib/v/util/util.v	2020-08-06 12:52:48.123603455 -0800
+++ b/vlib/v/util/util.v	2020-08-06 12:53:17.171010251 -0800
@@ -118,7 +118,6 @@
 	set_vroot_folder(vroot)
 	tool_args := args_quote_paths_with_spaces(args)
 	tool_exe := path_of_executable(os.real_path('$vroot/cmd/tools/$tool_name'))
-	tool_source := os.real_path('$vroot/cmd/tools/${tool_name}.v')
 	tool_command := '"$tool_exe" $tool_args'
 	if is_verbose {
 		println('launch_tool vexe        : $vroot')
@@ -126,56 +125,6 @@
 		println('launch_tool tool_args   : $tool_args')
 		println('launch_tool tool_command: $tool_command')
 	}
-	// TODO Caching should be done on the `vlib/v` level.
-	mut should_compile := false
-	if !os.exists(tool_exe) {
-		should_compile = true
-	} else {
-		if os.file_last_mod_unix(tool_exe) <= os.file_last_mod_unix(vexe) {
-			// v was recompiled, maybe after v up ...
-			// rebuild the tool too just in case
-			should_compile = true
-			if tool_name == 'vself' || tool_name == 'vup' {
-				// The purpose of vself/up is to update and recompile v itself.
-				// After the first 'v self' execution, v will be modified, so
-				// then a second 'v self' will detect, that v is newer than the
-				// vself executable, and try to recompile vself/up again, which
-				// will slow down the next v recompilation needlessly.
-				should_compile = false
-			}
-		}
-		if os.file_last_mod_unix(tool_exe) <= os.file_last_mod_unix(tool_source) {
-			// the user changed the source code of the tool, or git updated it:
-			should_compile = true
-		}
-	}
-	if is_verbose {
-		println('launch_tool should_compile: $should_compile')
-	}
-	if should_compile {
-		emodules := external_module_dependencies_for_tool[tool_name]
-		for emodule in emodules {
-			check_module_is_installed(emodule, is_verbose) or {
-				panic(err)
-			}
-		}
-		mut compilation_command := '"$vexe" '
-		compilation_command += '"$tool_source"'
-		if is_verbose {
-			println('Compiling $tool_name with: "$compilation_command"')
-		}
-		tool_compilation := os.exec(compilation_command) or {
-			panic(err)
-		}
-		if tool_compilation.exit_code != 0 {
-			mut err := 'Permission denied'
-			if !tool_compilation.output.contains(err) {
-				err = '\n$tool_compilation.output'
-			}
-			eprintln('cannot compile `$tool_source`: $err')
-			exit(1)
-		}
-	}
 	if is_verbose {
 		println('launch_tool running tool command: $tool_command ...')
 	}
