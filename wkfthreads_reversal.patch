--- src/WKFThreads.C	2020-10-16 19:12:35.700720013 +0300
+++ src/WKFThreads.C	2020-10-20 23:43:13.354885730 +0300
@@ -3,7 +3,7 @@
  *
  *      $RCSfile: WKFThreads.C,v $
  *      $Author: johns $        $Locker:  $             $State: Exp $
- *      $Revision: 1.25 $       $Date: 2020/07/20 04:17:49 $
+ *      $Revision: 1.20 $       $Date: 2020/02/26 15:43:31 $
  *
  ***************************************************************************/
 /**
@@ -22,7 +22,7 @@
  *       running the sequence of 'sed' commands shown at the top of the
  *       "threads.c" file within the Tachyon source distribution.
  *
- * $Revision: 1.25 $       $Date: 2020/07/20 04:17:49 $
+ * $Revision: 1.20 $       $Date: 2020/02/26 15:43:31 $
  *
  * \author John E. Stone - john.stone@gmail.com
  * \copyright
@@ -233,211 +233,12 @@
 }
 
 
-/*
- * Functions supporting processor-specific runtime dispatch for hand-written
- * kernels using SIMD vector intrinsics or other highly specialized routines.
- */
-#define WKF_USEINTCPUID 1
-#if defined(WKF_USEINTCPUID) && (defined(__GNUC__) || defined(__INTEL_COMPILER)) && (defined(__i386__) || defined(__x86_64__))
-#if 1
-//static void wkf_cpuid(uint32_t eax, uint32_t ecx, uint32_t* abcd) {
-static void wkf_cpuid(unsigned int eax, unsigned int ecx, unsigned int* abcd) {
-#if defined(_MSC_VER)
-  __cpuidex((int*)abcd, eax, ecx);
-#else
-//  uint32_t ebx, edx;
-  unsigned int ebx=0, edx=0;
-#if defined(__i386__) && defined (__PIC__)
-  /* in case of PIC under 32-bit EBX cannot be clobbered */
-  __asm__("movl %%ebx, %%edi \n\t cpuid \n\t xchgl %%ebx, %%edi" : "=D" (ebx),
-#else
-  __asm__("cpuid" : "+b" (ebx),
-#endif
-          "+a" (eax), "+c" (ecx), "=d" (edx));
-          abcd[0] = eax; abcd[1] = ebx; abcd[2] = ecx; abcd[3] = edx;
-#endif
-  }
-#else
-static void wkf_cpuid(unsigned int eax, unsigned int ecx, unsigned int *info) {
-  __asm__ __volatile__(
-    "xchg %%ebx, %%edi;"
-    "cpuid;"
-    "xchg %%ebx, %%edi;"
-    :"=a" (info[0]), "=D" (info[1]), "=c" (info[2]), "=d" (info[3])
-    :"0" (eax)
-  );
-}
-#endif
-
-static unsigned long long wkf_xgetbv(unsigned int index) {
-  unsigned int eax=0, edx=0;
-  __asm__ __volatile__(
-    "xgetbv;"
-    : "=a" (eax), "=d"(edx)
-    : "c" (index)
-  );
-  return ((unsigned long long) edx << 32) | eax;
-}
-#endif
-
-
-static int wkf_x86cpu_vector_reg_state(wkf_cpu_caps_t *cpucaps) {
-
-#if defined(WKF_USEINTCPUID) && (defined(__GNUC__) || defined(__INTEL_COMPILER)) && (defined(__i386__) || defined(__x86_64__))
-  unsigned int cpuinfo[4] = { 0 };
-  int havexmmymm = 0;
-  int havezmmmask = 0;
-  int haveosxsave = 0;
-  unsigned long long xcrFeatureMask = 0;
-  unsigned long long xcrXinuse = 0;
-
-  wkf_cpuid(1, 0, cpuinfo);     /* get various SIMD extension flags */
-  haveosxsave = (cpuinfo[2] & (1 << 27)) != 0; /* OS save/restore xmm regs */
-
-  /* if we have AVX, we need to call xgetbv too */
-  if ((cpuinfo[2] & (1 << 28)) != 0) {
-    xcrFeatureMask = wkf_xgetbv(0);
-    havexmmymm  = (xcrFeatureMask & 0x06) == 0x06;
-    havezmmmask = (xcrFeatureMask & 0xE6) == 0xE6;
-    xcrXinuse = wkf_xgetbv(1);
-  }
-
-  printf("wkf_x86cpu_vector_reg_state():\n");
-  printf("  XINUSE %16lx\n", xcrXinuse);
-  printf("    ");
-  if (xcrXinuse & 0x01)
-    printf("x87  ");
-  if (xcrXinuse & 0x02)
-    printf("SSE  ");
-  if (xcrXinuse & 0x04)
-    printf("YMM_Hi128  ");
-  if (xcrXinuse & 0x20)
-    printf("OpMask  ");
-  if (xcrXinuse & 0x40)
-    printf("ZMM_Hi256  ");
-  if (xcrXinuse & 0x80)
-    printf("Hi16_ZMM  ");
-  printf("\n");
-
-#endif
-
-  return 0;   
-}
-
-
 int wkf_cpu_capability_flags(wkf_cpu_caps_t *cpucaps) {
   int flags=CPU_UNKNOWN;
-  int smtdepth = CPU_SMTDEPTH_UNKNOWN;
-
-#if defined(WKF_USEINTCPUID) && (defined(__GNUC__) || defined(__INTEL_COMPILER)) && (defined(__i386__) || defined(__x86_64__))
-  // https://software.intel.com/content/www/us/en/develop/articles/how-to-detect-new-instruction-support-in-the-4th-generation-intel-core-processor-family.html
-  // https://stackoverflow.com/questions/6121792/how-to-check-if-a-cpu-supports-the-sse3-instruction-set
-  // https://gist.github.com/hi2p-perim/7855506
-  // http://www.hugi.scene.org/online/coding/hugi%2016%20-%20corawhd4.htm
-  // http://www.geoffchappell.com/studies/windows/km/cpu/precpuid.htm
-  // http://www.geoffchappell.com/studies/windows/km/cpu/cpuid/index.htm
-  // https://www.sandpile.org/x86/cpuid.htm
-  unsigned int vendcpuinfo[4] = { 0 };
-  unsigned int cpuinfo[4] = { 0 };
-  unsigned long long xcrFeatureMask = 0;
-  int havexmmymm = 0;
-  int havezmmmask = 0;
-  int haveosxsave = 0;
-
-  wkf_cpuid(0, 0, vendcpuinfo); /* get vendor string, highest function code */
-  if (vendcpuinfo[0] == 0)
-    goto nocpuinfo; /* bail on very primitive CPU type, max fctn code==0 */
-
-  wkf_cpuid(1, 0, cpuinfo);     /* get various SIMD extension flags */
-  haveosxsave = (cpuinfo[2] & (1 << 27)) != 0; /* OS save/restore xmm regs */
-
-  flags = 0;
-  flags |= ((cpuinfo[2] & (1 << 19)) != 0)           * CPU_SSE4_1;
-  flags |= ((cpuinfo[2] & (1 << 29)) != 0)           * CPU_F16C;
-  flags |= ((cpuinfo[2] & (1 << 31)) != 0)           * CPU_HYPERVISOR;
-  flags |= ((cpuinfo[3] & (1 << 26)) != 0)           * CPU_SSE2;
-  flags |= ((cpuinfo[3] & (1 << 28)) != 0)           * CPU_HT;
-
-  /* if we have AVX, we need to call xgetbv too */
-  if ((cpuinfo[2] & (1 << 28)) != 0) {
-    xcrFeatureMask = wkf_xgetbv(0);
-    havexmmymm  = (xcrFeatureMask & 0x06) == 0x06;
-    havezmmmask = (xcrFeatureMask & 0xE6) == 0xE6;
-  }
-
-  flags |= (((cpuinfo[2] & (1 << 28)) != 0) &&
-            havexmmymm && haveosxsave)               * CPU_AVX;
-
-  /* check that we can call CPUID function 7 */
-  if (cpuinfo[0] >= 0x7) {
-    unsigned int extcpuinfo[4] = { 0 };
-    wkf_cpuid(7, 0, extcpuinfo);
-
-    flags |= (((extcpuinfo[1] & (1 << 5)) != 0) &&
-              havexmmymm && haveosxsave)               * CPU_AVX2;
-
-    flags |= (((extcpuinfo[1] & (1 << 16)) != 0) &&
-              havezmmmask && haveosxsave)              * CPU_AVX512F;
-    flags |= (((extcpuinfo[1] & (1 << 26)) != 0) &&
-              havezmmmask && haveosxsave)              * CPU_AVX512PF;
-    flags |= (((extcpuinfo[1] & (1 << 27)) != 0) &&
-              havezmmmask && haveosxsave)              * CPU_AVX512ER;
-    flags |= (((extcpuinfo[1] & (1 << 28)) != 0) &&
-              havezmmmask && haveosxsave)              * CPU_AVX512CD;
-  }
 
-  smtdepth = 1;
-  if (flags & CPU_HT) {
-#if 1
-    /* XXX correct this for Phi, OS/BIOS settings */
-    smtdepth = 2;
-
-    /* XXX Hack to detect Xeon Phi CPUs since no other CPUs */
-    /* support AVX-512ER or AVX-512PF (yet...)              */        
-    if ((flags & CPU_AVX512ER) && (flags & CPU_AVX512PF)) {
-      smtdepth = 4;
-    }
-#else
-    int logicalcores = (cpuinfo[1] >> 16) && 0xFF;
-    int physicalcores = logicalcores;
-    char vendor[16] = { 0 };
-    ((unsigned *)vendor)[0] = vendcpuinfo[1]; 
-    ((unsigned *)vendor)[1] = vendcpuinfo[3]; 
-    ((unsigned *)vendor)[2] = vendcpuinfo[2]; 
-
-    /* hmm, not quite right yet */
-    if (!strcmp(vendor, "GenuineIntel")) {
-      unsigned int corecpuinfo[4] = { 0 };
-      wkf_cpuid(4, 0, corecpuinfo);
-      physicalcores = ((corecpuinfo[0] >> 26) & 0x3f) + 1;
-    } else if (!strcmp(vendor, "AuthenticAMD")) {
-      unsigned int corecpuinfo[4] = { 0 };
-      wkf_cpuid(0x80000008, 0, corecpuinfo);
-      physicalcores = (corecpuinfo[2] & 0xFF) + 1;        
-    }
-
-printf("cpuinfo: %d / %d  vend: %s\n", logicalcores, physicalcores, vendor);
-
-    smtdepth = logicalcores / physicalcores; 
-#endif
-  }  
-
-#if 1
-  __m256 qq = _mm256_set1_ps(3.14159f);
-  __m512 qqqq = _mm512_set1_ps(3.141f); 
-  float q1 = ((float *) &qq)[0];
-  float q2 = ((float *) &qqqq)[0];
-//  _mm256_zeroupper();
-  printf("  q1: %f  q2: %f\n\n", q1, q2);
-#endif
-wkf_x86cpu_vector_reg_state(cpucaps);
-
-#elif defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1300)
-
-  // https://software.intel.com/content/www/us/en/develop/documentation/cpp-compiler-developer-guide-and-reference/top/compiler-reference/intrinsics/intrinsics-for-all-intel-architectures/may-i-use-cpu-feature.html
+#if defined(__INTEL_COMPILER) && (__INTEL_COMPILER >= 1300)
   flags = 0;
   flags |= _may_i_use_cpu_feature(_FEATURE_SSE2)     * CPU_SSE2;
-  flags |= _may_i_use_cpu_feature(_FEATURE_SSE4_1)   * CPU_SSE4_1;
   flags |= _may_i_use_cpu_feature(_FEATURE_AVX)      * CPU_AVX;
   flags |= _may_i_use_cpu_feature(_FEATURE_AVX2)     * CPU_AVX2;
   flags |= _may_i_use_cpu_feature(_FEATURE_FMA)      * CPU_FMA;
@@ -445,27 +246,9 @@
   flags |= _may_i_use_cpu_feature(_FEATURE_AVX512CD) * CPU_AVX512CD;
   flags |= _may_i_use_cpu_feature(_FEATURE_AVX512ER) * CPU_AVX512ER;
   flags |= _may_i_use_cpu_feature(_FEATURE_AVX512PF) * CPU_AVX512PF;
-
-#elif defined(__GNUC__) && (defined(__i386__) || defined(__x86_64__))
-
-  // https://gcc.gnu.org/onlinedocs/gcc/x86-Built-in-Functions.html
-  flags = 0;
-  __builtin_cpu_init();
-  flags |= (__builtin_cpu_supports("sse2")!=0)       * CPU_SSE2;
-  flags |= (__builtin_cpu_supports("sse4.1")!=0)     * CPU_SSE4_1;
-  flags |= (__builtin_cpu_supports("avx")!=0)        * CPU_AVX;
-  flags |= (__builtin_cpu_supports("avx2")!=0)       * CPU_AVX2;
-  flags |= (__builtin_cpu_supports("fma")!=0)        * CPU_FMA;
-  flags |= (__builtin_cpu_supports("avx512f")!=0)    * CPU_AVX512F;
-  flags |= (__builtin_cpu_supports("avx512cd")!=0)   * CPU_AVX512CD;
-  flags |= (__builtin_cpu_supports("avx512er")!=0)   * CPU_AVX512ER;
-  flags |= (__builtin_cpu_supports("avx512pf")!=0)   * CPU_AVX512PF;
-
 #endif
 
-nocpuinfo:
   cpucaps->flags = flags;
-  cpucaps->smtdepth = smtdepth;
 
   if (flags == CPU_UNKNOWN)
     return 1;
@@ -474,23 +257,6 @@
 }
 
 
-int wkf_cpu_smt_depth(void) {
-  int smtdepth = CPU_SMTDEPTH_UNKNOWN;
-
-#if defined(WKF_USEINTCPUID) && (defined(__GNUC__) || defined(__INTEL_COMPILER)) && (defined(__i386__) || defined(__x86_64__))
-  // x86 examples:
-  //  https://software.intel.com/en-us/articles/methods-to-utilize-intels-hyper-threading-technology-with-linux
-  // https://stackoverflow.com/questions/2901694/how-to-detect-the-number-of-physical-processors-cores-on-windows-mac-and-linu
-  wkf_cpu_caps_t cpucaps;
-  if (!wkf_cpu_capability_flags(&cpucaps)) {
-    smtdepth = cpucaps.smtdepth;
-  }
-#endif
-
-  return smtdepth;
-}
-
-
 int * wkf_cpu_affinitylist(int *cpuaffinitycount) {
   int *affinitylist = NULL;
   *cpuaffinitycount = -1; /* return count -1 if unimplemented or err occurs */
