From cc95d58f3531307aaef1a7d1df9a229c2ec75b29 Mon Sep 17 00:00:00 2001
From: =?UTF-8?q?Cl=C3=A9ment=20Gu=C3=A9rin?= <libcg@protonmail.com>
Date: Fri, 17 Jun 2022 16:42:22 -0700
Subject: [PATCH 1/2] handle SDL touch events

disable SDL mouse emulation to avoid getting mouse events.
---
 src/sdlwindow.cpp |  16 +++
 src/wlserver.cpp  | 251 ++++++++++++++++++++++++----------------------
 src/wlserver.hpp  |   4 +
 3 files changed, 153 insertions(+), 118 deletions(-)

diff --git a/src/sdlwindow.cpp b/src/sdlwindow.cpp
index 9486c3a..4c6c79e 100644
--- a/src/sdlwindow.cpp
+++ b/src/sdlwindow.cpp
@@ -105,6 +105,7 @@ void inputSDLThreadRun( void )
 	}
 
 	SDL_SetRelativeMouseMode(SDL_TRUE);
+	SDL_SetHint(SDL_HINT_TOUCH_MOUSE_EVENTS, "0");
 
 	g_nOldNestedRefresh = g_nNestedRefresh;
 
@@ -136,6 +137,21 @@ void inputSDLThreadRun( void )
 				wlserver_mousewheel( -event.wheel.x, -event.wheel.y, event.wheel.timestamp );
 				wlserver_unlock();
 				break;
+			case SDL_FINGERMOTION:
+				wlserver_lock();
+				wlserver_touchmotion( event.tfinger.x, event.tfinger.y, event.tfinger.fingerId, event.tfinger.timestamp );
+				wlserver_unlock();
+				break;
+			case SDL_FINGERDOWN:
+				wlserver_lock();
+				wlserver_touchdown( event.tfinger.x, event.tfinger.y, event.tfinger.fingerId, event.tfinger.timestamp );
+				wlserver_unlock();
+				break;
+			case SDL_FINGERUP:
+				wlserver_lock();
+				wlserver_touchup( event.tfinger.fingerId, event.tfinger.timestamp );
+				wlserver_unlock();
+				break;
 			case SDL_KEYDOWN:
 			case SDL_KEYUP:
 				key = SDLScancodeToLinuxKey( event.key.keysym.scancode );
diff --git a/src/wlserver.cpp b/src/wlserver.cpp
index cbf5df8..0862f51 100644
--- a/src/wlserver.cpp
+++ b/src/wlserver.cpp
@@ -280,57 +280,7 @@ static void wlserver_handle_touch_down(struct wl_listener *listener, void *data)
 	struct wlserver_touch *touch = wl_container_of( listener, touch, down );
 	struct wlr_event_touch_down *event = (struct wlr_event_touch_down *) data;
 
-	if ( wlserver.mouse_focus_surface != NULL )
-	{
-		double x = g_bRotated ? event->y : event->x;
-		double y = g_bRotated ? 1.0 - event->x : event->y;
-
-		x *= g_nOutputWidth;
-		y *= g_nOutputHeight;
-
-		x += focusedWindowOffsetX;
-		y += focusedWindowOffsetY;
-
-		x *= focusedWindowScaleX;
-		y *= focusedWindowScaleY;
-
-		wlserver.mouse_surface_cursorx = x;
-		wlserver.mouse_surface_cursory = y;
-
-		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
-		{
-			if ( event->touch_id >= 0 && event->touch_id < WLSERVER_TOUCH_COUNT )
-			{
-				wlr_seat_touch_notify_down( wlserver.wlr.seat, wlserver.mouse_focus_surface, event->time_msec, event->touch_id,
-											wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
-
-				wlserver.touch_down[ event->touch_id ] = true;
-			}
-		}
-		else if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_DISABLED )
-		{
-			return;
-		}
-		else
-		{
-			g_bPendingTouchMovement = true;
-
-			wlr_seat_pointer_notify_motion( wlserver.wlr.seat, event->time_msec, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
-			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
-
-			uint32_t button = steamcompmgr_button_to_wlserver_button( g_nTouchClickMode );
-
-			if ( button != 0 && g_nTouchClickMode < WLSERVER_BUTTON_COUNT )
-			{
-				wlr_seat_pointer_notify_button( wlserver.wlr.seat, event->time_msec, button, WLR_BUTTON_PRESSED );
-				wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
-
-				wlserver.button_held[ g_nTouchClickMode ] = true;
-			}
-		}
-	}
-
-	bump_input_counter();
+	wlserver_touchdown( event->x, event->y, event->touch_id, event->time_msec );
 }
 
 static void wlserver_handle_touch_up(struct wl_listener *listener, void *data)
@@ -338,38 +288,7 @@ static void wlserver_handle_touch_up(struct wl_listener *listener, void *data)
 	struct wlserver_touch *touch = wl_container_of( listener, touch, up );
 	struct wlr_event_touch_up *event = (struct wlr_event_touch_up *) data;
 
-	if ( wlserver.mouse_focus_surface != NULL )
-	{
-		bool bReleasedAny = false;
-		for ( int i = 0; i < WLSERVER_BUTTON_COUNT; i++ )
-		{
-			if ( wlserver.button_held[ i ] == true )
-			{
-				uint32_t button = steamcompmgr_button_to_wlserver_button( i );
-
-				if ( button != 0 )
-				{
-					wlr_seat_pointer_notify_button( wlserver.wlr.seat, event->time_msec, button, WLR_BUTTON_RELEASED );
-					bReleasedAny = true;
-				}
-
-				wlserver.button_held[ i ] = false;
-			}
-		}
-
-		if ( bReleasedAny == true )
-		{
-			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
-		}
-
-		if ( event->touch_id >= 0 && event->touch_id < WLSERVER_TOUCH_COUNT && wlserver.touch_down[ event->touch_id ] == true )
-		{
-			wlr_seat_touch_notify_up( wlserver.wlr.seat, event->time_msec, event->touch_id );
-			wlserver.touch_down[ event->touch_id ] = false;
-		}
-	}
-
-	bump_input_counter();
+	wlserver_touchup( event->touch_id, event->time_msec );
 }
 
 static void wlserver_handle_touch_motion(struct wl_listener *listener, void *data)
@@ -377,41 +296,7 @@ static void wlserver_handle_touch_motion(struct wl_listener *listener, void *dat
 	struct wlserver_touch *touch = wl_container_of( listener, touch, motion );
 	struct wlr_event_touch_motion *event = (struct wlr_event_touch_motion *) data;
 
-	if ( wlserver.mouse_focus_surface != NULL )
-	{
-		double x = g_bRotated ? event->y : event->x;
-		double y = g_bRotated ? 1.0 - event->x : event->y;
-
-		x *= g_nOutputWidth;
-		y *= g_nOutputHeight;
-
-		x += focusedWindowOffsetX;
-		y += focusedWindowOffsetY;
-
-		x *= focusedWindowScaleX;
-		y *= focusedWindowScaleY;
-
-		wlserver.mouse_surface_cursorx = x;
-		wlserver.mouse_surface_cursory = y;
-
-		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
-		{
-			wlr_seat_touch_notify_motion( wlserver.wlr.seat, event->time_msec, event->touch_id, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
-		}
-		else if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_DISABLED )
-		{
-			return;
-		}
-		else
-		{
-			g_bPendingTouchMovement = true;
-
-			wlr_seat_pointer_notify_motion( wlserver.wlr.seat, event->time_msec, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
-			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
-		}
-	}
-
-	bump_input_counter();
+	wlserver_touchmotion( event->x, event->y, event->touch_id, event->time_msec );
 }
 
 static void wlserver_new_input(struct wl_listener *listener, void *data)
@@ -972,6 +857,136 @@ void wlserver_send_frame_done( struct wlr_surface *surf, const struct timespec *
 	wlr_surface_send_frame_done( surf, when );
 }
 
+void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time )
+{
+	if ( wlserver.mouse_focus_surface != NULL )
+	{
+		double tx = g_bRotated ? y : x;
+		double ty = g_bRotated ? 1.0 - x : y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
+		{
+			wlr_seat_touch_notify_motion( wlserver.wlr.seat, time, touch_id, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
+		}
+		else if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_DISABLED )
+		{
+			return;
+		}
+		else
+		{
+			g_bPendingTouchMovement = true;
+
+			wlr_seat_pointer_notify_motion( wlserver.wlr.seat, time, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
+			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
+		}
+	}
+
+	bump_input_counter();
+}
+
+void wlserver_touchdown( double x, double y, int touch_id, uint32_t time )
+{
+	if ( wlserver.mouse_focus_surface != NULL )
+	{
+		double tx = g_bRotated ? y : x;
+		double ty = g_bRotated ? 1.0 - x : y;
+
+		tx *= g_nOutputWidth;
+		ty *= g_nOutputHeight;
+
+		tx += focusedWindowOffsetX;
+		ty += focusedWindowOffsetY;
+
+		tx *= focusedWindowScaleX;
+		ty *= focusedWindowScaleY;
+
+		wlserver.mouse_surface_cursorx = tx;
+		wlserver.mouse_surface_cursory = ty;
+
+		if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_PASSTHROUGH )
+		{
+			if ( touch_id >= 0 && touch_id < WLSERVER_TOUCH_COUNT )
+			{
+				wlr_seat_touch_notify_down( wlserver.wlr.seat, wlserver.mouse_focus_surface, time, touch_id,
+											wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
+
+				wlserver.touch_down[ touch_id ] = true;
+			}
+		}
+		else if ( g_nTouchClickMode == WLSERVER_TOUCH_CLICK_DISABLED )
+		{
+			return;
+		}
+		else
+		{
+			g_bPendingTouchMovement = true;
+
+			wlr_seat_pointer_notify_motion( wlserver.wlr.seat, time, wlserver.mouse_surface_cursorx, wlserver.mouse_surface_cursory );
+			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
+
+			uint32_t button = steamcompmgr_button_to_wlserver_button( g_nTouchClickMode );
+
+			if ( button != 0 && g_nTouchClickMode < WLSERVER_BUTTON_COUNT )
+			{
+				wlr_seat_pointer_notify_button( wlserver.wlr.seat, time, button, WLR_BUTTON_PRESSED );
+				wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
+
+				wlserver.button_held[ g_nTouchClickMode ] = true;
+			}
+		}
+	}
+
+	bump_input_counter();
+}
+
+void wlserver_touchup( int touch_id, uint32_t time )
+{
+	if ( wlserver.mouse_focus_surface != NULL )
+	{
+		bool bReleasedAny = false;
+		for ( int i = 0; i < WLSERVER_BUTTON_COUNT; i++ )
+		{
+			if ( wlserver.button_held[ i ] == true )
+			{
+				uint32_t button = steamcompmgr_button_to_wlserver_button( i );
+
+				if ( button != 0 )
+				{
+					wlr_seat_pointer_notify_button( wlserver.wlr.seat, time, button, WLR_BUTTON_RELEASED );
+					bReleasedAny = true;
+				}
+
+				wlserver.button_held[ i ] = false;
+			}
+		}
+
+		if ( bReleasedAny == true )
+		{
+			wlr_seat_pointer_notify_frame( wlserver.wlr.seat );
+		}
+
+		if ( touch_id >= 0 && touch_id < WLSERVER_TOUCH_COUNT && wlserver.touch_down[ touch_id ] == true )
+		{
+			wlr_seat_touch_notify_up( wlserver.wlr.seat, time, touch_id );
+			wlserver.touch_down[ touch_id ] = false;
+		}
+	}
+
+	bump_input_counter();
+}
+
 gamescope_xwayland_server_t *wlserver_get_xwayland_server( size_t index )
 {
 	if (index >= wlserver.wlr.xwayland_servers.size() )
diff --git a/src/wlserver.hpp b/src/wlserver.hpp
index 1522be6..cb0f06a 100644
--- a/src/wlserver.hpp
+++ b/src/wlserver.hpp
@@ -152,6 +152,10 @@ void wlserver_mousemotion( int x, int y, uint32_t time );
 void wlserver_mousebutton( int button, bool press, uint32_t time );
 void wlserver_mousewheel( int x, int y, uint32_t time );
 
+void wlserver_touchmotion( double x, double y, int touch_id, uint32_t time );
+void wlserver_touchdown( double x, double y, int touch_id, uint32_t time );
+void wlserver_touchup( int touch_id, uint32_t time );
+
 void wlserver_send_frame_done( struct wlr_surface *surf, const struct timespec *when );
 
 gamescope_xwayland_server_t *wlserver_get_xwayland_server( size_t index );
-- 
2.37.1

