diff -rupN a/src/kimchi/model/host.py b/src/kimchi/model/host.py
--- a/src/kimchi/model/host.py	2015-06-10 19:12:27.395432953 +0200
+++ b/src/kimchi/model/host.py	2015-06-10 19:21:35.661184834 +0200
@@ -91,7 +91,7 @@ class HostModel(object):
         res['memory'] = psutil.TOTAL_PHYMEM
 
         # Include IBM PowerKVM name to supported distro names
-        _sup_distros = platform._supported_dists + ('ibm_powerkvm',)
+        _sup_distros = platform._supported_dists + ('ibm_powerkvm','arch',)
         # 'fedora' '17' 'Beefy Miracle'
         distro, version, codename = platform.linux_distribution(
             supported_dists=_sup_distros)
diff -rupN a/src/kimchi/swupdate.py b/src/kimchi/swupdate.py
--- a/src/kimchi/swupdate.py	2015-06-10 19:12:27.392099645 +0200
+++ b/src/kimchi/swupdate.py	2015-06-10 19:13:53.784764143 +0200
@@ -25,6 +25,9 @@ from kimchi.config import kimchiLock
 from kimchi.exception import NotFoundError, OperationFailed
 from kimchi.utils import kimchi_log, run_command
 
+import re
+import os
+
 
 class SoftwareUpdate(object):
     __metaclass__ = Singleton
@@ -62,8 +65,14 @@ class SoftwareUpdate(object):
                     kimchi_log.info("Loading ZypperUpdate features.")
                     self._pkg_mnger = ZypperUpdate()
                 else:
-                    raise Exception("There is no compatible package manager "
-                                    "for this system.")
+                    pacman_help = ["pacman", "--help"]
+                    (stdout, stderr, returncode) = run_command(pacman_help)
+                    if returncode == 0:
+                        kimchi_log.info("Loading PacmanUpdate features.")
+                        self._pkg_mnger = PacmanUpdate()
+                    else:
+                        raise Exception("There is no compatible package manager "
+                                        "for this system.")
 
     def _scanUpdates(self):
         """
@@ -264,3 +273,66 @@ class ZypperUpdate(object):
         self._refreshUpdateList()
         kimchiLock.release()
         return self._pkgs
+
+class PacmanUpdate(object):
+    """
+    Class to represent and operate with Pacman software update system.
+    It's loaded only on those systems listed at PACMAN_DISTROS and loads
+    necessary modules in runtime.
+    """
+
+    def __init__(self):
+        self._pkgs = {}
+        self.update_cmd = ["pacman", "-Su", "--noconfirm", "--noprogressbar"]
+
+    def _refreshUpdateList(self):
+        """
+        Update the list of packages to be updated in the system.
+        """
+        self._pkgs = []
+        cmd_update = ["pacman", "-Sy"]
+        cmd_list = ["pacman", "-Qu"]
+        (stdout, stderr, rc) = run_command(cmd_update)
+        if rc > 0:
+            raise OperationFailed('KCHPKGUPD0003E', {'err': stderr})
+
+        (stdout, stderr, rc) = run_command(cmd_list)
+        if rc > 0:
+            if not (rc == 1 and len(stdout)==0):
+                raise OperationFailed('KCHPKGUPD0003E', {'err': stderr})
+
+        os.environ['LANG'] = 'C'
+
+        for line in stdout.split('\n'):
+            if line.find('->') >= 0:
+                info = line.split(" ")
+                (sout, serr, ret) = run_command(["pacman", "-Si", info[0]])
+                if len(sout) > 0:
+                    for l in sout.split('\n'):
+                        i = re.split('\s+', l.strip())
+                        if len(i) >= 2:
+                            if i[0] == "Repository":
+                                repo = i[2]
+                            elif i[0] == "Architecture":
+                                arch = i[2]
+                if arch == "any":
+                    arch = "noarch"
+                package = {
+                    'package_name': info[0],
+                    'version': info[3],
+                    'arch': arch,
+                    'repository': repo
+                    }
+                self._pkgs.append(package)
+
+    def getPackagesList(self):
+        """
+        Return a list of package's dictionaries. Each dictionary contains the
+        information about a package, in the format
+        package = {'package_name': <string>, 'version': <string>,
+                   'arch': <string>, 'repository': <string>}
+        """
+        self._refreshUpdateList()
+        return self._pkgs
+
+
