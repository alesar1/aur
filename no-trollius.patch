diff -urb catkin_tools-0.4.4/catkin_tools/common.py catkin_tools-0.4.4/catkin_tools/common.py
--- catkin_tools-0.4.4/catkin_tools/common.py	2017-02-08 13:25:41.000000000 -0500
+++ catkin_tools-0.4.4/catkin_tools/common.py	2018-08-06 14:24:11.800221023 -0400
@@ -20,7 +20,7 @@
 import re
 import sys
 
-import trollius as asyncio
+import asyncio
 
 from shlex import split as _cmd_split
 try:
diff -urb catkin_tools-0.4.4/catkin_tools/execution/executor.py catkin_tools-0.4.4/catkin_tools/execution/executor.py
--- catkin_tools-0.4.4/catkin_tools/execution/executor.py	2017-02-08 13:25:41.000000000 -0500
+++ catkin_tools-0.4.4/catkin_tools/execution/executor.py	2018-08-06 14:43:51.029023552 -0400
@@ -18,7 +18,7 @@
 
 from itertools import tee
 
-import trollius as asyncio
+import asyncio
 
 from concurrent.futures import ThreadPoolExecutor
 from concurrent.futures import FIRST_COMPLETED
@@ -70,7 +70,7 @@
         # Check for stage synchronization lock
         if stage.locked_resource is not None:
             lock = locks.setdefault(stage.locked_resource, asyncio.Lock())
-            yield asyncio.From(lock)
+            yield from(lock)
         else:
             lock = FakeLock()
 
@@ -79,7 +79,7 @@
             if stage.occupy_job:
                 if not occupying_job:
                     while job_server.try_acquire() is None:
-                        yield asyncio.From(asyncio.sleep(0.05))
+                        yield from(asyncio.sleep(0.05))
                     occupying_job = True
             else:
                 if occupying_job:
@@ -103,7 +103,7 @@
                             # Get the logger
                             protocol_type = stage.logger_factory(verb, job.jid, stage.label, event_queue, log_path)
                             # Start asynchroonous execution
-                            transport, logger = yield asyncio.From(
+                            transport, logger = yield from(
                                 async_execute_process(
                                     protocol_type,
                                     **stage.async_execute_process_kwargs))
@@ -112,7 +112,7 @@
                             if 'Text file busy' in str(exc):
                                 # This is a transient error, try again shortly
                                 # TODO: report the file causing the problem (exc.filename)
-                                yield asyncio.From(asyncio.sleep(0.01))
+                                yield from(asyncio.sleep(0.01))
                                 continue
                             raise
 
@@ -125,7 +125,7 @@
                         **stage.async_execute_process_kwargs))
 
                     # Asynchronously yield until this command is  completed
-                    retcode = yield asyncio.From(logger.complete)
+                    retcode = yield from(logger.complete)
                 except:
                     logger = IOBufferLogger(verb, job.jid, stage.label, event_queue, log_path)
                     logger.err(str(traceback.format_exc()))
@@ -135,7 +135,7 @@
                 logger = IOBufferLogger(verb, job.jid, stage.label, event_queue, log_path)
                 try:
                     # Asynchronously yield until this function is completed
-                    retcode = yield asyncio.From(get_loop().run_in_executor(
+                    retcode = yield from(get_loop().run_in_executor(
                         threadpool,
                         stage.function,
                         logger,
@@ -175,7 +175,7 @@
             lock.release()
 
     # Finally, return whether all stages of the job completed
-    raise asyncio.Return(job.jid, all_stages_succeeded)
+    return job.jid, all_stages_succeeded
 
 
 @asyncio.coroutine
@@ -268,14 +268,14 @@
         ))
 
         # Process jobs as they complete asynchronously
-        done_job_fs, active_job_fs = yield asyncio.From(asyncio.wait(
+        done_job_fs, active_job_fs = yield from(asyncio.wait(
             active_job_fs,
             timeout=0.10,
             return_when=FIRST_COMPLETED))
 
         for done_job_f in done_job_fs:
             # Capture a result once the job has finished
-            job_id, succeeded = yield asyncio.From(done_job_f)
+            job_id, succeeded = yield from(done_job_f)
 
             # Release a jobserver token now that this job has succeeded
             job_server.release(job_id)
@@ -358,7 +358,7 @@
         completed=completed_jobs
     ))
 
-    raise asyncio.Return(all(completed_jobs.values()))
+    return all(completed_jobs.values())
 
 
 def run_until_complete(coroutine):
diff -urb catkin_tools-0.4.4/catkin_tools/verbs/catkin_build/build.py catkin_tools-0.4.4/catkin_tools/verbs/catkin_build/build.py
--- catkin_tools-0.4.4/catkin_tools/verbs/catkin_build/build.py	2017-01-05 15:06:28.000000000 -0500
+++ catkin_tools-0.4.4/catkin_tools/verbs/catkin_build/build.py	2018-08-06 14:24:32.433486767 -0400
@@ -22,7 +22,7 @@
 import traceback
 import yaml
 
-import trollius as asyncio
+import asyncio
 
 try:
     # Python3
