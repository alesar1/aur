diff -Naupr ipt-netflow-2.2_orig/compat.h ipt-netflow/compat.h
--- ipt-netflow-2.2_orig/compat.h	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/compat.h	2018-03-11 19:50:52.050634765 +0700
@@ -589,13 +589,85 @@ out:
 # define vlan_tx_tag_present skb_vlan_tag_present
 #endif
 
-/* NF_HOOK is 'define' in old code, but it's function in new code,
- * also, it's function in, supposedly older, kernel version of Centos 7.[01],
- * due to backporing. */
-#if defined(NF_HOOK) || (defined(RHEL_MAJOR) && RHEL_MAJOR == 7 && RHEL_MINOR < 2)
-# define NF_HOOK_COMPAT(a,b,c,d,e,f,g) NF_HOOK(a,b,  d,e,f,g)
-#else /* new kernels */
-# define NF_HOOK_COMPAT NF_HOOK
+#ifndef SPEED_UNKNOWN
+# define SPEED_UNKNOWN		-1
+#endif
+
+#if !defined __GNUC_PREREQ && defined __GNUC__ && defined __GNUC_MINOR__
+# define __GNUC_PREREQ(maj, min) \
+	((__GNUC__ << 16) + __GNUC_MINOR__ >= ((maj) << 16) + (min))
+#else
+# define __GNUC_PREREQ(maj, min) 0
+#endif
+
+/* ktime is not union anymore, since 2456e855354415bfaeb7badaa14e11b3e02c8466 */
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+# define first_tv64	first.tv64
+# define last_tv64	last.tv64
+#else
+# define first_tv64	first
+# define last_tv64	last
+#endif
+
+/* Offset changes made in 613dbd95723aee7abd16860745691b6c7bda20dc */
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28) && LINUX_VERSION_CODE < KERNEL_VERSION(4,10,0)
+# if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
+#  define xt_action_param xt_target_param
+# endif
+static inline u_int8_t xt_family(const struct xt_action_param *par)
+{
+	return par->family;
+}
+static inline const struct net_device *xt_in(const struct xt_action_param *par)
+{
+	return par->in;
+}
+static inline const struct net_device *xt_out(const struct xt_action_param *par)
+{
+	return par->out;
+}
+static inline unsigned int xt_hooknum(const struct xt_action_param *par)
+{
+	return par->hooknum;
+}
+#endif
+
+#ifndef SK_CAN_REUSE
+# define SK_CAN_REUSE   1
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,13,0)
+# define compat_refcount_read atomic_read
+#else
+# define compat_refcount_read refcount_read
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+# define timer_setup setup_timer
+#endif
+
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,15,0)
+static int dev_get_alias(const struct net_device *dev, char *name, size_t len)
+{
+	return snprintf(name, len, "%s", dev->ifalias);
+}
+#else
+/* no static because defined in include/linux/netdevice.h,
+ * but forgot to create EXPORT_SYMBOL,
+ * probably will collide with some future kernel */
+int dev_get_alias(const struct net_device *dev, char *name, size_t len)
+{
+	const struct dev_ifalias *alias;
+	int ret = 0;
+
+	rcu_read_lock();
+	alias = rcu_dereference(dev->ifalias);
+	if (alias)
+		ret = snprintf(name, len, "%s", alias->ifalias);
+	rcu_read_unlock();
+
+	return ret;
+}
 #endif
 
 #endif /* COMPAT_NETFLOW_H */
diff -Naupr ipt-netflow-2.2_orig/configure ipt-netflow/configure
--- ipt-netflow-2.2_orig/configure	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/configure	2018-03-11 19:50:52.050634765 +0700
@@ -152,6 +152,34 @@ iptables_find_version() {
   fi
 }
 
+compiler_presence_test() {
+  echo -n "Check for working gcc: "
+  $CC -v >/dev/null 2>&1
+  if [ $? = 0 ]; then
+    echo Yes "($CC)"
+  else
+    echo No
+
+    echo "! You need gcc to install module from source"
+    if [ -s /etc/debian_version ]; then
+      NAME=Debian
+      if [ -e /etc/os-release ]; then
+	. /etc/os-release >/dev/null 2>&1
+      fi
+      echo "! "
+      echo "! Under $NAME try to run this:"
+      echo "!   root# apt-get install gcc"
+      echo "! "
+    elif [ -s /etc/redhat-release ]; then
+      echo "! "
+      echo "! Under Centos try to run this:"
+      echo "!   root# yum install gcc"
+      echo "! "
+    fi
+    exit 1
+  fi
+}
+
 compile_libitp_test() {
   local FLAGS
   local MSG
@@ -169,7 +197,7 @@ compile_libitp_test() {
   echo "
 #define __EXPORTED_HEADERS__
 #include <$*>" > test.c
-  gcc -c test.c $FLAGS >/dev/null 2>&1
+  $CC -c test.c $FLAGS >/dev/null 2>&1
   RET=$?
   if [ $RET = 0 ]; then
     echo Yes $MSG;
@@ -211,6 +239,7 @@ iptables_try_pkgconfig() {
     # and if not, then it's older who need it.
     IPTCFLAGS="-I$KDIR/include -DIPTABLES_VERSION=\\\\\"$IPTVER\\\\\""
   fi
+  compiler_presence_test
   if compile_libitp_test xtables.h; then
     IPTCFLAGS="-DXTABLES $IPTCFLAGS"
   elif ! compile_libitp_test iptables.h; then
@@ -306,13 +335,13 @@ do
     --enable-aggr*)  KOPTS="$KOPTS -DENABLE_AGGR" ;;
     --enable-promi*)   ENABLE_PROMISC=1 ;;
     --promisc-mpls*)   ENABLE_PROMISC=1; PROMISC_MPLS=1; MPLS_DEPTH=${ac_optarg:-3} ;;
-    --enable-snmp-r*)  KOPTS="$KOPTS -DENABLE_SNMP" ;;
+    --enable-snmp-r*)  KOPTS="$KOPTS -DSNMP_RULES" ;;
     --enable-physdev)       KOPTS="$KOPTS -DENABLE_PHYSDEV" ;;
     --enable-physdev-over*) KOPTS="$KOPTS -DENABLE_PHYSDEV_OVER" ;;
     --disable-snmp-a*)   SKIPSNMP=1 ;;
     --disable-net-snmp*) SKIPSNMP=1 ;;
     --disable-dkms*)     SKIPDKMS=1 ;;
-    --from-dkms-conf) ;;
+    --from-dkms-conf*) ;;
     --make) echo called from make; CARGS=`echo $CARGS | sed s/--make//g` ;;
     -Werror) KOPTS="$KOPTS -Werror" ;;
     --help|-h) show_help ;;
@@ -564,6 +593,7 @@ kernel_check_consistency
 kernel_check_config
 kernel_check_features
 
+CC=${CC:-gcc}
 test "$IPTBIN" || IPTBIN=`which iptables`
 
 iptables_find_version	#IPTVER
diff -Naupr ipt-netflow-2.2_orig/CREDITS ipt-netflow/CREDITS
--- ipt-netflow-2.2_orig/CREDITS	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/CREDITS	2018-03-11 19:50:52.049634760 +0700
@@ -67,17 +67,20 @@ Patch authors and submitters:
    uropek [2013]
    shaman [2013]
    Jeremy Drake [2013]
+   Matthew Martin [2016] DKMS fixes
+   alex-eri [2016, 2017] OpenWRT compatibility
 
 
 Reference or prototype code authors:
 
-   Valentin V. Yankin [2011]
+   Valentin V. Yankin [2011] SNMP-index
 
 
 Project supporters:
 
    Summa Telecom [2014]
    Starlink [2014]
+   Anonymous
 
 
 Extensive testing and other help:
diff -Naupr ipt-netflow-2.2_orig/ipt_NETFLOW.c ipt-netflow/ipt_NETFLOW.c
--- ipt-netflow-2.2_orig/ipt_NETFLOW.c	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/ipt_NETFLOW.c	2018-03-11 19:50:52.052634775 +0700
@@ -209,6 +209,10 @@ MODULE_PARM_DESC(maxflows, "maximum numb
 static int peakflows = 0;
 static unsigned long peakflows_at; /* jfffies */
 
+static int engine_id = 0;
+module_param(engine_id, int, 0644);
+MODULE_PARM_DESC(engine_id, "Observation Domain ID");
+
 #ifdef ENABLE_AGGR
 #define AGGR_SIZE 1024
 static char aggregation_buf[AGGR_SIZE] = "";
@@ -271,7 +275,6 @@ static union {
 	struct netflow9_pdu v9;
 	struct ipfix_pdu ipfix;
 } pdu;
-static int engine_id = 0; /* Observation Domain */
 static __u8 *pdu_data_used;
 static __u8 *pdu_high_wm; /* high watermark */
 static struct flowset_data *pdu_flowset = NULL; /* current data flowset */
@@ -466,6 +469,42 @@ static char *print_sockaddr(const struct
 	return snprintf_sockaddr(buf, sizeof(buf), ss);
 }
 
+static int is_zero_addr(const struct sockaddr_storage *ss)
+{
+	if (ss->ss_family == AF_INET)
+		return ((const struct sockaddr_in *)ss)->sin_addr.s_addr == 0;
+	else if (ss->ss_family == AF_INET6)
+		return  ((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[0] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[1] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[2] == 0 &&
+			((const struct sockaddr_in6 *)ss)->sin6_addr.s6_addr32[3] == 0;
+	else /* AF_UNSPEC */
+		return 1;
+}
+
+static char *print_usock_addr(struct ipt_netflow_sock *usock)
+{
+	static char buf[128];
+	size_t len;
+
+	snprintf(buf, sizeof(buf), "%s", print_sockaddr(&usock->addr));
+
+	if (!is_zero_addr(&usock->saddr)) {
+		len = strlen(buf);
+		snprintf(buf + len, sizeof(buf) - len, "@%s",
+		    print_sockaddr(&usock->saddr));
+		len = strlen(buf);
+		/* strip zero port */
+		if (len > 2 && buf[len - 1] == '0' && buf[len - 2] == ':')
+			buf[len - 2] = '\0';
+	}
+	if (usock->sdev[0]) {
+		len = strlen(buf);
+		snprintf(buf + len, sizeof(buf) - len, "%%%s", usock->sdev);
+	}
+	return buf;
+}
+
 #ifdef CONFIG_PROC_FS
 static inline int ABS(int x) { return x >= 0 ? x : -x; }
 #define SAFEDIV(x,y) ((y)? ({ u64 __tmp = x; do_div(__tmp, y); (int)__tmp; }) : 0)
@@ -572,7 +611,7 @@ static int snmp_seq_show(struct seq_file
 			sndbuf_peak = wmem_peak;
 		seq_printf(seq, "sock%d %s %d %u %u %u %u",
 		    snum,
-		    print_sockaddr(&usock->addr),
+		    print_usock_addr(usock),
 		    !!usock->sock,
 		    usock->err_connect,
 		    usock->err_full,
@@ -583,7 +622,7 @@ static int snmp_seq_show(struct seq_file
 
 			seq_printf(seq, " %u %u %u\n",
 			    sk->sk_sndbuf,
-			    atomic_read(&sk->sk_wmem_alloc),
+			    compat_refcount_read(&sk->sk_wmem_alloc),
 			    wmem_peak);
 		} else
 			seq_printf(seq, " 0 0 %u\n", wmem_peak);
@@ -818,14 +857,14 @@ static int nf_seq_show(struct seq_file *
 	list_for_each_entry(usock, &usock_list, list) {
 		seq_printf(seq, "sock%d: %s",
 		    snum,
-		    print_sockaddr(&usock->addr));
+		    print_usock_addr(usock));
 		if (usock->sock) {
 			struct sock *sk = usock->sock->sk;
 
 			seq_printf(seq, ", sndbuf %u, filled %u, peak %u;"
 			    " err: sndbuf reached %u, connect %u, cberr %u, other %u\n",
 			    sk->sk_sndbuf,
-			    atomic_read(&sk->sk_wmem_alloc),
+			    compat_refcount_read(&sk->sk_wmem_alloc),
 			    atomic_read(&usock->wmem_peak),
 			    usock->err_full,
 			    usock->err_connect,
@@ -1073,9 +1112,7 @@ static int flows_dump_seq_show(struct se
 #ifdef SNMP_RULES
 	seq_printf(seq, " %hd,%hd",
 	    nf->i_ifcr,
-	    nf->o_ifcr,
-	    nf->tuple.i_ifc,
-	    nf->o_ifc);
+	    nf->o_ifcr);
 #endif
 #ifdef ENABLE_MAC
 	seq_printf(seq, " %pM,%pM", &nf->tuple.h_src, &nf->tuple.h_dst);
@@ -1216,11 +1253,14 @@ static int promisc4_rcv(struct sk_buff *
 	memset(IPCB(skb), 0, sizeof(struct inet_skb_parm));
 	skb_orphan(skb);
 
-	return NF_HOOK_COMPAT(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
+	return NF_HOOK(NFPROTO_IPV4, NF_INET_PRE_ROUTING,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,0)
 	    dev_net(dev),
 #endif
-	    NULL, skb, dev, NULL, promisc_finish);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0) || (defined(RHEL_MAJOR) && RHEL_MAJOR == 7 && RHEL_MINOR > 1)
+	    NULL,
+#endif
+	    skb, dev, NULL, promisc_finish);
 drop:
 	NETFLOW_STAT_INC(pkt_promisc_drop);
 	kfree_skb(skb);
@@ -1288,11 +1328,14 @@ static int promisc6_rcv(struct sk_buff *
 	rcu_read_unlock();
 	skb_orphan(skb);
 
-	return NF_HOOK_COMPAT(NFPROTO_IPV6, NF_INET_PRE_ROUTING,
+	return NF_HOOK(NFPROTO_IPV6, NF_INET_PRE_ROUTING,
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(4,4,0)
 	    dev_net(dev),
 #endif
-	    NULL, skb, dev, NULL, promisc_finish);
+#if LINUX_VERSION_CODE >= KERNEL_VERSION(4,1,0) || (defined(RHEL_MAJOR) && RHEL_MAJOR == 7 && RHEL_MINOR > 1)
+	    NULL,
+#endif
+	    skb, dev, NULL, promisc_finish);
 drop:
 	rcu_read_unlock();
 	NETFLOW_STAT_INC(pkt_promisc_drop);
@@ -1879,24 +1922,50 @@ static void sk_error_report(struct sock
 	return;
 }
 
-static struct socket *usock_open_sock(const struct sockaddr_storage *addr, void *user_data)
+static struct socket *usock_open_sock(struct ipt_netflow_sock *usock)
 {
 	struct socket *sock;
 	int error;
+	int salen = 0;
 
-	if ((error = sock_create_kern(addr->ss_family, SOCK_DGRAM, IPPROTO_UDP, &sock)) < 0) {
+	if ((error = sock_create_kern(usock->addr.ss_family, SOCK_DGRAM, IPPROTO_UDP, &sock)) < 0) {
 		printk(KERN_ERR "ipt_NETFLOW: sock_create_kern error %d\n", -error);
 		return NULL;
 	}
 	sock->sk->sk_allocation = GFP_ATOMIC;
 	sock->sk->sk_prot->unhash(sock->sk); /* hidden from input */
 	sock->sk->sk_error_report = &sk_error_report; /* clear ECONNREFUSED */
-	sock->sk->sk_user_data = user_data; /* usock */
+	sock->sk->sk_user_data = usock;
+	sock->sk->sk_reuse = SK_CAN_REUSE;
+
+	if (usock->sdev[0]) {
+		struct net_device *dev = dev_get_by_name(&init_net, usock->sdev);
+
+		if (dev) {
+			sock->sk->sk_bound_dev_if = dev->ifindex;
+			dev_put(dev);
+		} else {
+			printk(KERN_ERR "ipt_NETFLOW: error binding to device %s, errno %d\n",
+			    usock->sdev, -error);
+			return NULL;
+		}
+	}
+	if (!is_zero_addr(&usock->saddr)) {
+		if (usock->saddr.ss_family == AF_INET)
+			salen = sizeof(struct sockaddr_in);
+		else if (usock->saddr.ss_family == AF_INET6)
+			salen = sizeof(struct sockaddr_in6);
+		if ((error = sock->ops->bind(sock, (struct sockaddr *)&usock->saddr, salen)) < 0) {
+			printk(KERN_ERR "ipt_NETFLOW: error binding socket %d\n", -error);
+			return NULL;
+		}
+	}
+
 	if (sndbuf)
 		sock->sk->sk_sndbuf = sndbuf;
 	else
 		sndbuf = sock->sk->sk_sndbuf;
-	error = sock->ops->connect(sock, (struct sockaddr *)addr, sizeof(*addr), 0);
+	error = sock->ops->connect(sock, (struct sockaddr *)&usock->addr, sizeof(usock->addr), 0);
 	if (error < 0) {
 		printk(KERN_ERR "ipt_NETFLOW: error connecting UDP socket %d,"
 		    " don't worry, will try reconnect later.\n", -error);
@@ -1909,7 +1978,7 @@ static struct socket *usock_open_sock(co
 
 static void usock_connect(struct ipt_netflow_sock *usock, const int sendmsg)
 {
-	usock->sock = usock_open_sock(&usock->addr, usock);
+	usock->sock = usock_open_sock(usock);
 	if (usock->sock) {
 		if (sendmsg || debug)
 			printk(KERN_INFO "ipt_NETFLOW: connected %s\n",
@@ -1960,7 +2029,7 @@ static void netflow_sendmsg(void *buffer
 			printk(KERN_INFO "netflow_sendmsg: sendmsg(%d, %d) [%u %u]\n",
 			       snum,
 			       len,
-			       atomic_read(&usock->sock->sk->sk_wmem_alloc),
+			       compat_refcount_read(&usock->sock->sk->sk_wmem_alloc),
 			       usock->sock->sk->sk_sndbuf);
 		ret = kernel_sendmsg(usock->sock, &msg, &iov, 1, (size_t)len);
 		if (ret < 0) {
@@ -1983,7 +2052,7 @@ static void netflow_sendmsg(void *buffer
 			printk(KERN_ERR "ipt_NETFLOW: sendmsg[%d] error %d: data loss %llu pkt, %llu bytes%s\n",
 			       snum, ret, pdu_packets, pdu_traf, suggestion);
 		} else {
-			unsigned int wmem = atomic_read(&usock->sock->sk->sk_wmem_alloc);
+			unsigned int wmem = compat_refcount_read(&usock->sock->sk->sk_wmem_alloc);
 			if (wmem > atomic_read(&usock->wmem_peak))
 				atomic_set(&usock->wmem_peak, wmem);
 			NETFLOW_STAT_INC(exported_pkt);
@@ -2043,7 +2112,7 @@ static void add_usock(struct ipt_netflow
 	}
 	list_add_tail(&usock->list, &usock_list);
 	printk(KERN_INFO "ipt_NETFLOW: added destination %s%s\n",
-	       print_sockaddr(&usock->addr),
+	       print_usock_addr(usock),
 	       (!usock->sock)? " (unconnected)" : "");
 	mutex_unlock(&sock_lock);
 }
@@ -2239,9 +2308,11 @@ static int add_destinations(const char *
 
 	for (; ptr; ptr += len) {
 		struct sockaddr_storage ss;
+		struct sockaddr_storage sbind = {};
 		struct ipt_netflow_sock *usock;
 		const char *end;
 		int succ = 0;
+		char name[IFNAMSIZ] = { 0 };
 
 		/* skip initial separators */
 		ptr += strspn(ptr, SEPARATORS);
@@ -2253,6 +2324,7 @@ static int add_destinations(const char *
 
 		if (strncount(ptr, len, ':') >= 2) {
 			struct sockaddr_in6 *sin6 = (struct sockaddr_in6 *)&ss;
+			struct sockaddr_in6 *sout = (struct sockaddr_in6 *)&sbind;
 			const char *c = ptr;
 			int clen = len;
 
@@ -2267,15 +2339,32 @@ static int add_destinations(const char *
 				++end;
 			if (succ &&
 			    (*end == ':' || *end == '.' || *end == 'p' || *end == '#'))
-				sin6->sin6_port = htons(simple_strtoul(++end, NULL, 0));
+				sin6->sin6_port = htons(simple_strtoul(++end, (char **)&end, 0));
+			if (succ && *end == '@') {
+				++end;
+				sout->sin6_family = AF_INET6;
+				sout->sin6_port   = 0;
+				succ = in6_pton(end, strcspn(end, SEPARATORS), (u8 *)&sout->sin6_addr, -1, &end);
+			}
 		} else {
-			struct sockaddr_in *sin = (struct sockaddr_in *)&ss;
+			struct sockaddr_in *sin  = (struct sockaddr_in *)&ss;
+			struct sockaddr_in *sout = (struct sockaddr_in *)&sbind;
 
 			sin->sin_family = AF_INET;
 			sin->sin_port = htons(2055);
 			succ = in4_pton(ptr, len, (u8 *)&sin->sin_addr, -1, &end);
 			if (succ && *end == ':')
-				sin->sin_port = htons(simple_strtoul(++end, NULL, 0));
+				sin->sin_port = htons(simple_strtoul(++end, (char **)&end, 0));
+			if (succ && *end == '@') {
+				++end;
+				sout->sin_family = AF_INET;
+				sout->sin_port   = 0;
+				succ = in4_pton(end, strcspn(end, SEPARATORS), (u8 *)&sout->sin_addr, -1, &end);
+			}
+		}
+		if (succ && *end == '%') {
+			++end;
+			snprintf(name, sizeof(name), "%.*s", (int)strcspn(end, SEPARATORS), end);
 		}
 		if (!succ) {
 			printk(KERN_ERR "ipt_NETFLOW: can't parse destination: %.*s\n",
@@ -2288,7 +2377,9 @@ static int add_destinations(const char *
 			return -ENOMEM;
 		}
 		memset(usock, 0, sizeof(*usock));
-		usock->addr = ss;
+		usock->addr  = ss;
+		usock->saddr = sbind;
+		memcpy(usock->sdev, name, sizeof(usock->sdev));
 		usock_connect(usock, 0);
 		add_usock(usock);
 	}
@@ -2532,7 +2623,7 @@ static void netflow_export_pdu_v5(void)
 	pdu.v5.ts_unsecs	= htonl(tv.tv_usec);
 	pdu.v5.seq		= htonl(pdu_seq);
 	//pdu.v5.eng_type	= 0;
-	pdu.v5.eng_id		= engine_id;
+	pdu.v5.eng_id		= (__u8)engine_id;
 #ifdef ENABLE_SAMPLER
 	pdu.v5.sampling		= htons(sampler_nf_v5());
 #endif
@@ -2615,7 +2706,7 @@ static void netflow_export_pdu_v9(void)
 	do_gettimeofday(&tv);
 	pdu.v9.export_time_s	= htonl(tv.tv_sec);
 	pdu.v9.seq		= htonl(pdu_seq);
-	pdu.v9.source_id	= engine_id;
+	pdu.v9.source_id	= htonl(engine_id);
 
 	pdusize = pdu_data_used - (unsigned char *)&pdu.v9;
 
@@ -2647,7 +2738,7 @@ static void netflow_export_pdu_ipfix(voi
 	do_gettimeofday(&tv);
 	pdu.ipfix.export_time_s	= htonl(tv.tv_sec);
 	pdu.ipfix.seq		= htonl(pdu_seq);
-	pdu.ipfix.odomain_id	= engine_id;
+	pdu.ipfix.odomain_id	= htonl(engine_id);
 	pdusize = pdu_data_used - (unsigned char *)&pdu;
 	pdu.ipfix.length	= htons(pdusize);
 
@@ -3285,15 +3376,15 @@ static u_int16_t scope_ipfix_to_v9(const
 	case observationDomainId:
 	case meteringProcessId:
 	case exportingProcessId:
-		return SCOPE_SYSTEM;
+		return V9_SCOPE_SYSTEM;
 	case ingressInterface:
 	case portId:
-		return SCOPE_INTERFACE;
+		return V9_SCOPE_INTERFACE;
 	case observationPointId:
 	case LineCardId:
-		return SCOPE_LINECARD;
+		return V9_SCOPE_LINECARD;
 	case TemplateId:
-		return SCOPE_TEMPLATE;
+		return V9_SCOPE_TEMPLATE;
 	default:
 		return -1;
 	}
@@ -3463,8 +3554,10 @@ static inline void add_tpl_field(__u8 *p
 	case sourceMacAddress:	    memcpy(ptr, &nf->tuple.h_src, ETH_ALEN); break;
 #endif
 #ifdef MPLS_DEPTH
-# pragma GCC diagnostic push
-# pragma GCC diagnostic ignored "-Warray-bounds"
+# if __GNUC_PREREQ(4,6)
+#  pragma GCC diagnostic push
+#  pragma GCC diagnostic ignored "-Warray-bounds"
+# endif
 	case MPLS_LABEL_1:    memcpy(ptr, &nf->tuple.mpls[0], 3); break;
 	case MPLS_LABEL_2:    memcpy(ptr, &nf->tuple.mpls[1], 3); break;
 	case MPLS_LABEL_3:    memcpy(ptr, &nf->tuple.mpls[2], 3); break;
@@ -3477,7 +3570,9 @@ static inline void add_tpl_field(__u8 *p
 	case MPLS_LABEL_9:    memcpy(ptr, &nf->tuple.mpls[8], 3); break;
 	case MPLS_LABEL_10:   memcpy(ptr, &nf->tuple.mpls[9], 3); break;
 # endif
-# pragma GCC diagnostic pop
+# if __GNUC_PREREQ(4,6)
+#  pragma GCC diagnostic pop
+# endif
 	case mplsTopLabelTTL: *ptr = ntohl(nf->tuple.mpls[0]); break;
 #endif
 #ifdef ENABLE_DIRECTION
@@ -3850,10 +3945,10 @@ static void netflow_export_stats(void)
 		t.pkts_selected	+= st->pkts_selected;
 		t.pkts_observed	+= st->pkts_observed;
 #endif
-		t.drop.first.tv64 = min_not_zero(t.drop.first.tv64, st->drop.first.tv64);
-		t.drop.last.tv64  = max(t.drop.last.tv64, st->drop.last.tv64);
-		t.lost.first.tv64 = min_not_zero(t.lost.first.tv64, st->lost.first.tv64);
-		t.lost.last.tv64  = max(t.lost.last.tv64, st->lost.last.tv64);
+		t.drop.first_tv64 = min_not_zero(t.drop.first_tv64, st->drop.first_tv64);
+		t.drop.last_tv64  = max(t.drop.last_tv64, st->drop.last_tv64);
+		t.lost.first_tv64 = min_not_zero(t.lost.first_tv64, st->lost.first_tv64);
+		t.lost.last_tv64  = max(t.lost.last_tv64, st->lost.last_tv64);
 	}
 
 	export_stat_st(OTPL_MPSTAT, &t);
@@ -3904,7 +3999,13 @@ static int ethtool_drvinfo(unsigned char
 {
 	struct ethtool_drvinfo info = { 0 };
 	const struct ethtool_ops *ops = dev->ethtool_ops;
+#ifndef ETHTOOL_GLINKSETTINGS
 	struct ethtool_cmd ecmd;
+#define _KSETTINGS(x, y) (x)
+#else
+	struct ethtool_link_ksettings ekmd;
+#define _KSETTINGS(x, y) (y)
+#endif
 	int len = size;
 	int n;
 
@@ -3933,19 +4034,19 @@ static int ethtool_drvinfo(unsigned char
 	/* only get_settings for running devices to not trigger link negotiation */
 	if (dev->flags & IFF_UP &&
 	    dev->flags & IFF_RUNNING &&
-	    !__ethtool_get_settings(dev, &ecmd)) {
-		char *s, *p;
-
-		/* append basic parameters: speed and port */
-		switch (ethtool_cmd_speed(&ecmd)) {
-		case SPEED_10000: s = "10Gb"; break;
-		case SPEED_2500:  s = "2.5Gb"; break;
-		case SPEED_1000:  s = "1Gb"; break;
-		case SPEED_100:   s = "100Mb"; break;
-		case SPEED_10:    s = "10Mb"; break;
-		default:          s = "";
+	    !_KSETTINGS(__ethtool_get_settings(dev, &ecmd), __ethtool_get_link_ksettings(dev, &ekmd))) {
+		char *units, *p;
+		__u32 speed = _KSETTINGS(ethtool_cmd_speed(&ecmd), ekmd.base.speed);
+
+		if (speed == SPEED_UNKNOWN)
+			units = "";
+		else if (speed <= 1000)
+			units = "MbE";
+		else {
+			speed /= 1000;
+			units = "GbE";
 		}
-		switch (ecmd.port) {
+		switch (_KSETTINGS(ecmd.port, ekmd.base.port)) {
 		case PORT_TP:     p = "tp"; break;
 		case PORT_AUI:    p = "aui"; break;
 		case PORT_MII:    p = "mii"; break;
@@ -3956,7 +4057,7 @@ static int ethtool_drvinfo(unsigned char
 #endif
 		default:          p = "";
 		}
-		n = scnprintf(ptr, len, ",%s,%s", s, p);
+		n = scnprintf(ptr, len, ",%d%s,%s", speed, units, p);
 		len -= n;
 	}
 ret:
@@ -3964,6 +4065,7 @@ ret:
 		ops->complete(dev);
 	return size - len;
 }
+#undef _KSETTINGS
 
 static const unsigned short netdev_type[] =
 {ARPHRD_NETROM, ARPHRD_ETHER, ARPHRD_AX25,
@@ -4039,9 +4141,11 @@ static void export_dev(struct net_device
 			 * then ethtool driver name with basic info,
 			 * finally net_device.type is a last resort */
 #if LINUX_VERSION_CODE >= KERNEL_VERSION(2,6,28)
-			if (dev->ifalias)
-				n = scnprintf(ptr, size, "%s", dev->ifalias);
-			else
+			if (dev->ifalias) {
+				n = dev_get_alias(dev, ptr, size);
+				if (n >= size)
+					n = size - 1;
+			} else
 #endif
 				n = ethtool_drvinfo(ptr, size, dev);
 			if (!n)
@@ -4350,7 +4454,13 @@ static void netflow_work_fn(struct work_
 #define CALC_RATE(ewma, cur, minutes) ewma += _A(cur - ewma, minutes)
 
 // calculate EWMA throughput rate for whole module
-static void rate_timer_calc(unsigned long dummy)
+static void rate_timer_calc(
+#if LINUX_VERSION_CODE < KERNEL_VERSION(4,14,0)
+    unsigned long dummy
+#else
+    struct timer_list *t
+#endif
+    )
 {
 	static u64 old_pkt_total = 0;
 	static u64 old_traf_total = 0;
@@ -4761,8 +4871,8 @@ static unsigned int netflow_target(
 			   const void *targinfo
 # endif
 #else /* since 2.6.28 */
-# define if_in  par->in
-# define if_out par->out
+# define if_in  xt_in(par)
+# define if_out xt_out(par)
 # if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,35)
 			   const struct xt_target_param *par
 # else
@@ -4786,10 +4896,10 @@ static unsigned int netflow_target(
 #if LINUX_VERSION_CODE < KERNEL_VERSION(2,6,28)
 	const int family = target->family;
 #else
-#ifdef ENABLE_DIRECTION
-	const int hooknum = par->hooknum;
-#endif
-	const int family = par->family;
+# ifdef ENABLE_DIRECTION
+	const int hooknum = xt_hooknum(par);
+# endif
+	const int family = xt_family(par);
 #endif
 	struct ipt_netflow_tuple tuple;
 	struct ipt_netflow *nf;
@@ -5518,7 +5628,7 @@ static int __init ipt_netflow_init(void)
 
 	netflow_switch_version(protocol);
 	_schedule_scan_worker(0);
-	setup_timer(&rate_timer, rate_timer_calc, 0);
+	timer_setup(&rate_timer, rate_timer_calc, 0);
 	mod_timer(&rate_timer, jiffies + (HZ * SAMPLERATE));
 
 	peakflows_at = jiffies;
diff -Naupr ipt-netflow-2.2_orig/ipt_NETFLOW.h ipt-netflow/ipt_NETFLOW.h
--- ipt-netflow-2.2_orig/ipt_NETFLOW.h	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/ipt_NETFLOW.h	2018-03-11 19:50:52.052634775 +0700
@@ -194,11 +194,11 @@ enum {
 };
 
 enum {				/* v9 scopes */
-	SCOPE_SYSTEM = 1,
-	SCOPE_INTERFACE = 2,
-	SCOPE_LINECARD = 3,
-	SCOPE_CACHE = 4,
-	SCOPE_TEMPLATE = 5,
+	V9_SCOPE_SYSTEM = 1,
+	V9_SCOPE_INTERFACE = 2,
+	V9_SCOPE_LINECARD = 3,
+	V9_SCOPE_CACHE = 4,
+	V9_SCOPE_TEMPLATE = 5,
 };
 
 struct flowset_template {
@@ -378,6 +378,8 @@ struct ipt_netflow_sock {
 	struct list_head list;
 	struct socket *sock;
 	struct sockaddr_storage addr;	// destination
+	struct sockaddr_storage saddr;	// source
+	char   sdev[IFNAMSIZ];		// source device
 	atomic_t wmem_peak;		// sk_wmem_alloc peak value
 	unsigned int err_connect;	// connect errors
 	unsigned int err_full;		// socket filled error
@@ -414,7 +416,7 @@ struct netflow_aggr_p {
 #define NETFLOW_STAT_TS(count)							 \
 	do {									 \
 		ktime_t kts = ktime_get_real();					 \
-		if (!(__get_cpu_var(ipt_netflow_stat)).count.first.tv64)	 \
+		if (!(__get_cpu_var(ipt_netflow_stat)).count.first_tv64)	 \
 			__get_cpu_var(ipt_netflow_stat).count.first = kts;	 \
 		__get_cpu_var(ipt_netflow_stat).count.last = kts;		 \
 	} while (0);
diff -Naupr ipt-netflow-2.2_orig/Makefile.in ipt-netflow/Makefile.in
--- ipt-netflow-2.2_orig/Makefile.in	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/Makefile.in	2018-03-11 19:50:52.049634760 +0700
@@ -64,10 +64,10 @@ sinstall: | snmp_NETFLOW.so IPT-NETFLOW-
 	fi
 
 %_sh.o: libipt_NETFLOW.c
-	gcc -O2 -Wall -Wunused $(IPTABLES_CFLAGS) -fPIC -o $@ -c libipt_NETFLOW.c
+	$(CC) $(CFLAGS) -O2 -Wall -Wunused $(IPTABLES_CFLAGS) -fPIC -o $@ -c libipt_NETFLOW.c
 
 %.so: %_sh.o
-	gcc -shared -o $@ $<
+	$(CC) -shared -o $@ $<
 
 version.h: ipt_NETFLOW.c ipt_NETFLOW.h compat.h Makefile
 	@./version.sh --define > version.h
diff -Naupr ipt-netflow-2.2_orig/README ipt-netflow/README
--- ipt-netflow-2.2_orig/README	2016-02-21 20:24:29.000000000 +0600
+++ ipt-netflow/README	2018-03-11 19:50:52.050634765 +0700
@@ -224,11 +224,6 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
      --enable-aggregation
          enables aggregation rules. Read below for explanation of aggregation.
 
-     --enable-debugfs
-         enabled debugfs interface to active flows list. NB! This is for debug
-         purposes only. cat /sys/kernel/debug/netflow_dump to see all currently
-         accouned flows.
-
      --disable-dkms
          disable creating dkms.conf and auto-install module into DKMS tree.
 
@@ -276,6 +271,7 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
 2. Statistics is in /proc/net/stat/ipt_netflow
    Machine readable statistics is in /proc/net/stat/ipt_netflow_snmp
    To view boring slab statistics: grep ipt_netflow /proc/slabinfo
+   Dump of all flows is in /proc/net/stat/ipt_netflow_flows
 
 3. You can view parameters and control them via sysctl, example:
 
@@ -422,6 +418,12 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
      - mirror flows to two (can be more) addresses, separate addresses
        with comma.
 
+   destination=127.0.0.1:2055@127.0.0.2
+     - bind socket to address (127.0.0.2).
+
+   destination=127.0.0.1:2055%eth0
+     - bind socket to interface (eth0). May be useful for multi-homed boxes.
+
    sampler=deterministic:123
    sampler=random:123
    sampler=hash:123
@@ -572,10 +574,21 @@ ipt_NETFLOW linux 2.6.x-4.x kernel modul
        desirable to combine it with packet processing on very highly loaded
        routers.
 
-       This option also could be changed at runtime with: 
+       This option could be changed at runtime with:
 
          # echo number > /sys/module/ipt_NETFLOW/parameters/exportcpu
 
+   engine_id=number
+     - Observation Domain ID (on IPFIX, Source Id on NetFlow v9, or Engine Id
+       on NetFlow v5) value to be exported. This may help your collector to
+       distinguish between multiple exporters. On Netflow v9 and IPFIX this
+       value is 32-bit on NetFlow v5 only 8 low bits are significant.
+       Default value is 0.
+
+       This option could be changed at runtime with:
+
+         # echo number > /sys/module/ipt_NETFLOW/parameters/engine_id
+
 
 ====================
 = HOW TO READ STAT =
