From 293676c476733e81d7b596736add6cd510eb6960 Mon Sep 17 00:00:00 2001
From: =?utf8?q?Martin=20Storsj=C3=B6?= <martin@martin.st>
Date: Fri, 8 Jul 2016 23:21:41 +0300
Subject: [PATCH] libopenh264: Support building with the 1.6 release
MIME-Version: 1.0
Content-Type: text/plain; charset=utf8
Content-Transfer-Encoding: 8bit

This fixes trac issue #5417.

This is cherry-picked from libav commit
d825b1a5306576dcd0553b7d0d24a3a46ad92864.

Signed-off-by: Martin StorsjÃ¶ <martin@martin.st>
---
 libavcodec/libopenh264dec.c |  2 ++
 libavcodec/libopenh264enc.c | 26 ++++++++++++++++++++++++--
 2 files changed, 26 insertions(+), 2 deletions(-)

diff --git a/libavcodec/libopenh264dec.c b/libavcodec/libopenh264dec.c
index f642082..6af60af 100644
--- a/libavcodec/libopenh264dec.c
+++ b/libavcodec/libopenh264dec.c
@@ -90,7 +90,9 @@ static av_cold int svc_decode_init(AVCodecContext *avctx)
     (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK, (void *)&callback_function);
     (*s->decoder)->SetOption(s->decoder, DECODER_OPTION_TRACE_CALLBACK_CONTEXT, (void *)&avctx);
 
+#if !OPENH264_VER_AT_LEAST(1, 6)
     param.eOutputColorFormat = videoFormatI420;
+#endif
     param.eEcActiveIdc       = ERROR_CON_DISABLE;
     param.sVideoProperty.eVideoBsType = VIDEO_BITSTREAM_DEFAULT;
 
diff --git a/libavcodec/libopenh264enc.c b/libavcodec/libopenh264enc.c
index d27fc41..07af31d 100644
--- a/libavcodec/libopenh264enc.c
+++ b/libavcodec/libopenh264enc.c
@@ -33,6 +33,10 @@
 #include "internal.h"
 #include "libopenh264.h"
 
+#if !OPENH264_VER_AT_LEAST(1, 6)
+#define SM_SIZELIMITED_SLICE SM_DYN_SLICE
+#endif
+
 typedef struct SVCContext {
     const AVClass *av_class;
     ISVCEncoder *encoder;
@@ -48,11 +52,20 @@ typedef struct SVCContext {
 #define OFFSET(x) offsetof(SVCContext, x)
 #define VE AV_OPT_FLAG_VIDEO_PARAM | AV_OPT_FLAG_ENCODING_PARAM
 static const AVOption options[] = {
+#if OPENH264_VER_AT_LEAST(1, 6)
+    { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_FIXEDSLCNUM_SLICE }, SM_SINGLE_SLICE, SM_RESERVED, VE, "slice_mode" },
+#else
     { "slice_mode", "set slice mode", OFFSET(slice_mode), AV_OPT_TYPE_INT, { .i64 = SM_AUTO_SLICE }, SM_SINGLE_SLICE, SM_RESERVED, VE, "slice_mode" },
+#endif
         { "fixed", "a fixed number of slices", 0, AV_OPT_TYPE_CONST, { .i64 = SM_FIXEDSLCNUM_SLICE }, 0, 0, VE, "slice_mode" },
+#if OPENH264_VER_AT_LEAST(1, 6)
+        { "dyn", "Size limited (compatibility name)", 0, AV_OPT_TYPE_CONST, { .i64 = SM_SIZELIMITED_SLICE }, 0, 0, VE, "slice_mode" },
+        { "sizelimited", "Size limited", 0, AV_OPT_TYPE_CONST, { .i64 = SM_SIZELIMITED_SLICE }, 0, 0, VE, "slice_mode" },
+#else
         { "rowmb", "one slice per row of macroblocks", 0, AV_OPT_TYPE_CONST, { .i64 = SM_ROWMB_SLICE }, 0, 0, VE, "slice_mode" },
         { "auto", "automatic number of slices according to number of threads", 0, AV_OPT_TYPE_CONST, { .i64 = SM_AUTO_SLICE }, 0, 0, VE, "slice_mode" },
         { "dyn", "Dynamic slicing", 0, AV_OPT_TYPE_CONST, { .i64 = SM_DYN_SLICE }, 0, 0, VE, "slice_mode" },
+#endif
     { "loopfilter", "enable loop filter", OFFSET(loopfilter), AV_OPT_TYPE_INT, { .i64 = 1 }, 0, 1, VE },
     { "profile", "set profile restrictions", OFFSET(profile), AV_OPT_TYPE_STRING, { .str = NULL }, 0, 0, VE },
     { "max_nal_size", "set maximum NAL size in bytes", OFFSET(max_nal_size), AV_OPT_TYPE_INT, { .i64 = 0 }, 0, INT_MAX, VE },
@@ -159,15 +172,24 @@ FF_ENABLE_DEPRECATION_WARNINGS
         s->slice_mode = SM_FIXEDSLCNUM_SLICE;
 
     if (s->max_nal_size)
-        s->slice_mode = SM_DYN_SLICE;
+        s->slice_mode = SM_SIZELIMITED_SLICE;
 
+#if OPENH264_VER_AT_LEAST(1, 6)
+    param.sSpatialLayers[0].sSliceArgument.uiSliceMode = s->slice_mode;
+    param.sSpatialLayers[0].sSliceArgument.uiSliceNum  = avctx->slices;
+#else
     param.sSpatialLayers[0].sSliceCfg.uiSliceMode               = s->slice_mode;
     param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceNum = avctx->slices;
+#endif
 
-    if (s->slice_mode == SM_DYN_SLICE) {
+    if (s->slice_mode == SM_SIZELIMITED_SLICE) {
         if (s->max_nal_size){
             param.uiMaxNalSize = s->max_nal_size;
+#if OPENH264_VER_AT_LEAST(1, 6)
+            param.sSpatialLayers[0].sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
+#else
             param.sSpatialLayers[0].sSliceCfg.sSliceArgument.uiSliceSizeConstraint = s->max_nal_size;
+#endif
         } else {
             av_log(avctx, AV_LOG_ERROR, "Invalid -max_nal_size, "
                    "specify a valid max_nal_size to use -slice_mode dyn\n");
-- 
2.1.4

